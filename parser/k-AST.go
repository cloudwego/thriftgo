// Code generated by thriftgo (0.4.1) (fastgo). DO NOT EDIT.
package parser

import (
	"fmt"
	"unsafe"

	"github.com/cloudwego/gopkg/protocol/thrift"
)

var ThriftGoUnusedProtection = struct{}{}

func (p *Reference) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Name ID:1 thrift.STRING
	off += 3
	off += 4 + len(p.Name)

	// p.Index ID:2 thrift.I32
	off += 3
	off += 4
	return off + 1
}

func (p *Reference) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *Reference) FastWriteNocopy(b []byte, w thrift.NocopyWriter) (n int) {
	if n = len(p.FastAppend(b[:0])); n > len(b) {
		panic("buffer overflow. concurrency issue?")
	}
	return
}

func (p *Reference) FastAppend(b []byte) []byte {
	if p == nil {
		return append(b, 0)
	}
	x := thrift.BinaryProtocol{}
	_ = x

	// p.Name
	b = append(b, 11, 0, 1)
	b = x.AppendI32(b, int32(len(p.Name)))
	b = append(b, p.Name...)

	// p.Index
	b = append(b, 8, 0, 2)
	b = x.AppendI32(b, int32(p.Index))

	return append(b, 0)
}

func (p *Reference) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x10b: // p.Name ID:1 thrift.STRING
			p.Name, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x208: // p.Index ID:2 thrift.I32
			p.Index, l, err = x.ReadI32(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_Reference[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *Annotation) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Key ID:1 thrift.STRING
	off += 3
	off += 4 + len(p.Key)

	// p.Values ID:2 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Values {
		off += 4 + len(v)
	}
	return off + 1
}

func (p *Annotation) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *Annotation) FastWriteNocopy(b []byte, w thrift.NocopyWriter) (n int) {
	if n = len(p.FastAppend(b[:0])); n > len(b) {
		panic("buffer overflow. concurrency issue?")
	}
	return
}

func (p *Annotation) FastAppend(b []byte) []byte {
	if p == nil {
		return append(b, 0)
	}
	x := thrift.BinaryProtocol{}
	_ = x

	// p.Key
	b = append(b, 11, 0, 1)
	b = x.AppendI32(b, int32(len(p.Key)))
	b = append(b, p.Key...)

	// p.Values
	b = append(b, 15, 0, 2)
	b = x.AppendListBegin(b, thrift.STRING, len(p.Values))
	for _, v := range p.Values {
		b = x.AppendI32(b, int32(len(v)))
		b = append(b, v...)
	}

	return append(b, 0)
}

func (p *Annotation) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x10b: // p.Key ID:1 thrift.STRING
			p.Key, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x20f: // p.Values ID:2 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Values = make([]string, sz)
			for i := 0; i < sz; i++ {
				p.Values[i], l, err = x.ReadString(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_Annotation[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *Type) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Name ID:1 thrift.STRING
	off += 3
	off += 4 + len(p.Name)

	// p.KeyType ID:2 thrift.STRUCT
	if p.KeyType != nil {
		off += 3
		off += p.KeyType.BLength()
	}

	// p.ValueType ID:3 thrift.STRUCT
	if p.ValueType != nil {
		off += 3
		off += p.ValueType.BLength()
	}

	// p.CppType ID:4 thrift.STRING
	off += 3
	off += 4 + len(p.CppType)

	// p.Annotations ID:5 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Annotations {
		off += v.BLength()
	}

	// p.Category ID:6 thrift.I32
	off += 3
	off += 4

	// p.Reference ID:7 thrift.STRUCT
	if p.Reference != nil {
		off += 3
		off += p.Reference.BLength()
	}

	// p.IsTypedef ID:8 thrift.BOOL
	if p.IsTypedef != nil {
		off += 3
		off += 1
	}
	return off + 1
}

func (p *Type) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *Type) FastWriteNocopy(b []byte, w thrift.NocopyWriter) (n int) {
	if n = len(p.FastAppend(b[:0])); n > len(b) {
		panic("buffer overflow. concurrency issue?")
	}
	return
}

func (p *Type) FastAppend(b []byte) []byte {
	if p == nil {
		return append(b, 0)
	}
	x := thrift.BinaryProtocol{}
	_ = x

	// p.Name
	b = append(b, 11, 0, 1)
	b = x.AppendI32(b, int32(len(p.Name)))
	b = append(b, p.Name...)

	// p.KeyType
	if p.KeyType != nil {
		b = append(b, 12, 0, 2)
		b = p.KeyType.FastAppend(b)
	}

	// p.ValueType
	if p.ValueType != nil {
		b = append(b, 12, 0, 3)
		b = p.ValueType.FastAppend(b)
	}

	// p.CppType
	b = append(b, 11, 0, 4)
	b = x.AppendI32(b, int32(len(p.CppType)))
	b = append(b, p.CppType...)

	// p.Annotations
	b = append(b, 15, 0, 5)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Annotations))
	for _, v := range p.Annotations {
		b = v.FastAppend(b)
	}

	// p.Category
	b = append(b, 8, 0, 6)
	b = x.AppendI32(b, int32(p.Category))

	// p.Reference
	if p.Reference != nil {
		b = append(b, 12, 0, 7)
		b = p.Reference.FastAppend(b)
	}

	// p.IsTypedef
	if p.IsTypedef != nil {
		b = append(b, 2, 0, 8)
		b = append(b, *(*byte)(unsafe.Pointer(p.IsTypedef)))
	}

	return append(b, 0)
}

func (p *Type) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	var enum int32
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x10b: // p.Name ID:1 thrift.STRING
			p.Name, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x20c: // p.KeyType ID:2 thrift.STRUCT
			p.KeyType = NewType()
			l, err = p.KeyType.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x30c: // p.ValueType ID:3 thrift.STRUCT
			p.ValueType = NewType()
			l, err = p.ValueType.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x40b: // p.CppType ID:4 thrift.STRING
			p.CppType, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x50f: // p.Annotations ID:5 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Annotations = make(Annotations, sz)
			for i := 0; i < sz; i++ {
				p.Annotations[i] = NewAnnotation()
				l, err = p.Annotations[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x608: // p.Category ID:6 thrift.I32
			enum, l, err = x.ReadI32(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Category = Category(enum)
		case 0x70c: // p.Reference ID:7 thrift.STRUCT
			p.Reference = NewReference()
			l, err = p.Reference.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x802: // p.IsTypedef ID:8 thrift.BOOL
			if p.IsTypedef == nil {
				p.IsTypedef = new(bool)
			}
			*p.IsTypedef, l, err = x.ReadBool(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_Type[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *Namespace) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Language ID:1 thrift.STRING
	off += 3
	off += 4 + len(p.Language)

	// p.Name ID:2 thrift.STRING
	off += 3
	off += 4 + len(p.Name)

	// p.Annotations ID:3 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Annotations {
		off += v.BLength()
	}
	return off + 1
}

func (p *Namespace) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *Namespace) FastWriteNocopy(b []byte, w thrift.NocopyWriter) (n int) {
	if n = len(p.FastAppend(b[:0])); n > len(b) {
		panic("buffer overflow. concurrency issue?")
	}
	return
}

func (p *Namespace) FastAppend(b []byte) []byte {
	if p == nil {
		return append(b, 0)
	}
	x := thrift.BinaryProtocol{}
	_ = x

	// p.Language
	b = append(b, 11, 0, 1)
	b = x.AppendI32(b, int32(len(p.Language)))
	b = append(b, p.Language...)

	// p.Name
	b = append(b, 11, 0, 2)
	b = x.AppendI32(b, int32(len(p.Name)))
	b = append(b, p.Name...)

	// p.Annotations
	b = append(b, 15, 0, 3)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Annotations))
	for _, v := range p.Annotations {
		b = v.FastAppend(b)
	}

	return append(b, 0)
}

func (p *Namespace) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x10b: // p.Language ID:1 thrift.STRING
			p.Language, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x20b: // p.Name ID:2 thrift.STRING
			p.Name, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x30f: // p.Annotations ID:3 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Annotations = make(Annotations, sz)
			for i := 0; i < sz; i++ {
				p.Annotations[i] = NewAnnotation()
				l, err = p.Annotations[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_Namespace[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *Typedef) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Type ID:1 thrift.STRUCT
	if p.Type != nil {
		off += 3
		off += p.Type.BLength()
	}

	// p.Alias ID:2 thrift.STRING
	off += 3
	off += 4 + len(p.Alias)

	// p.Annotations ID:3 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Annotations {
		off += v.BLength()
	}

	// p.ReservedComments ID:4 thrift.STRING
	off += 3
	off += 4 + len(p.ReservedComments)
	return off + 1
}

func (p *Typedef) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *Typedef) FastWriteNocopy(b []byte, w thrift.NocopyWriter) (n int) {
	if n = len(p.FastAppend(b[:0])); n > len(b) {
		panic("buffer overflow. concurrency issue?")
	}
	return
}

func (p *Typedef) FastAppend(b []byte) []byte {
	if p == nil {
		return append(b, 0)
	}
	x := thrift.BinaryProtocol{}
	_ = x

	// p.Type
	if p.Type != nil {
		b = append(b, 12, 0, 1)
		b = p.Type.FastAppend(b)
	}

	// p.Alias
	b = append(b, 11, 0, 2)
	b = x.AppendI32(b, int32(len(p.Alias)))
	b = append(b, p.Alias...)

	// p.Annotations
	b = append(b, 15, 0, 3)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Annotations))
	for _, v := range p.Annotations {
		b = v.FastAppend(b)
	}

	// p.ReservedComments
	b = append(b, 11, 0, 4)
	b = x.AppendI32(b, int32(len(p.ReservedComments)))
	b = append(b, p.ReservedComments...)

	return append(b, 0)
}

func (p *Typedef) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x10c: // p.Type ID:1 thrift.STRUCT
			p.Type = NewType()
			l, err = p.Type.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x20b: // p.Alias ID:2 thrift.STRING
			p.Alias, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x30f: // p.Annotations ID:3 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Annotations = make(Annotations, sz)
			for i := 0; i < sz; i++ {
				p.Annotations[i] = NewAnnotation()
				l, err = p.Annotations[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x40b: // p.ReservedComments ID:4 thrift.STRING
			p.ReservedComments, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_Typedef[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *EnumValue) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Name ID:1 thrift.STRING
	off += 3
	off += 4 + len(p.Name)

	// p.Value ID:2 thrift.I64
	off += 3
	off += 8

	// p.Annotations ID:3 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Annotations {
		off += v.BLength()
	}

	// p.ReservedComments ID:4 thrift.STRING
	off += 3
	off += 4 + len(p.ReservedComments)
	return off + 1
}

func (p *EnumValue) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *EnumValue) FastWriteNocopy(b []byte, w thrift.NocopyWriter) (n int) {
	if n = len(p.FastAppend(b[:0])); n > len(b) {
		panic("buffer overflow. concurrency issue?")
	}
	return
}

func (p *EnumValue) FastAppend(b []byte) []byte {
	if p == nil {
		return append(b, 0)
	}
	x := thrift.BinaryProtocol{}
	_ = x

	// p.Name
	b = append(b, 11, 0, 1)
	b = x.AppendI32(b, int32(len(p.Name)))
	b = append(b, p.Name...)

	// p.Value
	b = append(b, 10, 0, 2)
	b = x.AppendI64(b, int64(p.Value))

	// p.Annotations
	b = append(b, 15, 0, 3)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Annotations))
	for _, v := range p.Annotations {
		b = v.FastAppend(b)
	}

	// p.ReservedComments
	b = append(b, 11, 0, 4)
	b = x.AppendI32(b, int32(len(p.ReservedComments)))
	b = append(b, p.ReservedComments...)

	return append(b, 0)
}

func (p *EnumValue) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x10b: // p.Name ID:1 thrift.STRING
			p.Name, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x20a: // p.Value ID:2 thrift.I64
			p.Value, l, err = x.ReadI64(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x30f: // p.Annotations ID:3 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Annotations = make(Annotations, sz)
			for i := 0; i < sz; i++ {
				p.Annotations[i] = NewAnnotation()
				l, err = p.Annotations[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x40b: // p.ReservedComments ID:4 thrift.STRING
			p.ReservedComments, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_EnumValue[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *Enum) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Name ID:1 thrift.STRING
	off += 3
	off += 4 + len(p.Name)

	// p.Values ID:2 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Values {
		off += v.BLength()
	}

	// p.Annotations ID:3 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Annotations {
		off += v.BLength()
	}

	// p.ReservedComments ID:4 thrift.STRING
	off += 3
	off += 4 + len(p.ReservedComments)
	return off + 1
}

func (p *Enum) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *Enum) FastWriteNocopy(b []byte, w thrift.NocopyWriter) (n int) {
	if n = len(p.FastAppend(b[:0])); n > len(b) {
		panic("buffer overflow. concurrency issue?")
	}
	return
}

func (p *Enum) FastAppend(b []byte) []byte {
	if p == nil {
		return append(b, 0)
	}
	x := thrift.BinaryProtocol{}
	_ = x

	// p.Name
	b = append(b, 11, 0, 1)
	b = x.AppendI32(b, int32(len(p.Name)))
	b = append(b, p.Name...)

	// p.Values
	b = append(b, 15, 0, 2)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Values))
	for _, v := range p.Values {
		b = v.FastAppend(b)
	}

	// p.Annotations
	b = append(b, 15, 0, 3)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Annotations))
	for _, v := range p.Annotations {
		b = v.FastAppend(b)
	}

	// p.ReservedComments
	b = append(b, 11, 0, 4)
	b = x.AppendI32(b, int32(len(p.ReservedComments)))
	b = append(b, p.ReservedComments...)

	return append(b, 0)
}

func (p *Enum) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x10b: // p.Name ID:1 thrift.STRING
			p.Name, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x20f: // p.Values ID:2 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Values = make([]*EnumValue, sz)
			for i := 0; i < sz; i++ {
				p.Values[i] = NewEnumValue()
				l, err = p.Values[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x30f: // p.Annotations ID:3 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Annotations = make(Annotations, sz)
			for i := 0; i < sz; i++ {
				p.Annotations[i] = NewAnnotation()
				l, err = p.Annotations[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x40b: // p.ReservedComments ID:4 thrift.STRING
			p.ReservedComments, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_Enum[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *ConstValueExtra) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.IsEnum ID:1 thrift.BOOL
	off += 3
	off += 1

	// p.Index ID:2 thrift.I32
	off += 3
	off += 4

	// p.Name ID:3 thrift.STRING
	off += 3
	off += 4 + len(p.Name)

	// p.Sel ID:4 thrift.STRING
	off += 3
	off += 4 + len(p.Sel)
	return off + 1
}

func (p *ConstValueExtra) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *ConstValueExtra) FastWriteNocopy(b []byte, w thrift.NocopyWriter) (n int) {
	if n = len(p.FastAppend(b[:0])); n > len(b) {
		panic("buffer overflow. concurrency issue?")
	}
	return
}

func (p *ConstValueExtra) FastAppend(b []byte) []byte {
	if p == nil {
		return append(b, 0)
	}
	x := thrift.BinaryProtocol{}
	_ = x

	// p.IsEnum
	b = append(b, 2, 0, 1)
	b = append(b, *(*byte)(unsafe.Pointer(&p.IsEnum)))

	// p.Index
	b = append(b, 8, 0, 2)
	b = x.AppendI32(b, int32(p.Index))

	// p.Name
	b = append(b, 11, 0, 3)
	b = x.AppendI32(b, int32(len(p.Name)))
	b = append(b, p.Name...)

	// p.Sel
	b = append(b, 11, 0, 4)
	b = x.AppendI32(b, int32(len(p.Sel)))
	b = append(b, p.Sel...)

	return append(b, 0)
}

func (p *ConstValueExtra) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x102: // p.IsEnum ID:1 thrift.BOOL
			p.IsEnum, l, err = x.ReadBool(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x208: // p.Index ID:2 thrift.I32
			p.Index, l, err = x.ReadI32(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x30b: // p.Name ID:3 thrift.STRING
			p.Name, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x40b: // p.Sel ID:4 thrift.STRING
			p.Sel, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_ConstValueExtra[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *ConstValue) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Type ID:1 thrift.I32
	off += 3
	off += 4

	// p.TypedValue ID:2 thrift.STRUCT
	if p.TypedValue != nil {
		off += 3
		off += p.TypedValue.BLength()
	}

	// p.Extra ID:3 thrift.STRUCT
	if p.Extra != nil {
		off += 3
		off += p.Extra.BLength()
	}
	return off + 1
}

func (p *ConstValue) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *ConstValue) FastWriteNocopy(b []byte, w thrift.NocopyWriter) (n int) {
	if n = len(p.FastAppend(b[:0])); n > len(b) {
		panic("buffer overflow. concurrency issue?")
	}
	return
}

func (p *ConstValue) FastAppend(b []byte) []byte {
	if p == nil {
		return append(b, 0)
	}
	x := thrift.BinaryProtocol{}
	_ = x

	// p.Type
	b = append(b, 8, 0, 1)
	b = x.AppendI32(b, int32(p.Type))

	// p.TypedValue
	if p.TypedValue != nil {
		b = append(b, 12, 0, 2)
		b = p.TypedValue.FastAppend(b)
	}

	// p.Extra
	if p.Extra != nil {
		b = append(b, 12, 0, 3)
		b = p.Extra.FastAppend(b)
	}

	return append(b, 0)
}

func (p *ConstValue) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	var enum int32
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x108: // p.Type ID:1 thrift.I32
			enum, l, err = x.ReadI32(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Type = ConstType(enum)
		case 0x20c: // p.TypedValue ID:2 thrift.STRUCT
			p.TypedValue = NewConstTypedValue()
			l, err = p.TypedValue.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x30c: // p.Extra ID:3 thrift.STRUCT
			p.Extra = NewConstValueExtra()
			l, err = p.Extra.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_ConstValue[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *MapConstValue) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Key ID:1 thrift.STRUCT
	if p.Key != nil {
		off += 3
		off += p.Key.BLength()
	}

	// p.Value ID:2 thrift.STRUCT
	if p.Value != nil {
		off += 3
		off += p.Value.BLength()
	}
	return off + 1
}

func (p *MapConstValue) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *MapConstValue) FastWriteNocopy(b []byte, w thrift.NocopyWriter) (n int) {
	if n = len(p.FastAppend(b[:0])); n > len(b) {
		panic("buffer overflow. concurrency issue?")
	}
	return
}

func (p *MapConstValue) FastAppend(b []byte) []byte {
	if p == nil {
		return append(b, 0)
	}
	x := thrift.BinaryProtocol{}
	_ = x

	// p.Key
	if p.Key != nil {
		b = append(b, 12, 0, 1)
		b = p.Key.FastAppend(b)
	}

	// p.Value
	if p.Value != nil {
		b = append(b, 12, 0, 2)
		b = p.Value.FastAppend(b)
	}

	return append(b, 0)
}

func (p *MapConstValue) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x10c: // p.Key ID:1 thrift.STRUCT
			p.Key = NewConstValue()
			l, err = p.Key.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x20c: // p.Value ID:2 thrift.STRUCT
			p.Value = NewConstValue()
			l, err = p.Value.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_MapConstValue[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *Constant) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Name ID:1 thrift.STRING
	off += 3
	off += 4 + len(p.Name)

	// p.Type ID:2 thrift.STRUCT
	if p.Type != nil {
		off += 3
		off += p.Type.BLength()
	}

	// p.Value ID:3 thrift.STRUCT
	if p.Value != nil {
		off += 3
		off += p.Value.BLength()
	}

	// p.Annotations ID:4 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Annotations {
		off += v.BLength()
	}

	// p.ReservedComments ID:5 thrift.STRING
	off += 3
	off += 4 + len(p.ReservedComments)
	return off + 1
}

func (p *Constant) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *Constant) FastWriteNocopy(b []byte, w thrift.NocopyWriter) (n int) {
	if n = len(p.FastAppend(b[:0])); n > len(b) {
		panic("buffer overflow. concurrency issue?")
	}
	return
}

func (p *Constant) FastAppend(b []byte) []byte {
	if p == nil {
		return append(b, 0)
	}
	x := thrift.BinaryProtocol{}
	_ = x

	// p.Name
	b = append(b, 11, 0, 1)
	b = x.AppendI32(b, int32(len(p.Name)))
	b = append(b, p.Name...)

	// p.Type
	if p.Type != nil {
		b = append(b, 12, 0, 2)
		b = p.Type.FastAppend(b)
	}

	// p.Value
	if p.Value != nil {
		b = append(b, 12, 0, 3)
		b = p.Value.FastAppend(b)
	}

	// p.Annotations
	b = append(b, 15, 0, 4)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Annotations))
	for _, v := range p.Annotations {
		b = v.FastAppend(b)
	}

	// p.ReservedComments
	b = append(b, 11, 0, 5)
	b = x.AppendI32(b, int32(len(p.ReservedComments)))
	b = append(b, p.ReservedComments...)

	return append(b, 0)
}

func (p *Constant) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x10b: // p.Name ID:1 thrift.STRING
			p.Name, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x20c: // p.Type ID:2 thrift.STRUCT
			p.Type = NewType()
			l, err = p.Type.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x30c: // p.Value ID:3 thrift.STRUCT
			p.Value = NewConstValue()
			l, err = p.Value.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x40f: // p.Annotations ID:4 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Annotations = make(Annotations, sz)
			for i := 0; i < sz; i++ {
				p.Annotations[i] = NewAnnotation()
				l, err = p.Annotations[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x50b: // p.ReservedComments ID:5 thrift.STRING
			p.ReservedComments, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_Constant[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *Field) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.ID ID:1 thrift.I32
	off += 3
	off += 4

	// p.Name ID:2 thrift.STRING
	off += 3
	off += 4 + len(p.Name)

	// p.Requiredness ID:3 thrift.I32
	off += 3
	off += 4

	// p.Type ID:4 thrift.STRUCT
	off += 3
	off += p.Type.BLength()

	// p.Default ID:5 thrift.STRUCT
	if p.Default != nil {
		off += 3
		off += p.Default.BLength()
	}

	// p.Annotations ID:6 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Annotations {
		off += v.BLength()
	}

	// p.ReservedComments ID:7 thrift.STRING
	off += 3
	off += 4 + len(p.ReservedComments)
	return off + 1
}

func (p *Field) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *Field) FastWriteNocopy(b []byte, w thrift.NocopyWriter) (n int) {
	if n = len(p.FastAppend(b[:0])); n > len(b) {
		panic("buffer overflow. concurrency issue?")
	}
	return
}

func (p *Field) FastAppend(b []byte) []byte {
	if p == nil {
		return append(b, 0)
	}
	x := thrift.BinaryProtocol{}
	_ = x

	// p.ID
	b = append(b, 8, 0, 1)
	b = x.AppendI32(b, int32(p.ID))

	// p.Name
	b = append(b, 11, 0, 2)
	b = x.AppendI32(b, int32(len(p.Name)))
	b = append(b, p.Name...)

	// p.Requiredness
	b = append(b, 8, 0, 3)
	b = x.AppendI32(b, int32(p.Requiredness))

	// p.Type
	b = append(b, 12, 0, 4)
	b = p.Type.FastAppend(b)

	// p.Default
	if p.Default != nil {
		b = append(b, 12, 0, 5)
		b = p.Default.FastAppend(b)
	}

	// p.Annotations
	b = append(b, 15, 0, 6)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Annotations))
	for _, v := range p.Annotations {
		b = v.FastAppend(b)
	}

	// p.ReservedComments
	b = append(b, 11, 0, 7)
	b = x.AppendI32(b, int32(len(p.ReservedComments)))
	b = append(b, p.ReservedComments...)

	return append(b, 0)
}

func (p *Field) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	var enum int32
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x108: // p.ID ID:1 thrift.I32
			p.ID, l, err = x.ReadI32(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x20b: // p.Name ID:2 thrift.STRING
			p.Name, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x308: // p.Requiredness ID:3 thrift.I32
			enum, l, err = x.ReadI32(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Requiredness = FieldType(enum)
		case 0x40c: // p.Type ID:4 thrift.STRUCT
			p.Type = NewType()
			l, err = p.Type.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x50c: // p.Default ID:5 thrift.STRUCT
			p.Default = NewConstValue()
			l, err = p.Default.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x60f: // p.Annotations ID:6 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Annotations = make(Annotations, sz)
			for i := 0; i < sz; i++ {
				p.Annotations[i] = NewAnnotation()
				l, err = p.Annotations[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x70b: // p.ReservedComments ID:7 thrift.STRING
			p.ReservedComments, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_Field[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *StructLike) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Category ID:1 thrift.STRING
	off += 3
	off += 4 + len(p.Category)

	// p.Name ID:2 thrift.STRING
	off += 3
	off += 4 + len(p.Name)

	// p.Fields ID:3 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Fields {
		off += v.BLength()
	}

	// p.Annotations ID:4 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Annotations {
		off += v.BLength()
	}

	// p.ReservedComments ID:5 thrift.STRING
	off += 3
	off += 4 + len(p.ReservedComments)
	return off + 1
}

func (p *StructLike) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *StructLike) FastWriteNocopy(b []byte, w thrift.NocopyWriter) (n int) {
	if n = len(p.FastAppend(b[:0])); n > len(b) {
		panic("buffer overflow. concurrency issue?")
	}
	return
}

func (p *StructLike) FastAppend(b []byte) []byte {
	if p == nil {
		return append(b, 0)
	}
	x := thrift.BinaryProtocol{}
	_ = x

	// p.Category
	b = append(b, 11, 0, 1)
	b = x.AppendI32(b, int32(len(p.Category)))
	b = append(b, p.Category...)

	// p.Name
	b = append(b, 11, 0, 2)
	b = x.AppendI32(b, int32(len(p.Name)))
	b = append(b, p.Name...)

	// p.Fields
	b = append(b, 15, 0, 3)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Fields))
	for _, v := range p.Fields {
		b = v.FastAppend(b)
	}

	// p.Annotations
	b = append(b, 15, 0, 4)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Annotations))
	for _, v := range p.Annotations {
		b = v.FastAppend(b)
	}

	// p.ReservedComments
	b = append(b, 11, 0, 5)
	b = x.AppendI32(b, int32(len(p.ReservedComments)))
	b = append(b, p.ReservedComments...)

	return append(b, 0)
}

func (p *StructLike) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x10b: // p.Category ID:1 thrift.STRING
			p.Category, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x20b: // p.Name ID:2 thrift.STRING
			p.Name, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x30f: // p.Fields ID:3 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Fields = make([]*Field, sz)
			for i := 0; i < sz; i++ {
				p.Fields[i] = NewField()
				l, err = p.Fields[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x40f: // p.Annotations ID:4 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Annotations = make(Annotations, sz)
			for i := 0; i < sz; i++ {
				p.Annotations[i] = NewAnnotation()
				l, err = p.Annotations[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x50b: // p.ReservedComments ID:5 thrift.STRING
			p.ReservedComments, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_StructLike[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *Function) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Name ID:1 thrift.STRING
	off += 3
	off += 4 + len(p.Name)

	// p.Oneway ID:2 thrift.BOOL
	off += 3
	off += 1

	// p.Void ID:3 thrift.BOOL
	off += 3
	off += 1

	// p.FunctionType ID:4 thrift.STRUCT
	if p.FunctionType != nil {
		off += 3
		off += p.FunctionType.BLength()
	}

	// p.Arguments ID:5 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Arguments {
		off += v.BLength()
	}

	// p.Throws ID:6 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Throws {
		off += v.BLength()
	}

	// p.Annotations ID:7 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Annotations {
		off += v.BLength()
	}

	// p.ReservedComments ID:8 thrift.STRING
	off += 3
	off += 4 + len(p.ReservedComments)
	return off + 1
}

func (p *Function) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *Function) FastWriteNocopy(b []byte, w thrift.NocopyWriter) (n int) {
	if n = len(p.FastAppend(b[:0])); n > len(b) {
		panic("buffer overflow. concurrency issue?")
	}
	return
}

func (p *Function) FastAppend(b []byte) []byte {
	if p == nil {
		return append(b, 0)
	}
	x := thrift.BinaryProtocol{}
	_ = x

	// p.Name
	b = append(b, 11, 0, 1)
	b = x.AppendI32(b, int32(len(p.Name)))
	b = append(b, p.Name...)

	// p.Oneway
	b = append(b, 2, 0, 2)
	b = append(b, *(*byte)(unsafe.Pointer(&p.Oneway)))

	// p.Void
	b = append(b, 2, 0, 3)
	b = append(b, *(*byte)(unsafe.Pointer(&p.Void)))

	// p.FunctionType
	if p.FunctionType != nil {
		b = append(b, 12, 0, 4)
		b = p.FunctionType.FastAppend(b)
	}

	// p.Arguments
	b = append(b, 15, 0, 5)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Arguments))
	for _, v := range p.Arguments {
		b = v.FastAppend(b)
	}

	// p.Throws
	b = append(b, 15, 0, 6)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Throws))
	for _, v := range p.Throws {
		b = v.FastAppend(b)
	}

	// p.Annotations
	b = append(b, 15, 0, 7)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Annotations))
	for _, v := range p.Annotations {
		b = v.FastAppend(b)
	}

	// p.ReservedComments
	b = append(b, 11, 0, 8)
	b = x.AppendI32(b, int32(len(p.ReservedComments)))
	b = append(b, p.ReservedComments...)

	return append(b, 0)
}

func (p *Function) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x10b: // p.Name ID:1 thrift.STRING
			p.Name, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x202: // p.Oneway ID:2 thrift.BOOL
			p.Oneway, l, err = x.ReadBool(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x302: // p.Void ID:3 thrift.BOOL
			p.Void, l, err = x.ReadBool(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x40c: // p.FunctionType ID:4 thrift.STRUCT
			p.FunctionType = NewType()
			l, err = p.FunctionType.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x50f: // p.Arguments ID:5 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Arguments = make([]*Field, sz)
			for i := 0; i < sz; i++ {
				p.Arguments[i] = NewField()
				l, err = p.Arguments[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x60f: // p.Throws ID:6 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Throws = make([]*Field, sz)
			for i := 0; i < sz; i++ {
				p.Throws[i] = NewField()
				l, err = p.Throws[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x70f: // p.Annotations ID:7 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Annotations = make(Annotations, sz)
			for i := 0; i < sz; i++ {
				p.Annotations[i] = NewAnnotation()
				l, err = p.Annotations[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x80b: // p.ReservedComments ID:8 thrift.STRING
			p.ReservedComments, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_Function[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *Service) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Name ID:1 thrift.STRING
	off += 3
	off += 4 + len(p.Name)

	// p.Extends ID:2 thrift.STRING
	off += 3
	off += 4 + len(p.Extends)

	// p.Functions ID:3 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Functions {
		off += v.BLength()
	}

	// p.Annotations ID:4 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Annotations {
		off += v.BLength()
	}

	// p.Reference ID:5 thrift.STRUCT
	if p.Reference != nil {
		off += 3
		off += p.Reference.BLength()
	}

	// p.ReservedComments ID:6 thrift.STRING
	off += 3
	off += 4 + len(p.ReservedComments)
	return off + 1
}

func (p *Service) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *Service) FastWriteNocopy(b []byte, w thrift.NocopyWriter) (n int) {
	if n = len(p.FastAppend(b[:0])); n > len(b) {
		panic("buffer overflow. concurrency issue?")
	}
	return
}

func (p *Service) FastAppend(b []byte) []byte {
	if p == nil {
		return append(b, 0)
	}
	x := thrift.BinaryProtocol{}
	_ = x

	// p.Name
	b = append(b, 11, 0, 1)
	b = x.AppendI32(b, int32(len(p.Name)))
	b = append(b, p.Name...)

	// p.Extends
	b = append(b, 11, 0, 2)
	b = x.AppendI32(b, int32(len(p.Extends)))
	b = append(b, p.Extends...)

	// p.Functions
	b = append(b, 15, 0, 3)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Functions))
	for _, v := range p.Functions {
		b = v.FastAppend(b)
	}

	// p.Annotations
	b = append(b, 15, 0, 4)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Annotations))
	for _, v := range p.Annotations {
		b = v.FastAppend(b)
	}

	// p.Reference
	if p.Reference != nil {
		b = append(b, 12, 0, 5)
		b = p.Reference.FastAppend(b)
	}

	// p.ReservedComments
	b = append(b, 11, 0, 6)
	b = x.AppendI32(b, int32(len(p.ReservedComments)))
	b = append(b, p.ReservedComments...)

	return append(b, 0)
}

func (p *Service) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x10b: // p.Name ID:1 thrift.STRING
			p.Name, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x20b: // p.Extends ID:2 thrift.STRING
			p.Extends, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x30f: // p.Functions ID:3 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Functions = make([]*Function, sz)
			for i := 0; i < sz; i++ {
				p.Functions[i] = NewFunction()
				l, err = p.Functions[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x40f: // p.Annotations ID:4 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Annotations = make(Annotations, sz)
			for i := 0; i < sz; i++ {
				p.Annotations[i] = NewAnnotation()
				l, err = p.Annotations[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x50c: // p.Reference ID:5 thrift.STRUCT
			p.Reference = NewReference()
			l, err = p.Reference.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x60b: // p.ReservedComments ID:6 thrift.STRING
			p.ReservedComments, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_Service[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *Include) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Path ID:1 thrift.STRING
	off += 3
	off += 4 + len(p.Path)

	// p.Reference ID:2 thrift.STRUCT
	if p.Reference != nil {
		off += 3
		off += p.Reference.BLength()
	}

	// p.Used ID:3 thrift.BOOL
	if p.Used != nil {
		off += 3
		off += 1
	}
	return off + 1
}

func (p *Include) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *Include) FastWriteNocopy(b []byte, w thrift.NocopyWriter) (n int) {
	if n = len(p.FastAppend(b[:0])); n > len(b) {
		panic("buffer overflow. concurrency issue?")
	}
	return
}

func (p *Include) FastAppend(b []byte) []byte {
	if p == nil {
		return append(b, 0)
	}
	x := thrift.BinaryProtocol{}
	_ = x

	// p.Path
	b = append(b, 11, 0, 1)
	b = x.AppendI32(b, int32(len(p.Path)))
	b = append(b, p.Path...)

	// p.Reference
	if p.Reference != nil {
		b = append(b, 12, 0, 2)
		b = p.Reference.FastAppend(b)
	}

	// p.Used
	if p.Used != nil {
		b = append(b, 2, 0, 3)
		b = append(b, *(*byte)(unsafe.Pointer(p.Used)))
	}

	return append(b, 0)
}

func (p *Include) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x10b: // p.Path ID:1 thrift.STRING
			p.Path, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x20c: // p.Reference ID:2 thrift.STRUCT
			p.Reference = NewThrift()
			l, err = p.Reference.FastRead(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x302: // p.Used ID:3 thrift.BOOL
			if p.Used == nil {
				p.Used = new(bool)
			}
			*p.Used, l, err = x.ReadBool(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_Include[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *Thrift) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Filename ID:1 thrift.STRING
	off += 3
	off += 4 + len(p.Filename)

	// p.Includes ID:2 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Includes {
		off += v.BLength()
	}

	// p.CppIncludes ID:3 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.CppIncludes {
		off += 4 + len(v)
	}

	// p.Namespaces ID:4 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Namespaces {
		off += v.BLength()
	}

	// p.Typedefs ID:5 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Typedefs {
		off += v.BLength()
	}

	// p.Constants ID:6 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Constants {
		off += v.BLength()
	}

	// p.Enums ID:7 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Enums {
		off += v.BLength()
	}

	// p.Structs ID:8 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Structs {
		off += v.BLength()
	}

	// p.Unions ID:9 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Unions {
		off += v.BLength()
	}

	// p.Exceptions ID:10 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Exceptions {
		off += v.BLength()
	}

	// p.Services ID:11 thrift.LIST
	off += 3
	off += 5
	for _, v := range p.Services {
		off += v.BLength()
	}

	// p.Name2Category ID:12 thrift.MAP
	off += 3
	off += 6
	off += len(p.Name2Category) * 4
	for k, _ := range p.Name2Category {
		off += 4 + len(k)
	}
	return off + 1
}

func (p *Thrift) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *Thrift) FastWriteNocopy(b []byte, w thrift.NocopyWriter) (n int) {
	if n = len(p.FastAppend(b[:0])); n > len(b) {
		panic("buffer overflow. concurrency issue?")
	}
	return
}

func (p *Thrift) FastAppend(b []byte) []byte {
	if p == nil {
		return append(b, 0)
	}
	x := thrift.BinaryProtocol{}
	_ = x

	// p.Filename
	b = append(b, 11, 0, 1)
	b = x.AppendI32(b, int32(len(p.Filename)))
	b = append(b, p.Filename...)

	// p.Includes
	b = append(b, 15, 0, 2)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Includes))
	for _, v := range p.Includes {
		b = v.FastAppend(b)
	}

	// p.CppIncludes
	b = append(b, 15, 0, 3)
	b = x.AppendListBegin(b, thrift.STRING, len(p.CppIncludes))
	for _, v := range p.CppIncludes {
		b = x.AppendI32(b, int32(len(v)))
		b = append(b, v...)
	}

	// p.Namespaces
	b = append(b, 15, 0, 4)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Namespaces))
	for _, v := range p.Namespaces {
		b = v.FastAppend(b)
	}

	// p.Typedefs
	b = append(b, 15, 0, 5)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Typedefs))
	for _, v := range p.Typedefs {
		b = v.FastAppend(b)
	}

	// p.Constants
	b = append(b, 15, 0, 6)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Constants))
	for _, v := range p.Constants {
		b = v.FastAppend(b)
	}

	// p.Enums
	b = append(b, 15, 0, 7)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Enums))
	for _, v := range p.Enums {
		b = v.FastAppend(b)
	}

	// p.Structs
	b = append(b, 15, 0, 8)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Structs))
	for _, v := range p.Structs {
		b = v.FastAppend(b)
	}

	// p.Unions
	b = append(b, 15, 0, 9)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Unions))
	for _, v := range p.Unions {
		b = v.FastAppend(b)
	}

	// p.Exceptions
	b = append(b, 15, 0, 10)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Exceptions))
	for _, v := range p.Exceptions {
		b = v.FastAppend(b)
	}

	// p.Services
	b = append(b, 15, 0, 11)
	b = x.AppendListBegin(b, thrift.STRUCT, len(p.Services))
	for _, v := range p.Services {
		b = v.FastAppend(b)
	}

	// p.Name2Category
	b = append(b, 13, 0, 12)
	b = x.AppendMapBegin(b, thrift.STRING, thrift.I32, len(p.Name2Category))
	for k, v := range p.Name2Category {
		b = x.AppendI32(b, int32(len(k)))
		b = append(b, k...)
		b = x.AppendI32(b, int32(v))
	}

	return append(b, 0)
}

func (p *Thrift) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	var enum int32
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x10b: // p.Filename ID:1 thrift.STRING
			p.Filename, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x20f: // p.Includes ID:2 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Includes = make([]*Include, sz)
			for i := 0; i < sz; i++ {
				p.Includes[i] = NewInclude()
				l, err = p.Includes[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x30f: // p.CppIncludes ID:3 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.CppIncludes = make([]string, sz)
			for i := 0; i < sz; i++ {
				p.CppIncludes[i], l, err = x.ReadString(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x40f: // p.Namespaces ID:4 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Namespaces = make([]*Namespace, sz)
			for i := 0; i < sz; i++ {
				p.Namespaces[i] = NewNamespace()
				l, err = p.Namespaces[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x50f: // p.Typedefs ID:5 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Typedefs = make([]*Typedef, sz)
			for i := 0; i < sz; i++ {
				p.Typedefs[i] = NewTypedef()
				l, err = p.Typedefs[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x60f: // p.Constants ID:6 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Constants = make([]*Constant, sz)
			for i := 0; i < sz; i++ {
				p.Constants[i] = NewConstant()
				l, err = p.Constants[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x70f: // p.Enums ID:7 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Enums = make([]*Enum, sz)
			for i := 0; i < sz; i++ {
				p.Enums[i] = NewEnum()
				l, err = p.Enums[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x80f: // p.Structs ID:8 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Structs = make([]*StructLike, sz)
			for i := 0; i < sz; i++ {
				p.Structs[i] = NewStructLike()
				l, err = p.Structs[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x90f: // p.Unions ID:9 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Unions = make([]*StructLike, sz)
			for i := 0; i < sz; i++ {
				p.Unions[i] = NewStructLike()
				l, err = p.Unions[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0xa0f: // p.Exceptions ID:10 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Exceptions = make([]*StructLike, sz)
			for i := 0; i < sz; i++ {
				p.Exceptions[i] = NewStructLike()
				l, err = p.Exceptions[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0xb0f: // p.Services ID:11 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Services = make([]*Service, sz)
			for i := 0; i < sz; i++ {
				p.Services[i] = NewService()
				l, err = p.Services[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0xc0d: // p.Name2Category ID:12 thrift.MAP
			var sz int
			_, _, sz, l, err = x.ReadMapBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Name2Category = make(map[string]Category, sz)
			for i := 0; i < sz; i++ {
				var k string
				var v Category
				k, l, err = x.ReadString(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				enum, l, err = x.ReadI32(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
				v = Category(enum)
				p.Name2Category[k] = v
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_Thrift[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}

func (p *ConstTypedValue) BLength() int {
	if p == nil {
		return 1
	}
	off := 0

	// p.Double ID:1 thrift.DOUBLE
	if p.Double != nil {
		off += 3
		off += 8
	}

	// p.Int ID:2 thrift.I64
	if p.Int != nil {
		off += 3
		off += 8
	}

	// p.Literal ID:3 thrift.STRING
	if p.Literal != nil {
		off += 3
		off += 4 + len(*p.Literal)
	}

	// p.Identifier ID:4 thrift.STRING
	if p.Identifier != nil {
		off += 3
		off += 4 + len(*p.Identifier)
	}

	// p.List ID:5 thrift.LIST
	if p.List != nil {
		off += 3
		off += 5
		for _, v := range p.List {
			off += v.BLength()
		}
	}

	// p.Map ID:6 thrift.LIST
	if p.Map != nil {
		off += 3
		off += 5
		for _, v := range p.Map {
			off += v.BLength()
		}
	}
	return off + 1
}

func (p *ConstTypedValue) FastWrite(b []byte) int { return p.FastWriteNocopy(b, nil) }

func (p *ConstTypedValue) FastWriteNocopy(b []byte, w thrift.NocopyWriter) (n int) {
	if n = len(p.FastAppend(b[:0])); n > len(b) {
		panic("buffer overflow. concurrency issue?")
	}
	return
}

func (p *ConstTypedValue) FastAppend(b []byte) []byte {
	if p == nil {
		return append(b, 0)
	}
	x := thrift.BinaryProtocol{}
	_ = x

	// p.Double
	if p.Double != nil {
		b = append(b, 4, 0, 1)
		b = x.AppendDouble(b, float64(*p.Double))
	}

	// p.Int
	if p.Int != nil {
		b = append(b, 10, 0, 2)
		b = x.AppendI64(b, int64(*p.Int))
	}

	// p.Literal
	if p.Literal != nil {
		b = append(b, 11, 0, 3)
		b = x.AppendI32(b, int32(len(*p.Literal)))
		b = append(b, *p.Literal...)
	}

	// p.Identifier
	if p.Identifier != nil {
		b = append(b, 11, 0, 4)
		b = x.AppendI32(b, int32(len(*p.Identifier)))
		b = append(b, *p.Identifier...)
	}

	// p.List
	if p.List != nil {
		b = append(b, 15, 0, 5)
		b = x.AppendListBegin(b, thrift.STRUCT, len(p.List))
		for _, v := range p.List {
			b = v.FastAppend(b)
		}
	}

	// p.Map
	if p.Map != nil {
		b = append(b, 15, 0, 6)
		b = x.AppendListBegin(b, thrift.STRUCT, len(p.Map))
		for _, v := range p.Map {
			b = v.FastAppend(b)
		}
	}

	return append(b, 0)
}

func (p *ConstTypedValue) FastRead(b []byte) (off int, err error) {
	var ftyp thrift.TType
	var fid int16
	var l int
	x := thrift.BinaryProtocol{}
	for {
		ftyp, fid, l, err = x.ReadFieldBegin(b[off:])
		off += l
		if err != nil {
			goto ReadFieldBeginError
		}
		if ftyp == thrift.STOP {
			break
		}
		switch uint32(fid)<<8 | uint32(ftyp) {
		case 0x104: // p.Double ID:1 thrift.DOUBLE
			if p.Double == nil {
				p.Double = new(float64)
			}
			*p.Double, l, err = x.ReadDouble(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x20a: // p.Int ID:2 thrift.I64
			if p.Int == nil {
				p.Int = new(int64)
			}
			*p.Int, l, err = x.ReadI64(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x30b: // p.Literal ID:3 thrift.STRING
			if p.Literal == nil {
				p.Literal = new(string)
			}
			*p.Literal, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x40b: // p.Identifier ID:4 thrift.STRING
			if p.Identifier == nil {
				p.Identifier = new(string)
			}
			*p.Identifier, l, err = x.ReadString(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
		case 0x50f: // p.List ID:5 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.List = make([]*ConstValue, sz)
			for i := 0; i < sz; i++ {
				p.List[i] = NewConstValue()
				l, err = p.List[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		case 0x60f: // p.Map ID:6 thrift.LIST
			var sz int
			_, sz, l, err = x.ReadListBegin(b[off:])
			off += l
			if err != nil {
				goto ReadFieldError
			}
			p.Map = make([]*MapConstValue, sz)
			for i := 0; i < sz; i++ {
				p.Map[i] = NewMapConstValue()
				l, err = p.Map[i].FastRead(b[off:])
				off += l
				if err != nil {
					goto ReadFieldError
				}
			}
		default:
			l, err = x.Skip(b[off:], ftyp)
			off += l
			if err != nil {
				goto SkipFieldError
			}
		}
	}
	return
ReadFieldBeginError:
	return off, thrift.PrependError(fmt.Sprintf("%T read field begin error: ", p), err)
ReadFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T read field %d '%s' error: ", p, fid, fieldIDToName_ConstTypedValue[fid]), err)
SkipFieldError:
	return off, thrift.PrependError(
		fmt.Sprintf("%T skip field %d type %d error: ", p, fid, ftyp), err)
}
