// Code generated by peg. DO NOT EDIT.
// Code generated by peg ./thrift.peg. DO NOT EDIT.

package parser

import (
	"bytes"
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleDocument
	ruleHeader
	ruleInclude
	ruleCppInclude
	ruleHsInclude
	ruleNamespace
	rulePackage
	ruleNamespaceScope
	ruleDefinition
	ruleConst
	ruleTypedef
	ruleEnum
	ruleService
	ruleInteraction
	ruleStruct
	ruleUnion
	ruleException
	ruleExceptionMeta
	ruleExceptionLabel
	ruleField
	ruleFieldId
	ruleFieldReq
	ruleFunction
	ruleReturnClause
	ruleFunctionType
	ruleFunctionMeta
	ruleFunctionLabel
	rulePerforms
	ruleThrows
	ruleFieldType
	ruleBaseType
	ruleContainerType
	ruleMapType
	ruleSetType
	ruleListType
	ruleCppType
	ruleSink
	ruleStream
	ruleConstValue
	ruleIntConstant
	ruleDoubleConstant
	ruleExponent
	ruleAnnotations
	ruleAnnotation
	ruleStructuredAnnotations
	ruleStructuredAnnotation
	ruleConstList
	ruleConstMap
	ruleConstStruct
	ruleEscapeLiteralChar
	ruleLiteral
	ruleIdentifier
	ruleListSeparator
	ruleLetter
	ruleLetterOrDigit
	ruleDigit
	ruleReservedComments
	ruleReservedEndLineComments
	ruleSkip
	ruleSkipLine
	ruleSpace
	ruleIndent
	ruleCarriageReturnLineFeed
	ruleComment
	ruleLongComment
	ruleLineComment
	ruleUnixComment
	ruleBOOL
	ruleBYTE
	ruleI8
	ruleI16
	ruleI32
	ruleI64
	ruleDOUBLE
	ruleSTRING
	ruleBINARY
	ruleCONST
	ruleONEWAY
	ruleREADONLY
	ruleIDEMPOTENT
	ruleTYPEDEF
	ruleMAP
	ruleSET
	ruleLIST
	ruleVOID
	ruleTHROWS
	ruleEXCEPTION
	ruleSAFE
	ruleUNSAFE
	ruleTRANSIENT
	rulePERMANENT
	ruleSTATEFUL
	ruleSERVER
	ruleCLIENT
	ruleEXTENDS
	ruleSERVICE
	ruleINTERACTION
	ruleSTRUCT
	ruleUNION
	ruleENUM
	ruleINCLUDE
	ruleCPPINCLUDE
	ruleHSINCLUDE
	ruleNAMESPACE
	rulePACKAGE
	ruleCPPTYPE
	rulePERFORMS
	ruleSINK
	ruleSTREAM
	ruleLBRK
	ruleRBRK
	ruleLWING
	ruleRWING
	ruleEQUAL
	ruleLPOINT
	ruleRPOINT
	ruleCOMMA
	ruleLPAR
	ruleRPAR
	ruleCOLON
	ruleAT
	rulePegText
)

var rul3s = [...]string{
	"Unknown",
	"Document",
	"Header",
	"Include",
	"CppInclude",
	"HsInclude",
	"Namespace",
	"Package",
	"NamespaceScope",
	"Definition",
	"Const",
	"Typedef",
	"Enum",
	"Service",
	"Interaction",
	"Struct",
	"Union",
	"Exception",
	"ExceptionMeta",
	"ExceptionLabel",
	"Field",
	"FieldId",
	"FieldReq",
	"Function",
	"ReturnClause",
	"FunctionType",
	"FunctionMeta",
	"FunctionLabel",
	"Performs",
	"Throws",
	"FieldType",
	"BaseType",
	"ContainerType",
	"MapType",
	"SetType",
	"ListType",
	"CppType",
	"Sink",
	"Stream",
	"ConstValue",
	"IntConstant",
	"DoubleConstant",
	"Exponent",
	"Annotations",
	"Annotation",
	"StructuredAnnotations",
	"StructuredAnnotation",
	"ConstList",
	"ConstMap",
	"ConstStruct",
	"EscapeLiteralChar",
	"Literal",
	"Identifier",
	"ListSeparator",
	"Letter",
	"LetterOrDigit",
	"Digit",
	"ReservedComments",
	"ReservedEndLineComments",
	"Skip",
	"SkipLine",
	"Space",
	"Indent",
	"CarriageReturnLineFeed",
	"Comment",
	"LongComment",
	"LineComment",
	"UnixComment",
	"BOOL",
	"BYTE",
	"I8",
	"I16",
	"I32",
	"I64",
	"DOUBLE",
	"STRING",
	"BINARY",
	"CONST",
	"ONEWAY",
	"READONLY",
	"IDEMPOTENT",
	"TYPEDEF",
	"MAP",
	"SET",
	"LIST",
	"VOID",
	"THROWS",
	"EXCEPTION",
	"SAFE",
	"UNSAFE",
	"TRANSIENT",
	"PERMANENT",
	"STATEFUL",
	"SERVER",
	"CLIENT",
	"EXTENDS",
	"SERVICE",
	"INTERACTION",
	"STRUCT",
	"UNION",
	"ENUM",
	"INCLUDE",
	"CPPINCLUDE",
	"HSINCLUDE",
	"NAMESPACE",
	"PACKAGE",
	"CPPTYPE",
	"PERFORMS",
	"SINK",
	"STREAM",
	"LBRK",
	"RBRK",
	"LWING",
	"RWING",
	"EQUAL",
	"LPOINT",
	"RPOINT",
	"COMMA",
	"LPAR",
	"RPAR",
	"COLON",
	"AT",
	"PegText",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprint(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type ThriftIDL struct {
	Buffer         string
	buffer         []rune
	rules          [123]func() bool
	parse          func(rule ...int) error
	reset          func()
	Pretty         bool
	disableMemoize bool
	tokens32
}

func (p *ThriftIDL) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *ThriftIDL) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *ThriftIDL
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *ThriftIDL) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *ThriftIDL) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *ThriftIDL) SprintSyntaxTree() string {
	var b bytes.Buffer
	p.WriteSyntaxTree(&b)
	return b.String()
}

func Pretty(pretty bool) func(*ThriftIDL) error {
	return func(p *ThriftIDL) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*ThriftIDL) error {
	return func(p *ThriftIDL) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}

func DisableMemoize() func(*ThriftIDL) error {
	return func(p *ThriftIDL) error {
		p.disableMemoize = true
		return nil
	}
}

type memo struct {
	Matched bool
	Partial []token32
}

type memoKey struct {
	Rule     uint32
	Position uint32
}

func (p *ThriftIDL) Init(options ...func(*ThriftIDL) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
		memoization          map[memoKey]memo
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0
		memoization = make(map[memoKey]memo)
		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	memoize := func(rule uint32, begin uint32, tokenIndexStart uint32, matched bool) {
		if p.disableMemoize {
			return
		}
		key := memoKey{rule, begin}
		if !matched {
			memoization[key] = memo{Matched: false}
		} else {
			t := tree.tree[tokenIndexStart:tokenIndex]
			tokenCopy := make([]token32, len(t))
			copy(tokenCopy, t)
			memoization[key] = memo{Matched: true, Partial: tokenCopy}
		}
	}

	memoizedResult := func(m memo) bool {
		if !m.Matched {
			return false
		}
		tree.tree = append(tree.tree[:tokenIndex], m.Partial...)
		tokenIndex += uint32(len(m.Partial))
		position = m.Partial[len(m.Partial)-1].end
		if tree.tree[tokenIndex-1].begin != position && position > max.end {
			max = tree.tree[tokenIndex-1]
		}
		return true
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	_rules = [...]func() bool{
		nil,
		/* 0 Document <- <(Header* Definition* Skip !.)> */
		func() bool {
			if memoized, ok := memoization[memoKey{0, position}]; ok {
				return memoizedResult(memoized)
			}
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[ruleHeader]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
			l4:
				{
					position5, tokenIndex5 := position, tokenIndex
					if !_rules[ruleDefinition]() {
						goto l5
					}
					goto l4
				l5:
					position, tokenIndex = position5, tokenIndex5
				}
				if !_rules[ruleSkip]() {
					goto l0
				}
				{
					position6, tokenIndex6 := position, tokenIndex
					if !matchDot() {
						goto l6
					}
					goto l0
				l6:
					position, tokenIndex = position6, tokenIndex6
				}
				add(ruleDocument, position1)
			}
			memoize(0, position0, tokenIndex0, true)
			return true
		l0:
			memoize(0, position0, tokenIndex0, false)
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Header <- <(Skip (Include / CppInclude / HsInclude / Namespace / Package) SkipLine)> */
		func() bool {
			if memoized, ok := memoization[memoKey{1, position}]; ok {
				return memoizedResult(memoized)
			}
			position7, tokenIndex7 := position, tokenIndex
			{
				position8 := position
				if !_rules[ruleSkip]() {
					goto l7
				}
				{
					position9, tokenIndex9 := position, tokenIndex
					if !_rules[ruleInclude]() {
						goto l10
					}
					goto l9
				l10:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleCppInclude]() {
						goto l11
					}
					goto l9
				l11:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleHsInclude]() {
						goto l12
					}
					goto l9
				l12:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleNamespace]() {
						goto l13
					}
					goto l9
				l13:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[rulePackage]() {
						goto l7
					}
				}
			l9:
				if !_rules[ruleSkipLine]() {
					goto l7
				}
				add(ruleHeader, position8)
			}
			memoize(1, position7, tokenIndex7, true)
			return true
		l7:
			memoize(1, position7, tokenIndex7, false)
			position, tokenIndex = position7, tokenIndex7
			return false
		},
		/* 2 Include <- <(INCLUDE Literal)> */
		func() bool {
			if memoized, ok := memoization[memoKey{2, position}]; ok {
				return memoizedResult(memoized)
			}
			position14, tokenIndex14 := position, tokenIndex
			{
				position15 := position
				if !_rules[ruleINCLUDE]() {
					goto l14
				}
				if !_rules[ruleLiteral]() {
					goto l14
				}
				add(ruleInclude, position15)
			}
			memoize(2, position14, tokenIndex14, true)
			return true
		l14:
			memoize(2, position14, tokenIndex14, false)
			position, tokenIndex = position14, tokenIndex14
			return false
		},
		/* 3 CppInclude <- <(CPPINCLUDE Literal)> */
		func() bool {
			if memoized, ok := memoization[memoKey{3, position}]; ok {
				return memoizedResult(memoized)
			}
			position16, tokenIndex16 := position, tokenIndex
			{
				position17 := position
				if !_rules[ruleCPPINCLUDE]() {
					goto l16
				}
				if !_rules[ruleLiteral]() {
					goto l16
				}
				add(ruleCppInclude, position17)
			}
			memoize(3, position16, tokenIndex16, true)
			return true
		l16:
			memoize(3, position16, tokenIndex16, false)
			position, tokenIndex = position16, tokenIndex16
			return false
		},
		/* 4 HsInclude <- <(HSINCLUDE Literal)> */
		func() bool {
			if memoized, ok := memoization[memoKey{4, position}]; ok {
				return memoizedResult(memoized)
			}
			position18, tokenIndex18 := position, tokenIndex
			{
				position19 := position
				if !_rules[ruleHSINCLUDE]() {
					goto l18
				}
				if !_rules[ruleLiteral]() {
					goto l18
				}
				add(ruleHsInclude, position19)
			}
			memoize(4, position18, tokenIndex18, true)
			return true
		l18:
			memoize(4, position18, tokenIndex18, false)
			position, tokenIndex = position18, tokenIndex18
			return false
		},
		/* 5 Namespace <- <(NAMESPACE NamespaceScope (Identifier / Literal) Annotations?)> */
		func() bool {
			if memoized, ok := memoization[memoKey{5, position}]; ok {
				return memoizedResult(memoized)
			}
			position20, tokenIndex20 := position, tokenIndex
			{
				position21 := position
				if !_rules[ruleNAMESPACE]() {
					goto l20
				}
				if !_rules[ruleNamespaceScope]() {
					goto l20
				}
				{
					position22, tokenIndex22 := position, tokenIndex
					if !_rules[ruleIdentifier]() {
						goto l23
					}
					goto l22
				l23:
					position, tokenIndex = position22, tokenIndex22
					if !_rules[ruleLiteral]() {
						goto l20
					}
				}
			l22:
				{
					position24, tokenIndex24 := position, tokenIndex
					if !_rules[ruleAnnotations]() {
						goto l24
					}
					goto l25
				l24:
					position, tokenIndex = position24, tokenIndex24
				}
			l25:
				add(ruleNamespace, position21)
			}
			memoize(5, position20, tokenIndex20, true)
			return true
		l20:
			memoize(5, position20, tokenIndex20, false)
			position, tokenIndex = position20, tokenIndex20
			return false
		},
		/* 6 Package <- <(ReservedComments StructuredAnnotations? PACKAGE Literal? ListSeparator?)> */
		func() bool {
			if memoized, ok := memoization[memoKey{6, position}]; ok {
				return memoizedResult(memoized)
			}
			position26, tokenIndex26 := position, tokenIndex
			{
				position27 := position
				if !_rules[ruleReservedComments]() {
					goto l26
				}
				{
					position28, tokenIndex28 := position, tokenIndex
					if !_rules[ruleStructuredAnnotations]() {
						goto l28
					}
					goto l29
				l28:
					position, tokenIndex = position28, tokenIndex28
				}
			l29:
				if !_rules[rulePACKAGE]() {
					goto l26
				}
				{
					position30, tokenIndex30 := position, tokenIndex
					if !_rules[ruleLiteral]() {
						goto l30
					}
					goto l31
				l30:
					position, tokenIndex = position30, tokenIndex30
				}
			l31:
				{
					position32, tokenIndex32 := position, tokenIndex
					if !_rules[ruleListSeparator]() {
						goto l32
					}
					goto l33
				l32:
					position, tokenIndex = position32, tokenIndex32
				}
			l33:
				add(rulePackage, position27)
			}
			memoize(6, position26, tokenIndex26, true)
			return true
		l26:
			memoize(6, position26, tokenIndex26, false)
			position, tokenIndex = position26, tokenIndex26
			return false
		},
		/* 7 NamespaceScope <- <((Skip <'*'> Indent*) / Identifier)> */
		func() bool {
			if memoized, ok := memoization[memoKey{7, position}]; ok {
				return memoizedResult(memoized)
			}
			position34, tokenIndex34 := position, tokenIndex
			{
				position35 := position
				{
					position36, tokenIndex36 := position, tokenIndex
					if !_rules[ruleSkip]() {
						goto l37
					}
					{
						position38 := position
						if buffer[position] != rune('*') {
							goto l37
						}
						position++
						add(rulePegText, position38)
					}
				l39:
					{
						position40, tokenIndex40 := position, tokenIndex
						if !_rules[ruleIndent]() {
							goto l40
						}
						goto l39
					l40:
						position, tokenIndex = position40, tokenIndex40
					}
					goto l36
				l37:
					position, tokenIndex = position36, tokenIndex36
					if !_rules[ruleIdentifier]() {
						goto l34
					}
				}
			l36:
				add(ruleNamespaceScope, position35)
			}
			memoize(7, position34, tokenIndex34, true)
			return true
		l34:
			memoize(7, position34, tokenIndex34, false)
			position, tokenIndex = position34, tokenIndex34
			return false
		},
		/* 8 Definition <- <(ReservedComments Skip (Const / Typedef / Enum / Service / Interaction / Struct / Union / Exception) Annotations? SkipLine)> */
		func() bool {
			if memoized, ok := memoization[memoKey{8, position}]; ok {
				return memoizedResult(memoized)
			}
			position41, tokenIndex41 := position, tokenIndex
			{
				position42 := position
				if !_rules[ruleReservedComments]() {
					goto l41
				}
				if !_rules[ruleSkip]() {
					goto l41
				}
				{
					position43, tokenIndex43 := position, tokenIndex
					if !_rules[ruleConst]() {
						goto l44
					}
					goto l43
				l44:
					position, tokenIndex = position43, tokenIndex43
					if !_rules[ruleTypedef]() {
						goto l45
					}
					goto l43
				l45:
					position, tokenIndex = position43, tokenIndex43
					if !_rules[ruleEnum]() {
						goto l46
					}
					goto l43
				l46:
					position, tokenIndex = position43, tokenIndex43
					if !_rules[ruleService]() {
						goto l47
					}
					goto l43
				l47:
					position, tokenIndex = position43, tokenIndex43
					if !_rules[ruleInteraction]() {
						goto l48
					}
					goto l43
				l48:
					position, tokenIndex = position43, tokenIndex43
					if !_rules[ruleStruct]() {
						goto l49
					}
					goto l43
				l49:
					position, tokenIndex = position43, tokenIndex43
					if !_rules[ruleUnion]() {
						goto l50
					}
					goto l43
				l50:
					position, tokenIndex = position43, tokenIndex43
					if !_rules[ruleException]() {
						goto l41
					}
				}
			l43:
				{
					position51, tokenIndex51 := position, tokenIndex
					if !_rules[ruleAnnotations]() {
						goto l51
					}
					goto l52
				l51:
					position, tokenIndex = position51, tokenIndex51
				}
			l52:
				if !_rules[ruleSkipLine]() {
					goto l41
				}
				add(ruleDefinition, position42)
			}
			memoize(8, position41, tokenIndex41, true)
			return true
		l41:
			memoize(8, position41, tokenIndex41, false)
			position, tokenIndex = position41, tokenIndex41
			return false
		},
		/* 9 Const <- <(StructuredAnnotations? CONST FieldType Identifier EQUAL ConstValue ListSeparator?)> */
		func() bool {
			if memoized, ok := memoization[memoKey{9, position}]; ok {
				return memoizedResult(memoized)
			}
			position53, tokenIndex53 := position, tokenIndex
			{
				position54 := position
				{
					position55, tokenIndex55 := position, tokenIndex
					if !_rules[ruleStructuredAnnotations]() {
						goto l55
					}
					goto l56
				l55:
					position, tokenIndex = position55, tokenIndex55
				}
			l56:
				if !_rules[ruleCONST]() {
					goto l53
				}
				if !_rules[ruleFieldType]() {
					goto l53
				}
				if !_rules[ruleIdentifier]() {
					goto l53
				}
				if !_rules[ruleEQUAL]() {
					goto l53
				}
				if !_rules[ruleConstValue]() {
					goto l53
				}
				{
					position57, tokenIndex57 := position, tokenIndex
					if !_rules[ruleListSeparator]() {
						goto l57
					}
					goto l58
				l57:
					position, tokenIndex = position57, tokenIndex57
				}
			l58:
				add(ruleConst, position54)
			}
			memoize(9, position53, tokenIndex53, true)
			return true
		l53:
			memoize(9, position53, tokenIndex53, false)
			position, tokenIndex = position53, tokenIndex53
			return false
		},
		/* 10 Typedef <- <(StructuredAnnotations? TYPEDEF FieldType Identifier ListSeparator?)> */
		func() bool {
			if memoized, ok := memoization[memoKey{10, position}]; ok {
				return memoizedResult(memoized)
			}
			position59, tokenIndex59 := position, tokenIndex
			{
				position60 := position
				{
					position61, tokenIndex61 := position, tokenIndex
					if !_rules[ruleStructuredAnnotations]() {
						goto l61
					}
					goto l62
				l61:
					position, tokenIndex = position61, tokenIndex61
				}
			l62:
				if !_rules[ruleTYPEDEF]() {
					goto l59
				}
				if !_rules[ruleFieldType]() {
					goto l59
				}
				if !_rules[ruleIdentifier]() {
					goto l59
				}
				{
					position63, tokenIndex63 := position, tokenIndex
					if !_rules[ruleListSeparator]() {
						goto l63
					}
					goto l64
				l63:
					position, tokenIndex = position63, tokenIndex63
				}
			l64:
				add(ruleTypedef, position60)
			}
			memoize(10, position59, tokenIndex59, true)
			return true
		l59:
			memoize(10, position59, tokenIndex59, false)
			position, tokenIndex = position59, tokenIndex59
			return false
		},
		/* 11 Enum <- <(StructuredAnnotations? ENUM Identifier LWING (ReservedComments StructuredAnnotations? Identifier (EQUAL IntConstant)? Annotations? ListSeparator? ReservedEndLineComments SkipLine)* RWING)> */
		func() bool {
			if memoized, ok := memoization[memoKey{11, position}]; ok {
				return memoizedResult(memoized)
			}
			position65, tokenIndex65 := position, tokenIndex
			{
				position66 := position
				{
					position67, tokenIndex67 := position, tokenIndex
					if !_rules[ruleStructuredAnnotations]() {
						goto l67
					}
					goto l68
				l67:
					position, tokenIndex = position67, tokenIndex67
				}
			l68:
				if !_rules[ruleENUM]() {
					goto l65
				}
				if !_rules[ruleIdentifier]() {
					goto l65
				}
				if !_rules[ruleLWING]() {
					goto l65
				}
			l69:
				{
					position70, tokenIndex70 := position, tokenIndex
					if !_rules[ruleReservedComments]() {
						goto l70
					}
					{
						position71, tokenIndex71 := position, tokenIndex
						if !_rules[ruleStructuredAnnotations]() {
							goto l71
						}
						goto l72
					l71:
						position, tokenIndex = position71, tokenIndex71
					}
				l72:
					if !_rules[ruleIdentifier]() {
						goto l70
					}
					{
						position73, tokenIndex73 := position, tokenIndex
						if !_rules[ruleEQUAL]() {
							goto l73
						}
						if !_rules[ruleIntConstant]() {
							goto l73
						}
						goto l74
					l73:
						position, tokenIndex = position73, tokenIndex73
					}
				l74:
					{
						position75, tokenIndex75 := position, tokenIndex
						if !_rules[ruleAnnotations]() {
							goto l75
						}
						goto l76
					l75:
						position, tokenIndex = position75, tokenIndex75
					}
				l76:
					{
						position77, tokenIndex77 := position, tokenIndex
						if !_rules[ruleListSeparator]() {
							goto l77
						}
						goto l78
					l77:
						position, tokenIndex = position77, tokenIndex77
					}
				l78:
					if !_rules[ruleReservedEndLineComments]() {
						goto l70
					}
					if !_rules[ruleSkipLine]() {
						goto l70
					}
					goto l69
				l70:
					position, tokenIndex = position70, tokenIndex70
				}
				if !_rules[ruleRWING]() {
					goto l65
				}
				add(ruleEnum, position66)
			}
			memoize(11, position65, tokenIndex65, true)
			return true
		l65:
			memoize(11, position65, tokenIndex65, false)
			position, tokenIndex = position65, tokenIndex65
			return false
		},
		/* 12 Service <- <(StructuredAnnotations? SERVICE Identifier (EXTENDS Identifier)? LWING (Function / Performs)* RWING)> */
		func() bool {
			if memoized, ok := memoization[memoKey{12, position}]; ok {
				return memoizedResult(memoized)
			}
			position79, tokenIndex79 := position, tokenIndex
			{
				position80 := position
				{
					position81, tokenIndex81 := position, tokenIndex
					if !_rules[ruleStructuredAnnotations]() {
						goto l81
					}
					goto l82
				l81:
					position, tokenIndex = position81, tokenIndex81
				}
			l82:
				if !_rules[ruleSERVICE]() {
					goto l79
				}
				if !_rules[ruleIdentifier]() {
					goto l79
				}
				{
					position83, tokenIndex83 := position, tokenIndex
					if !_rules[ruleEXTENDS]() {
						goto l83
					}
					if !_rules[ruleIdentifier]() {
						goto l83
					}
					goto l84
				l83:
					position, tokenIndex = position83, tokenIndex83
				}
			l84:
				if !_rules[ruleLWING]() {
					goto l79
				}
			l85:
				{
					position86, tokenIndex86 := position, tokenIndex
					{
						position87, tokenIndex87 := position, tokenIndex
						if !_rules[ruleFunction]() {
							goto l88
						}
						goto l87
					l88:
						position, tokenIndex = position87, tokenIndex87
						if !_rules[rulePerforms]() {
							goto l86
						}
					}
				l87:
					goto l85
				l86:
					position, tokenIndex = position86, tokenIndex86
				}
				if !_rules[ruleRWING]() {
					goto l79
				}
				add(ruleService, position80)
			}
			memoize(12, position79, tokenIndex79, true)
			return true
		l79:
			memoize(12, position79, tokenIndex79, false)
			position, tokenIndex = position79, tokenIndex79
			return false
		},
		/* 13 Interaction <- <(StructuredAnnotations? INTERACTION Identifier LWING Function* RWING)> */
		func() bool {
			if memoized, ok := memoization[memoKey{13, position}]; ok {
				return memoizedResult(memoized)
			}
			position89, tokenIndex89 := position, tokenIndex
			{
				position90 := position
				{
					position91, tokenIndex91 := position, tokenIndex
					if !_rules[ruleStructuredAnnotations]() {
						goto l91
					}
					goto l92
				l91:
					position, tokenIndex = position91, tokenIndex91
				}
			l92:
				if !_rules[ruleINTERACTION]() {
					goto l89
				}
				if !_rules[ruleIdentifier]() {
					goto l89
				}
				if !_rules[ruleLWING]() {
					goto l89
				}
			l93:
				{
					position94, tokenIndex94 := position, tokenIndex
					if !_rules[ruleFunction]() {
						goto l94
					}
					goto l93
				l94:
					position, tokenIndex = position94, tokenIndex94
				}
				if !_rules[ruleRWING]() {
					goto l89
				}
				add(ruleInteraction, position90)
			}
			memoize(13, position89, tokenIndex89, true)
			return true
		l89:
			memoize(13, position89, tokenIndex89, false)
			position, tokenIndex = position89, tokenIndex89
			return false
		},
		/* 14 Struct <- <(StructuredAnnotations? STRUCT Identifier LWING Field* RWING)> */
		func() bool {
			if memoized, ok := memoization[memoKey{14, position}]; ok {
				return memoizedResult(memoized)
			}
			position95, tokenIndex95 := position, tokenIndex
			{
				position96 := position
				{
					position97, tokenIndex97 := position, tokenIndex
					if !_rules[ruleStructuredAnnotations]() {
						goto l97
					}
					goto l98
				l97:
					position, tokenIndex = position97, tokenIndex97
				}
			l98:
				if !_rules[ruleSTRUCT]() {
					goto l95
				}
				if !_rules[ruleIdentifier]() {
					goto l95
				}
				if !_rules[ruleLWING]() {
					goto l95
				}
			l99:
				{
					position100, tokenIndex100 := position, tokenIndex
					if !_rules[ruleField]() {
						goto l100
					}
					goto l99
				l100:
					position, tokenIndex = position100, tokenIndex100
				}
				if !_rules[ruleRWING]() {
					goto l95
				}
				add(ruleStruct, position96)
			}
			memoize(14, position95, tokenIndex95, true)
			return true
		l95:
			memoize(14, position95, tokenIndex95, false)
			position, tokenIndex = position95, tokenIndex95
			return false
		},
		/* 15 Union <- <(StructuredAnnotations? UNION Identifier LWING Field* RWING)> */
		func() bool {
			if memoized, ok := memoization[memoKey{15, position}]; ok {
				return memoizedResult(memoized)
			}
			position101, tokenIndex101 := position, tokenIndex
			{
				position102 := position
				{
					position103, tokenIndex103 := position, tokenIndex
					if !_rules[ruleStructuredAnnotations]() {
						goto l103
					}
					goto l104
				l103:
					position, tokenIndex = position103, tokenIndex103
				}
			l104:
				if !_rules[ruleUNION]() {
					goto l101
				}
				if !_rules[ruleIdentifier]() {
					goto l101
				}
				if !_rules[ruleLWING]() {
					goto l101
				}
			l105:
				{
					position106, tokenIndex106 := position, tokenIndex
					if !_rules[ruleField]() {
						goto l106
					}
					goto l105
				l106:
					position, tokenIndex = position106, tokenIndex106
				}
				if !_rules[ruleRWING]() {
					goto l101
				}
				add(ruleUnion, position102)
			}
			memoize(15, position101, tokenIndex101, true)
			return true
		l101:
			memoize(15, position101, tokenIndex101, false)
			position, tokenIndex = position101, tokenIndex101
			return false
		},
		/* 16 Exception <- <(StructuredAnnotations? ExceptionMeta? EXCEPTION Identifier LWING Field* RWING)> */
		func() bool {
			if memoized, ok := memoization[memoKey{16, position}]; ok {
				return memoizedResult(memoized)
			}
			position107, tokenIndex107 := position, tokenIndex
			{
				position108 := position
				{
					position109, tokenIndex109 := position, tokenIndex
					if !_rules[ruleStructuredAnnotations]() {
						goto l109
					}
					goto l110
				l109:
					position, tokenIndex = position109, tokenIndex109
				}
			l110:
				{
					position111, tokenIndex111 := position, tokenIndex
					if !_rules[ruleExceptionMeta]() {
						goto l111
					}
					goto l112
				l111:
					position, tokenIndex = position111, tokenIndex111
				}
			l112:
				if !_rules[ruleEXCEPTION]() {
					goto l107
				}
				if !_rules[ruleIdentifier]() {
					goto l107
				}
				if !_rules[ruleLWING]() {
					goto l107
				}
			l113:
				{
					position114, tokenIndex114 := position, tokenIndex
					if !_rules[ruleField]() {
						goto l114
					}
					goto l113
				l114:
					position, tokenIndex = position114, tokenIndex114
				}
				if !_rules[ruleRWING]() {
					goto l107
				}
				add(ruleException, position108)
			}
			memoize(16, position107, tokenIndex107, true)
			return true
		l107:
			memoize(16, position107, tokenIndex107, false)
			position, tokenIndex = position107, tokenIndex107
			return false
		},
		/* 17 ExceptionMeta <- <ExceptionLabel*> */
		func() bool {
			if memoized, ok := memoization[memoKey{17, position}]; ok {
				return memoizedResult(memoized)
			}
			position115, tokenIndex115 := position, tokenIndex
			{
				position116 := position
			l117:
				{
					position118, tokenIndex118 := position, tokenIndex
					if !_rules[ruleExceptionLabel]() {
						goto l118
					}
					goto l117
				l118:
					position, tokenIndex = position118, tokenIndex118
				}
				add(ruleExceptionMeta, position116)
			}
			memoize(17, position115, tokenIndex115, true)
			return true
		},
		/* 18 ExceptionLabel <- <(SAFE / UNSAFE / TRANSIENT / PERMANENT / STATEFUL / SERVER / CLIENT)> */
		func() bool {
			if memoized, ok := memoization[memoKey{18, position}]; ok {
				return memoizedResult(memoized)
			}
			position119, tokenIndex119 := position, tokenIndex
			{
				position120 := position
				{
					position121, tokenIndex121 := position, tokenIndex
					if !_rules[ruleSAFE]() {
						goto l122
					}
					goto l121
				l122:
					position, tokenIndex = position121, tokenIndex121
					if !_rules[ruleUNSAFE]() {
						goto l123
					}
					goto l121
				l123:
					position, tokenIndex = position121, tokenIndex121
					if !_rules[ruleTRANSIENT]() {
						goto l124
					}
					goto l121
				l124:
					position, tokenIndex = position121, tokenIndex121
					if !_rules[rulePERMANENT]() {
						goto l125
					}
					goto l121
				l125:
					position, tokenIndex = position121, tokenIndex121
					if !_rules[ruleSTATEFUL]() {
						goto l126
					}
					goto l121
				l126:
					position, tokenIndex = position121, tokenIndex121
					if !_rules[ruleSERVER]() {
						goto l127
					}
					goto l121
				l127:
					position, tokenIndex = position121, tokenIndex121
					if !_rules[ruleCLIENT]() {
						goto l119
					}
				}
			l121:
				add(ruleExceptionLabel, position120)
			}
			memoize(18, position119, tokenIndex119, true)
			return true
		l119:
			memoize(18, position119, tokenIndex119, false)
			position, tokenIndex = position119, tokenIndex119
			return false
		},
		/* 19 Field <- <(ReservedComments Skip StructuredAnnotations? FieldId? FieldReq? FieldType Identifier (EQUAL ConstValue)? Annotations? ListSeparator? ReservedEndLineComments SkipLine)> */
		func() bool {
			if memoized, ok := memoization[memoKey{19, position}]; ok {
				return memoizedResult(memoized)
			}
			position128, tokenIndex128 := position, tokenIndex
			{
				position129 := position
				if !_rules[ruleReservedComments]() {
					goto l128
				}
				if !_rules[ruleSkip]() {
					goto l128
				}
				{
					position130, tokenIndex130 := position, tokenIndex
					if !_rules[ruleStructuredAnnotations]() {
						goto l130
					}
					goto l131
				l130:
					position, tokenIndex = position130, tokenIndex130
				}
			l131:
				{
					position132, tokenIndex132 := position, tokenIndex
					if !_rules[ruleFieldId]() {
						goto l132
					}
					goto l133
				l132:
					position, tokenIndex = position132, tokenIndex132
				}
			l133:
				{
					position134, tokenIndex134 := position, tokenIndex
					if !_rules[ruleFieldReq]() {
						goto l134
					}
					goto l135
				l134:
					position, tokenIndex = position134, tokenIndex134
				}
			l135:
				if !_rules[ruleFieldType]() {
					goto l128
				}
				if !_rules[ruleIdentifier]() {
					goto l128
				}
				{
					position136, tokenIndex136 := position, tokenIndex
					if !_rules[ruleEQUAL]() {
						goto l136
					}
					if !_rules[ruleConstValue]() {
						goto l136
					}
					goto l137
				l136:
					position, tokenIndex = position136, tokenIndex136
				}
			l137:
				{
					position138, tokenIndex138 := position, tokenIndex
					if !_rules[ruleAnnotations]() {
						goto l138
					}
					goto l139
				l138:
					position, tokenIndex = position138, tokenIndex138
				}
			l139:
				{
					position140, tokenIndex140 := position, tokenIndex
					if !_rules[ruleListSeparator]() {
						goto l140
					}
					goto l141
				l140:
					position, tokenIndex = position140, tokenIndex140
				}
			l141:
				if !_rules[ruleReservedEndLineComments]() {
					goto l128
				}
				if !_rules[ruleSkipLine]() {
					goto l128
				}
				add(ruleField, position129)
			}
			memoize(19, position128, tokenIndex128, true)
			return true
		l128:
			memoize(19, position128, tokenIndex128, false)
			position, tokenIndex = position128, tokenIndex128
			return false
		},
		/* 20 FieldId <- <(Skip IntConstant COLON Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{20, position}]; ok {
				return memoizedResult(memoized)
			}
			position142, tokenIndex142 := position, tokenIndex
			{
				position143 := position
				if !_rules[ruleSkip]() {
					goto l142
				}
				if !_rules[ruleIntConstant]() {
					goto l142
				}
				if !_rules[ruleCOLON]() {
					goto l142
				}
			l144:
				{
					position145, tokenIndex145 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l145
					}
					goto l144
				l145:
					position, tokenIndex = position145, tokenIndex145
				}
				add(ruleFieldId, position143)
			}
			memoize(20, position142, tokenIndex142, true)
			return true
		l142:
			memoize(20, position142, tokenIndex142, false)
			position, tokenIndex = position142, tokenIndex142
			return false
		},
		/* 21 FieldReq <- <(Skip <(('r' 'e' 'q' 'u' 'i' 'r' 'e' 'd') / ('o' 'p' 't' 'i' 'o' 'n' 'a' 'l'))> Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{21, position}]; ok {
				return memoizedResult(memoized)
			}
			position146, tokenIndex146 := position, tokenIndex
			{
				position147 := position
				if !_rules[ruleSkip]() {
					goto l146
				}
				{
					position148 := position
					{
						position149, tokenIndex149 := position, tokenIndex
						if buffer[position] != rune('r') {
							goto l150
						}
						position++
						if buffer[position] != rune('e') {
							goto l150
						}
						position++
						if buffer[position] != rune('q') {
							goto l150
						}
						position++
						if buffer[position] != rune('u') {
							goto l150
						}
						position++
						if buffer[position] != rune('i') {
							goto l150
						}
						position++
						if buffer[position] != rune('r') {
							goto l150
						}
						position++
						if buffer[position] != rune('e') {
							goto l150
						}
						position++
						if buffer[position] != rune('d') {
							goto l150
						}
						position++
						goto l149
					l150:
						position, tokenIndex = position149, tokenIndex149
						if buffer[position] != rune('o') {
							goto l146
						}
						position++
						if buffer[position] != rune('p') {
							goto l146
						}
						position++
						if buffer[position] != rune('t') {
							goto l146
						}
						position++
						if buffer[position] != rune('i') {
							goto l146
						}
						position++
						if buffer[position] != rune('o') {
							goto l146
						}
						position++
						if buffer[position] != rune('n') {
							goto l146
						}
						position++
						if buffer[position] != rune('a') {
							goto l146
						}
						position++
						if buffer[position] != rune('l') {
							goto l146
						}
						position++
					}
				l149:
					add(rulePegText, position148)
				}
			l151:
				{
					position152, tokenIndex152 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l152
					}
					goto l151
				l152:
					position, tokenIndex = position152, tokenIndex152
				}
				add(ruleFieldReq, position147)
			}
			memoize(21, position146, tokenIndex146, true)
			return true
		l146:
			memoize(21, position146, tokenIndex146, false)
			position, tokenIndex = position146, tokenIndex146
			return false
		},
		/* 22 Function <- <(ReservedComments Skip StructuredAnnotations? FunctionMeta? ReturnClause Identifier LPAR Field* RPAR Throws? Annotations? ListSeparator? SkipLine)> */
		func() bool {
			if memoized, ok := memoization[memoKey{22, position}]; ok {
				return memoizedResult(memoized)
			}
			position153, tokenIndex153 := position, tokenIndex
			{
				position154 := position
				if !_rules[ruleReservedComments]() {
					goto l153
				}
				if !_rules[ruleSkip]() {
					goto l153
				}
				{
					position155, tokenIndex155 := position, tokenIndex
					if !_rules[ruleStructuredAnnotations]() {
						goto l155
					}
					goto l156
				l155:
					position, tokenIndex = position155, tokenIndex155
				}
			l156:
				{
					position157, tokenIndex157 := position, tokenIndex
					if !_rules[ruleFunctionMeta]() {
						goto l157
					}
					goto l158
				l157:
					position, tokenIndex = position157, tokenIndex157
				}
			l158:
				if !_rules[ruleReturnClause]() {
					goto l153
				}
				if !_rules[ruleIdentifier]() {
					goto l153
				}
				if !_rules[ruleLPAR]() {
					goto l153
				}
			l159:
				{
					position160, tokenIndex160 := position, tokenIndex
					if !_rules[ruleField]() {
						goto l160
					}
					goto l159
				l160:
					position, tokenIndex = position160, tokenIndex160
				}
				if !_rules[ruleRPAR]() {
					goto l153
				}
				{
					position161, tokenIndex161 := position, tokenIndex
					if !_rules[ruleThrows]() {
						goto l161
					}
					goto l162
				l161:
					position, tokenIndex = position161, tokenIndex161
				}
			l162:
				{
					position163, tokenIndex163 := position, tokenIndex
					if !_rules[ruleAnnotations]() {
						goto l163
					}
					goto l164
				l163:
					position, tokenIndex = position163, tokenIndex163
				}
			l164:
				{
					position165, tokenIndex165 := position, tokenIndex
					if !_rules[ruleListSeparator]() {
						goto l165
					}
					goto l166
				l165:
					position, tokenIndex = position165, tokenIndex165
				}
			l166:
				if !_rules[ruleSkipLine]() {
					goto l153
				}
				add(ruleFunction, position154)
			}
			memoize(22, position153, tokenIndex153, true)
			return true
		l153:
			memoize(22, position153, tokenIndex153, false)
			position, tokenIndex = position153, tokenIndex153
			return false
		},
		/* 23 ReturnClause <- <(FunctionType (COMMA FunctionType)? (COMMA FunctionType)?)> */
		func() bool {
			if memoized, ok := memoization[memoKey{23, position}]; ok {
				return memoizedResult(memoized)
			}
			position167, tokenIndex167 := position, tokenIndex
			{
				position168 := position
				if !_rules[ruleFunctionType]() {
					goto l167
				}
				{
					position169, tokenIndex169 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l169
					}
					if !_rules[ruleFunctionType]() {
						goto l169
					}
					goto l170
				l169:
					position, tokenIndex = position169, tokenIndex169
				}
			l170:
				{
					position171, tokenIndex171 := position, tokenIndex
					if !_rules[ruleCOMMA]() {
						goto l171
					}
					if !_rules[ruleFunctionType]() {
						goto l171
					}
					goto l172
				l171:
					position, tokenIndex = position171, tokenIndex171
				}
			l172:
				add(ruleReturnClause, position168)
			}
			memoize(23, position167, tokenIndex167, true)
			return true
		l167:
			memoize(23, position167, tokenIndex167, false)
			position, tokenIndex = position167, tokenIndex167
			return false
		},
		/* 24 FunctionType <- <(VOID / Sink / Stream / FieldType)> */
		func() bool {
			if memoized, ok := memoization[memoKey{24, position}]; ok {
				return memoizedResult(memoized)
			}
			position173, tokenIndex173 := position, tokenIndex
			{
				position174 := position
				{
					position175, tokenIndex175 := position, tokenIndex
					if !_rules[ruleVOID]() {
						goto l176
					}
					goto l175
				l176:
					position, tokenIndex = position175, tokenIndex175
					if !_rules[ruleSink]() {
						goto l177
					}
					goto l175
				l177:
					position, tokenIndex = position175, tokenIndex175
					if !_rules[ruleStream]() {
						goto l178
					}
					goto l175
				l178:
					position, tokenIndex = position175, tokenIndex175
					if !_rules[ruleFieldType]() {
						goto l173
					}
				}
			l175:
				add(ruleFunctionType, position174)
			}
			memoize(24, position173, tokenIndex173, true)
			return true
		l173:
			memoize(24, position173, tokenIndex173, false)
			position, tokenIndex = position173, tokenIndex173
			return false
		},
		/* 25 FunctionMeta <- <FunctionLabel?> */
		func() bool {
			if memoized, ok := memoization[memoKey{25, position}]; ok {
				return memoizedResult(memoized)
			}
			position179, tokenIndex179 := position, tokenIndex
			{
				position180 := position
				{
					position181, tokenIndex181 := position, tokenIndex
					if !_rules[ruleFunctionLabel]() {
						goto l181
					}
					goto l182
				l181:
					position, tokenIndex = position181, tokenIndex181
				}
			l182:
				add(ruleFunctionMeta, position180)
			}
			memoize(25, position179, tokenIndex179, true)
			return true
		},
		/* 26 FunctionLabel <- <(ONEWAY / READONLY / IDEMPOTENT)> */
		func() bool {
			if memoized, ok := memoization[memoKey{26, position}]; ok {
				return memoizedResult(memoized)
			}
			position183, tokenIndex183 := position, tokenIndex
			{
				position184 := position
				{
					position185, tokenIndex185 := position, tokenIndex
					if !_rules[ruleONEWAY]() {
						goto l186
					}
					goto l185
				l186:
					position, tokenIndex = position185, tokenIndex185
					if !_rules[ruleREADONLY]() {
						goto l187
					}
					goto l185
				l187:
					position, tokenIndex = position185, tokenIndex185
					if !_rules[ruleIDEMPOTENT]() {
						goto l183
					}
				}
			l185:
				add(ruleFunctionLabel, position184)
			}
			memoize(26, position183, tokenIndex183, true)
			return true
		l183:
			memoize(26, position183, tokenIndex183, false)
			position, tokenIndex = position183, tokenIndex183
			return false
		},
		/* 27 Performs <- <(ReservedComments Skip PERFORMS Identifier ListSeparator? SkipLine)> */
		func() bool {
			if memoized, ok := memoization[memoKey{27, position}]; ok {
				return memoizedResult(memoized)
			}
			position188, tokenIndex188 := position, tokenIndex
			{
				position189 := position
				if !_rules[ruleReservedComments]() {
					goto l188
				}
				if !_rules[ruleSkip]() {
					goto l188
				}
				if !_rules[rulePERFORMS]() {
					goto l188
				}
				if !_rules[ruleIdentifier]() {
					goto l188
				}
				{
					position190, tokenIndex190 := position, tokenIndex
					if !_rules[ruleListSeparator]() {
						goto l190
					}
					goto l191
				l190:
					position, tokenIndex = position190, tokenIndex190
				}
			l191:
				if !_rules[ruleSkipLine]() {
					goto l188
				}
				add(rulePerforms, position189)
			}
			memoize(27, position188, tokenIndex188, true)
			return true
		l188:
			memoize(27, position188, tokenIndex188, false)
			position, tokenIndex = position188, tokenIndex188
			return false
		},
		/* 28 Throws <- <(THROWS LPAR Field* RPAR)> */
		func() bool {
			if memoized, ok := memoization[memoKey{28, position}]; ok {
				return memoizedResult(memoized)
			}
			position192, tokenIndex192 := position, tokenIndex
			{
				position193 := position
				if !_rules[ruleTHROWS]() {
					goto l192
				}
				if !_rules[ruleLPAR]() {
					goto l192
				}
			l194:
				{
					position195, tokenIndex195 := position, tokenIndex
					if !_rules[ruleField]() {
						goto l195
					}
					goto l194
				l195:
					position, tokenIndex = position195, tokenIndex195
				}
				if !_rules[ruleRPAR]() {
					goto l192
				}
				add(ruleThrows, position193)
			}
			memoize(28, position192, tokenIndex192, true)
			return true
		l192:
			memoize(28, position192, tokenIndex192, false)
			position, tokenIndex = position192, tokenIndex192
			return false
		},
		/* 29 FieldType <- <((ContainerType / BaseType / Identifier) Annotations?)> */
		func() bool {
			if memoized, ok := memoization[memoKey{29, position}]; ok {
				return memoizedResult(memoized)
			}
			position196, tokenIndex196 := position, tokenIndex
			{
				position197 := position
				{
					position198, tokenIndex198 := position, tokenIndex
					if !_rules[ruleContainerType]() {
						goto l199
					}
					goto l198
				l199:
					position, tokenIndex = position198, tokenIndex198
					if !_rules[ruleBaseType]() {
						goto l200
					}
					goto l198
				l200:
					position, tokenIndex = position198, tokenIndex198
					if !_rules[ruleIdentifier]() {
						goto l196
					}
				}
			l198:
				{
					position201, tokenIndex201 := position, tokenIndex
					if !_rules[ruleAnnotations]() {
						goto l201
					}
					goto l202
				l201:
					position, tokenIndex = position201, tokenIndex201
				}
			l202:
				add(ruleFieldType, position197)
			}
			memoize(29, position196, tokenIndex196, true)
			return true
		l196:
			memoize(29, position196, tokenIndex196, false)
			position, tokenIndex = position196, tokenIndex196
			return false
		},
		/* 30 BaseType <- <(BOOL / BYTE / I8 / I16 / I32 / I64 / DOUBLE / STRING / BINARY)> */
		func() bool {
			if memoized, ok := memoization[memoKey{30, position}]; ok {
				return memoizedResult(memoized)
			}
			position203, tokenIndex203 := position, tokenIndex
			{
				position204 := position
				{
					position205, tokenIndex205 := position, tokenIndex
					if !_rules[ruleBOOL]() {
						goto l206
					}
					goto l205
				l206:
					position, tokenIndex = position205, tokenIndex205
					if !_rules[ruleBYTE]() {
						goto l207
					}
					goto l205
				l207:
					position, tokenIndex = position205, tokenIndex205
					if !_rules[ruleI8]() {
						goto l208
					}
					goto l205
				l208:
					position, tokenIndex = position205, tokenIndex205
					if !_rules[ruleI16]() {
						goto l209
					}
					goto l205
				l209:
					position, tokenIndex = position205, tokenIndex205
					if !_rules[ruleI32]() {
						goto l210
					}
					goto l205
				l210:
					position, tokenIndex = position205, tokenIndex205
					if !_rules[ruleI64]() {
						goto l211
					}
					goto l205
				l211:
					position, tokenIndex = position205, tokenIndex205
					if !_rules[ruleDOUBLE]() {
						goto l212
					}
					goto l205
				l212:
					position, tokenIndex = position205, tokenIndex205
					if !_rules[ruleSTRING]() {
						goto l213
					}
					goto l205
				l213:
					position, tokenIndex = position205, tokenIndex205
					if !_rules[ruleBINARY]() {
						goto l203
					}
				}
			l205:
				add(ruleBaseType, position204)
			}
			memoize(30, position203, tokenIndex203, true)
			return true
		l203:
			memoize(30, position203, tokenIndex203, false)
			position, tokenIndex = position203, tokenIndex203
			return false
		},
		/* 31 ContainerType <- <(MapType / SetType / ListType)> */
		func() bool {
			if memoized, ok := memoization[memoKey{31, position}]; ok {
				return memoizedResult(memoized)
			}
			position214, tokenIndex214 := position, tokenIndex
			{
				position215 := position
				{
					position216, tokenIndex216 := position, tokenIndex
					if !_rules[ruleMapType]() {
						goto l217
					}
					goto l216
				l217:
					position, tokenIndex = position216, tokenIndex216
					if !_rules[ruleSetType]() {
						goto l218
					}
					goto l216
				l218:
					position, tokenIndex = position216, tokenIndex216
					if !_rules[ruleListType]() {
						goto l214
					}
				}
			l216:
				add(ruleContainerType, position215)
			}
			memoize(31, position214, tokenIndex214, true)
			return true
		l214:
			memoize(31, position214, tokenIndex214, false)
			position, tokenIndex = position214, tokenIndex214
			return false
		},
		/* 32 MapType <- <(MAP CppType? LPOINT FieldType COMMA FieldType RPOINT)> */
		func() bool {
			if memoized, ok := memoization[memoKey{32, position}]; ok {
				return memoizedResult(memoized)
			}
			position219, tokenIndex219 := position, tokenIndex
			{
				position220 := position
				if !_rules[ruleMAP]() {
					goto l219
				}
				{
					position221, tokenIndex221 := position, tokenIndex
					if !_rules[ruleCppType]() {
						goto l221
					}
					goto l222
				l221:
					position, tokenIndex = position221, tokenIndex221
				}
			l222:
				if !_rules[ruleLPOINT]() {
					goto l219
				}
				if !_rules[ruleFieldType]() {
					goto l219
				}
				if !_rules[ruleCOMMA]() {
					goto l219
				}
				if !_rules[ruleFieldType]() {
					goto l219
				}
				if !_rules[ruleRPOINT]() {
					goto l219
				}
				add(ruleMapType, position220)
			}
			memoize(32, position219, tokenIndex219, true)
			return true
		l219:
			memoize(32, position219, tokenIndex219, false)
			position, tokenIndex = position219, tokenIndex219
			return false
		},
		/* 33 SetType <- <(SET CppType? LPOINT FieldType RPOINT)> */
		func() bool {
			if memoized, ok := memoization[memoKey{33, position}]; ok {
				return memoizedResult(memoized)
			}
			position223, tokenIndex223 := position, tokenIndex
			{
				position224 := position
				if !_rules[ruleSET]() {
					goto l223
				}
				{
					position225, tokenIndex225 := position, tokenIndex
					if !_rules[ruleCppType]() {
						goto l225
					}
					goto l226
				l225:
					position, tokenIndex = position225, tokenIndex225
				}
			l226:
				if !_rules[ruleLPOINT]() {
					goto l223
				}
				if !_rules[ruleFieldType]() {
					goto l223
				}
				if !_rules[ruleRPOINT]() {
					goto l223
				}
				add(ruleSetType, position224)
			}
			memoize(33, position223, tokenIndex223, true)
			return true
		l223:
			memoize(33, position223, tokenIndex223, false)
			position, tokenIndex = position223, tokenIndex223
			return false
		},
		/* 34 ListType <- <(LIST LPOINT FieldType RPOINT CppType?)> */
		func() bool {
			if memoized, ok := memoization[memoKey{34, position}]; ok {
				return memoizedResult(memoized)
			}
			position227, tokenIndex227 := position, tokenIndex
			{
				position228 := position
				if !_rules[ruleLIST]() {
					goto l227
				}
				if !_rules[ruleLPOINT]() {
					goto l227
				}
				if !_rules[ruleFieldType]() {
					goto l227
				}
				if !_rules[ruleRPOINT]() {
					goto l227
				}
				{
					position229, tokenIndex229 := position, tokenIndex
					if !_rules[ruleCppType]() {
						goto l229
					}
					goto l230
				l229:
					position, tokenIndex = position229, tokenIndex229
				}
			l230:
				add(ruleListType, position228)
			}
			memoize(34, position227, tokenIndex227, true)
			return true
		l227:
			memoize(34, position227, tokenIndex227, false)
			position, tokenIndex = position227, tokenIndex227
			return false
		},
		/* 35 CppType <- <(CPPTYPE Literal)> */
		func() bool {
			if memoized, ok := memoization[memoKey{35, position}]; ok {
				return memoizedResult(memoized)
			}
			position231, tokenIndex231 := position, tokenIndex
			{
				position232 := position
				if !_rules[ruleCPPTYPE]() {
					goto l231
				}
				if !_rules[ruleLiteral]() {
					goto l231
				}
				add(ruleCppType, position232)
			}
			memoize(35, position231, tokenIndex231, true)
			return true
		l231:
			memoize(35, position231, tokenIndex231, false)
			position, tokenIndex = position231, tokenIndex231
			return false
		},
		/* 36 Sink <- <(SINK LPOINT FieldType Throws? COMMA FieldType Throws? RPOINT)> */
		func() bool {
			if memoized, ok := memoization[memoKey{36, position}]; ok {
				return memoizedResult(memoized)
			}
			position233, tokenIndex233 := position, tokenIndex
			{
				position234 := position
				if !_rules[ruleSINK]() {
					goto l233
				}
				if !_rules[ruleLPOINT]() {
					goto l233
				}
				if !_rules[ruleFieldType]() {
					goto l233
				}
				{
					position235, tokenIndex235 := position, tokenIndex
					if !_rules[ruleThrows]() {
						goto l235
					}
					goto l236
				l235:
					position, tokenIndex = position235, tokenIndex235
				}
			l236:
				if !_rules[ruleCOMMA]() {
					goto l233
				}
				if !_rules[ruleFieldType]() {
					goto l233
				}
				{
					position237, tokenIndex237 := position, tokenIndex
					if !_rules[ruleThrows]() {
						goto l237
					}
					goto l238
				l237:
					position, tokenIndex = position237, tokenIndex237
				}
			l238:
				if !_rules[ruleRPOINT]() {
					goto l233
				}
				add(ruleSink, position234)
			}
			memoize(36, position233, tokenIndex233, true)
			return true
		l233:
			memoize(36, position233, tokenIndex233, false)
			position, tokenIndex = position233, tokenIndex233
			return false
		},
		/* 37 Stream <- <(STREAM LPOINT FieldType Throws? RPOINT)> */
		func() bool {
			if memoized, ok := memoization[memoKey{37, position}]; ok {
				return memoizedResult(memoized)
			}
			position239, tokenIndex239 := position, tokenIndex
			{
				position240 := position
				if !_rules[ruleSTREAM]() {
					goto l239
				}
				if !_rules[ruleLPOINT]() {
					goto l239
				}
				if !_rules[ruleFieldType]() {
					goto l239
				}
				{
					position241, tokenIndex241 := position, tokenIndex
					if !_rules[ruleThrows]() {
						goto l241
					}
					goto l242
				l241:
					position, tokenIndex = position241, tokenIndex241
				}
			l242:
				if !_rules[ruleRPOINT]() {
					goto l239
				}
				add(ruleStream, position240)
			}
			memoize(37, position239, tokenIndex239, true)
			return true
		l239:
			memoize(37, position239, tokenIndex239, false)
			position, tokenIndex = position239, tokenIndex239
			return false
		},
		/* 38 ConstValue <- <(DoubleConstant / IntConstant / Literal / ConstStruct / Identifier / ConstList / ConstMap)> */
		func() bool {
			if memoized, ok := memoization[memoKey{38, position}]; ok {
				return memoizedResult(memoized)
			}
			position243, tokenIndex243 := position, tokenIndex
			{
				position244 := position
				{
					position245, tokenIndex245 := position, tokenIndex
					if !_rules[ruleDoubleConstant]() {
						goto l246
					}
					goto l245
				l246:
					position, tokenIndex = position245, tokenIndex245
					if !_rules[ruleIntConstant]() {
						goto l247
					}
					goto l245
				l247:
					position, tokenIndex = position245, tokenIndex245
					if !_rules[ruleLiteral]() {
						goto l248
					}
					goto l245
				l248:
					position, tokenIndex = position245, tokenIndex245
					if !_rules[ruleConstStruct]() {
						goto l249
					}
					goto l245
				l249:
					position, tokenIndex = position245, tokenIndex245
					if !_rules[ruleIdentifier]() {
						goto l250
					}
					goto l245
				l250:
					position, tokenIndex = position245, tokenIndex245
					if !_rules[ruleConstList]() {
						goto l251
					}
					goto l245
				l251:
					position, tokenIndex = position245, tokenIndex245
					if !_rules[ruleConstMap]() {
						goto l243
					}
				}
			l245:
				add(ruleConstValue, position244)
			}
			memoize(38, position243, tokenIndex243, true)
			return true
		l243:
			memoize(38, position243, tokenIndex243, false)
			position, tokenIndex = position243, tokenIndex243
			return false
		},
		/* 39 IntConstant <- <(Skip <((('+' / '-')? '0' ('b' / 'B') ('0' / '1')+) / (('+' / '-')? '0' ('x' / 'X') ([0-9] / [A-Z] / [a-z])+) / ('0' 'o' Digit+) / (('+' / '-')? Digit+))> Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{39, position}]; ok {
				return memoizedResult(memoized)
			}
			position252, tokenIndex252 := position, tokenIndex
			{
				position253 := position
				if !_rules[ruleSkip]() {
					goto l252
				}
				{
					position254 := position
					{
						position255, tokenIndex255 := position, tokenIndex
						{
							position257, tokenIndex257 := position, tokenIndex
							{
								position259, tokenIndex259 := position, tokenIndex
								if buffer[position] != rune('+') {
									goto l260
								}
								position++
								goto l259
							l260:
								position, tokenIndex = position259, tokenIndex259
								if buffer[position] != rune('-') {
									goto l257
								}
								position++
							}
						l259:
							goto l258
						l257:
							position, tokenIndex = position257, tokenIndex257
						}
					l258:
						if buffer[position] != rune('0') {
							goto l256
						}
						position++
						{
							position261, tokenIndex261 := position, tokenIndex
							if buffer[position] != rune('b') {
								goto l262
							}
							position++
							goto l261
						l262:
							position, tokenIndex = position261, tokenIndex261
							if buffer[position] != rune('B') {
								goto l256
							}
							position++
						}
					l261:
						{
							position265, tokenIndex265 := position, tokenIndex
							if buffer[position] != rune('0') {
								goto l266
							}
							position++
							goto l265
						l266:
							position, tokenIndex = position265, tokenIndex265
							if buffer[position] != rune('1') {
								goto l256
							}
							position++
						}
					l265:
					l263:
						{
							position264, tokenIndex264 := position, tokenIndex
							{
								position267, tokenIndex267 := position, tokenIndex
								if buffer[position] != rune('0') {
									goto l268
								}
								position++
								goto l267
							l268:
								position, tokenIndex = position267, tokenIndex267
								if buffer[position] != rune('1') {
									goto l264
								}
								position++
							}
						l267:
							goto l263
						l264:
							position, tokenIndex = position264, tokenIndex264
						}
						goto l255
					l256:
						position, tokenIndex = position255, tokenIndex255
						{
							position270, tokenIndex270 := position, tokenIndex
							{
								position272, tokenIndex272 := position, tokenIndex
								if buffer[position] != rune('+') {
									goto l273
								}
								position++
								goto l272
							l273:
								position, tokenIndex = position272, tokenIndex272
								if buffer[position] != rune('-') {
									goto l270
								}
								position++
							}
						l272:
							goto l271
						l270:
							position, tokenIndex = position270, tokenIndex270
						}
					l271:
						if buffer[position] != rune('0') {
							goto l269
						}
						position++
						{
							position274, tokenIndex274 := position, tokenIndex
							if buffer[position] != rune('x') {
								goto l275
							}
							position++
							goto l274
						l275:
							position, tokenIndex = position274, tokenIndex274
							if buffer[position] != rune('X') {
								goto l269
							}
							position++
						}
					l274:
						{
							position278, tokenIndex278 := position, tokenIndex
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l279
							}
							position++
							goto l278
						l279:
							position, tokenIndex = position278, tokenIndex278
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l280
							}
							position++
							goto l278
						l280:
							position, tokenIndex = position278, tokenIndex278
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l269
							}
							position++
						}
					l278:
					l276:
						{
							position277, tokenIndex277 := position, tokenIndex
							{
								position281, tokenIndex281 := position, tokenIndex
								if c := buffer[position]; c < rune('0') || c > rune('9') {
									goto l282
								}
								position++
								goto l281
							l282:
								position, tokenIndex = position281, tokenIndex281
								if c := buffer[position]; c < rune('A') || c > rune('Z') {
									goto l283
								}
								position++
								goto l281
							l283:
								position, tokenIndex = position281, tokenIndex281
								if c := buffer[position]; c < rune('a') || c > rune('z') {
									goto l277
								}
								position++
							}
						l281:
							goto l276
						l277:
							position, tokenIndex = position277, tokenIndex277
						}
						goto l255
					l269:
						position, tokenIndex = position255, tokenIndex255
						if buffer[position] != rune('0') {
							goto l284
						}
						position++
						if buffer[position] != rune('o') {
							goto l284
						}
						position++
						if !_rules[ruleDigit]() {
							goto l284
						}
					l285:
						{
							position286, tokenIndex286 := position, tokenIndex
							if !_rules[ruleDigit]() {
								goto l286
							}
							goto l285
						l286:
							position, tokenIndex = position286, tokenIndex286
						}
						goto l255
					l284:
						position, tokenIndex = position255, tokenIndex255
						{
							position287, tokenIndex287 := position, tokenIndex
							{
								position289, tokenIndex289 := position, tokenIndex
								if buffer[position] != rune('+') {
									goto l290
								}
								position++
								goto l289
							l290:
								position, tokenIndex = position289, tokenIndex289
								if buffer[position] != rune('-') {
									goto l287
								}
								position++
							}
						l289:
							goto l288
						l287:
							position, tokenIndex = position287, tokenIndex287
						}
					l288:
						if !_rules[ruleDigit]() {
							goto l252
						}
					l291:
						{
							position292, tokenIndex292 := position, tokenIndex
							if !_rules[ruleDigit]() {
								goto l292
							}
							goto l291
						l292:
							position, tokenIndex = position292, tokenIndex292
						}
					}
				l255:
					add(rulePegText, position254)
				}
			l293:
				{
					position294, tokenIndex294 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l294
					}
					goto l293
				l294:
					position, tokenIndex = position294, tokenIndex294
				}
				add(ruleIntConstant, position253)
			}
			memoize(39, position252, tokenIndex252, true)
			return true
		l252:
			memoize(39, position252, tokenIndex252, false)
			position, tokenIndex = position252, tokenIndex252
			return false
		},
		/* 40 DoubleConstant <- <(Skip <(('+' / '-')? ((Digit* '.' Digit+ Exponent?) / (Digit+ Exponent)))> Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{40, position}]; ok {
				return memoizedResult(memoized)
			}
			position295, tokenIndex295 := position, tokenIndex
			{
				position296 := position
				if !_rules[ruleSkip]() {
					goto l295
				}
				{
					position297 := position
					{
						position298, tokenIndex298 := position, tokenIndex
						{
							position300, tokenIndex300 := position, tokenIndex
							if buffer[position] != rune('+') {
								goto l301
							}
							position++
							goto l300
						l301:
							position, tokenIndex = position300, tokenIndex300
							if buffer[position] != rune('-') {
								goto l298
							}
							position++
						}
					l300:
						goto l299
					l298:
						position, tokenIndex = position298, tokenIndex298
					}
				l299:
					{
						position302, tokenIndex302 := position, tokenIndex
					l304:
						{
							position305, tokenIndex305 := position, tokenIndex
							if !_rules[ruleDigit]() {
								goto l305
							}
							goto l304
						l305:
							position, tokenIndex = position305, tokenIndex305
						}
						if buffer[position] != rune('.') {
							goto l303
						}
						position++
						if !_rules[ruleDigit]() {
							goto l303
						}
					l306:
						{
							position307, tokenIndex307 := position, tokenIndex
							if !_rules[ruleDigit]() {
								goto l307
							}
							goto l306
						l307:
							position, tokenIndex = position307, tokenIndex307
						}
						{
							position308, tokenIndex308 := position, tokenIndex
							if !_rules[ruleExponent]() {
								goto l308
							}
							goto l309
						l308:
							position, tokenIndex = position308, tokenIndex308
						}
					l309:
						goto l302
					l303:
						position, tokenIndex = position302, tokenIndex302
						if !_rules[ruleDigit]() {
							goto l295
						}
					l310:
						{
							position311, tokenIndex311 := position, tokenIndex
							if !_rules[ruleDigit]() {
								goto l311
							}
							goto l310
						l311:
							position, tokenIndex = position311, tokenIndex311
						}
						if !_rules[ruleExponent]() {
							goto l295
						}
					}
				l302:
					add(rulePegText, position297)
				}
			l312:
				{
					position313, tokenIndex313 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l313
					}
					goto l312
				l313:
					position, tokenIndex = position313, tokenIndex313
				}
				add(ruleDoubleConstant, position296)
			}
			memoize(40, position295, tokenIndex295, true)
			return true
		l295:
			memoize(40, position295, tokenIndex295, false)
			position, tokenIndex = position295, tokenIndex295
			return false
		},
		/* 41 Exponent <- <(('e' / 'E') IntConstant)> */
		func() bool {
			if memoized, ok := memoization[memoKey{41, position}]; ok {
				return memoizedResult(memoized)
			}
			position314, tokenIndex314 := position, tokenIndex
			{
				position315 := position
				{
					position316, tokenIndex316 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l317
					}
					position++
					goto l316
				l317:
					position, tokenIndex = position316, tokenIndex316
					if buffer[position] != rune('E') {
						goto l314
					}
					position++
				}
			l316:
				if !_rules[ruleIntConstant]() {
					goto l314
				}
				add(ruleExponent, position315)
			}
			memoize(41, position314, tokenIndex314, true)
			return true
		l314:
			memoize(41, position314, tokenIndex314, false)
			position, tokenIndex = position314, tokenIndex314
			return false
		},
		/* 42 Annotations <- <(LPAR Annotation* RPAR)> */
		func() bool {
			if memoized, ok := memoization[memoKey{42, position}]; ok {
				return memoizedResult(memoized)
			}
			position318, tokenIndex318 := position, tokenIndex
			{
				position319 := position
				if !_rules[ruleLPAR]() {
					goto l318
				}
			l320:
				{
					position321, tokenIndex321 := position, tokenIndex
					if !_rules[ruleAnnotation]() {
						goto l321
					}
					goto l320
				l321:
					position, tokenIndex = position321, tokenIndex321
				}
				if !_rules[ruleRPAR]() {
					goto l318
				}
				add(ruleAnnotations, position319)
			}
			memoize(42, position318, tokenIndex318, true)
			return true
		l318:
			memoize(42, position318, tokenIndex318, false)
			position, tokenIndex = position318, tokenIndex318
			return false
		},
		/* 43 Annotation <- <(((Identifier EQUAL ConstValue) / Identifier) ListSeparator?)> */
		func() bool {
			if memoized, ok := memoization[memoKey{43, position}]; ok {
				return memoizedResult(memoized)
			}
			position322, tokenIndex322 := position, tokenIndex
			{
				position323 := position
				{
					position324, tokenIndex324 := position, tokenIndex
					if !_rules[ruleIdentifier]() {
						goto l325
					}
					if !_rules[ruleEQUAL]() {
						goto l325
					}
					if !_rules[ruleConstValue]() {
						goto l325
					}
					goto l324
				l325:
					position, tokenIndex = position324, tokenIndex324
					if !_rules[ruleIdentifier]() {
						goto l322
					}
				}
			l324:
				{
					position326, tokenIndex326 := position, tokenIndex
					if !_rules[ruleListSeparator]() {
						goto l326
					}
					goto l327
				l326:
					position, tokenIndex = position326, tokenIndex326
				}
			l327:
				add(ruleAnnotation, position323)
			}
			memoize(43, position322, tokenIndex322, true)
			return true
		l322:
			memoize(43, position322, tokenIndex322, false)
			position, tokenIndex = position322, tokenIndex322
			return false
		},
		/* 44 StructuredAnnotations <- <StructuredAnnotation*> */
		func() bool {
			if memoized, ok := memoization[memoKey{44, position}]; ok {
				return memoizedResult(memoized)
			}
			position328, tokenIndex328 := position, tokenIndex
			{
				position329 := position
			l330:
				{
					position331, tokenIndex331 := position, tokenIndex
					if !_rules[ruleStructuredAnnotation]() {
						goto l331
					}
					goto l330
				l331:
					position, tokenIndex = position331, tokenIndex331
				}
				add(ruleStructuredAnnotations, position329)
			}
			memoize(44, position328, tokenIndex328, true)
			return true
		},
		/* 45 StructuredAnnotation <- <(AT (ConstStruct / Identifier))> */
		func() bool {
			if memoized, ok := memoization[memoKey{45, position}]; ok {
				return memoizedResult(memoized)
			}
			position332, tokenIndex332 := position, tokenIndex
			{
				position333 := position
				if !_rules[ruleAT]() {
					goto l332
				}
				{
					position334, tokenIndex334 := position, tokenIndex
					if !_rules[ruleConstStruct]() {
						goto l335
					}
					goto l334
				l335:
					position, tokenIndex = position334, tokenIndex334
					if !_rules[ruleIdentifier]() {
						goto l332
					}
				}
			l334:
				add(ruleStructuredAnnotation, position333)
			}
			memoize(45, position332, tokenIndex332, true)
			return true
		l332:
			memoize(45, position332, tokenIndex332, false)
			position, tokenIndex = position332, tokenIndex332
			return false
		},
		/* 46 ConstList <- <(LBRK (ConstValue ListSeparator?)* RBRK)> */
		func() bool {
			if memoized, ok := memoization[memoKey{46, position}]; ok {
				return memoizedResult(memoized)
			}
			position336, tokenIndex336 := position, tokenIndex
			{
				position337 := position
				if !_rules[ruleLBRK]() {
					goto l336
				}
			l338:
				{
					position339, tokenIndex339 := position, tokenIndex
					if !_rules[ruleConstValue]() {
						goto l339
					}
					{
						position340, tokenIndex340 := position, tokenIndex
						if !_rules[ruleListSeparator]() {
							goto l340
						}
						goto l341
					l340:
						position, tokenIndex = position340, tokenIndex340
					}
				l341:
					goto l338
				l339:
					position, tokenIndex = position339, tokenIndex339
				}
				if !_rules[ruleRBRK]() {
					goto l336
				}
				add(ruleConstList, position337)
			}
			memoize(46, position336, tokenIndex336, true)
			return true
		l336:
			memoize(46, position336, tokenIndex336, false)
			position, tokenIndex = position336, tokenIndex336
			return false
		},
		/* 47 ConstMap <- <(LWING (ConstValue COLON ConstValue ListSeparator?)* RWING)> */
		func() bool {
			if memoized, ok := memoization[memoKey{47, position}]; ok {
				return memoizedResult(memoized)
			}
			position342, tokenIndex342 := position, tokenIndex
			{
				position343 := position
				if !_rules[ruleLWING]() {
					goto l342
				}
			l344:
				{
					position345, tokenIndex345 := position, tokenIndex
					if !_rules[ruleConstValue]() {
						goto l345
					}
					if !_rules[ruleCOLON]() {
						goto l345
					}
					if !_rules[ruleConstValue]() {
						goto l345
					}
					{
						position346, tokenIndex346 := position, tokenIndex
						if !_rules[ruleListSeparator]() {
							goto l346
						}
						goto l347
					l346:
						position, tokenIndex = position346, tokenIndex346
					}
				l347:
					goto l344
				l345:
					position, tokenIndex = position345, tokenIndex345
				}
				if !_rules[ruleRWING]() {
					goto l342
				}
				add(ruleConstMap, position343)
			}
			memoize(47, position342, tokenIndex342, true)
			return true
		l342:
			memoize(47, position342, tokenIndex342, false)
			position, tokenIndex = position342, tokenIndex342
			return false
		},
		/* 48 ConstStruct <- <(Identifier LWING (Identifier EQUAL ConstValue ListSeparator?)* RWING)> */
		func() bool {
			if memoized, ok := memoization[memoKey{48, position}]; ok {
				return memoizedResult(memoized)
			}
			position348, tokenIndex348 := position, tokenIndex
			{
				position349 := position
				if !_rules[ruleIdentifier]() {
					goto l348
				}
				if !_rules[ruleLWING]() {
					goto l348
				}
			l350:
				{
					position351, tokenIndex351 := position, tokenIndex
					if !_rules[ruleIdentifier]() {
						goto l351
					}
					if !_rules[ruleEQUAL]() {
						goto l351
					}
					if !_rules[ruleConstValue]() {
						goto l351
					}
					{
						position352, tokenIndex352 := position, tokenIndex
						if !_rules[ruleListSeparator]() {
							goto l352
						}
						goto l353
					l352:
						position, tokenIndex = position352, tokenIndex352
					}
				l353:
					goto l350
				l351:
					position, tokenIndex = position351, tokenIndex351
				}
				if !_rules[ruleRWING]() {
					goto l348
				}
				add(ruleConstStruct, position349)
			}
			memoize(48, position348, tokenIndex348, true)
			return true
		l348:
			memoize(48, position348, tokenIndex348, false)
			position, tokenIndex = position348, tokenIndex348
			return false
		},
		/* 49 EscapeLiteralChar <- <(('\\' ('"' / '\'')) / ('\\' '\\'))> */
		func() bool {
			if memoized, ok := memoization[memoKey{49, position}]; ok {
				return memoizedResult(memoized)
			}
			position354, tokenIndex354 := position, tokenIndex
			{
				position355 := position
				{
					position356, tokenIndex356 := position, tokenIndex
					if buffer[position] != rune('\\') {
						goto l357
					}
					position++
					{
						position358, tokenIndex358 := position, tokenIndex
						if buffer[position] != rune('"') {
							goto l359
						}
						position++
						goto l358
					l359:
						position, tokenIndex = position358, tokenIndex358
						if buffer[position] != rune('\'') {
							goto l357
						}
						position++
					}
				l358:
					goto l356
				l357:
					position, tokenIndex = position356, tokenIndex356
					if buffer[position] != rune('\\') {
						goto l354
					}
					position++
					if buffer[position] != rune('\\') {
						goto l354
					}
					position++
				}
			l356:
				add(ruleEscapeLiteralChar, position355)
			}
			memoize(49, position354, tokenIndex354, true)
			return true
		l354:
			memoize(49, position354, tokenIndex354, false)
			position, tokenIndex = position354, tokenIndex354
			return false
		},
		/* 50 Literal <- <((Skip '"' <(EscapeLiteralChar / (!'"' .))*> '"' Indent*) / (Skip '\'' <(EscapeLiteralChar / (!'\'' .))*> '\'' Indent*))> */
		func() bool {
			if memoized, ok := memoization[memoKey{50, position}]; ok {
				return memoizedResult(memoized)
			}
			position360, tokenIndex360 := position, tokenIndex
			{
				position361 := position
				{
					position362, tokenIndex362 := position, tokenIndex
					if !_rules[ruleSkip]() {
						goto l363
					}
					if buffer[position] != rune('"') {
						goto l363
					}
					position++
					{
						position364 := position
					l365:
						{
							position366, tokenIndex366 := position, tokenIndex
							{
								position367, tokenIndex367 := position, tokenIndex
								if !_rules[ruleEscapeLiteralChar]() {
									goto l368
								}
								goto l367
							l368:
								position, tokenIndex = position367, tokenIndex367
								{
									position369, tokenIndex369 := position, tokenIndex
									if buffer[position] != rune('"') {
										goto l369
									}
									position++
									goto l366
								l369:
									position, tokenIndex = position369, tokenIndex369
								}
								if !matchDot() {
									goto l366
								}
							}
						l367:
							goto l365
						l366:
							position, tokenIndex = position366, tokenIndex366
						}
						add(rulePegText, position364)
					}
					if buffer[position] != rune('"') {
						goto l363
					}
					position++
				l370:
					{
						position371, tokenIndex371 := position, tokenIndex
						if !_rules[ruleIndent]() {
							goto l371
						}
						goto l370
					l371:
						position, tokenIndex = position371, tokenIndex371
					}
					goto l362
				l363:
					position, tokenIndex = position362, tokenIndex362
					if !_rules[ruleSkip]() {
						goto l360
					}
					if buffer[position] != rune('\'') {
						goto l360
					}
					position++
					{
						position372 := position
					l373:
						{
							position374, tokenIndex374 := position, tokenIndex
							{
								position375, tokenIndex375 := position, tokenIndex
								if !_rules[ruleEscapeLiteralChar]() {
									goto l376
								}
								goto l375
							l376:
								position, tokenIndex = position375, tokenIndex375
								{
									position377, tokenIndex377 := position, tokenIndex
									if buffer[position] != rune('\'') {
										goto l377
									}
									position++
									goto l374
								l377:
									position, tokenIndex = position377, tokenIndex377
								}
								if !matchDot() {
									goto l374
								}
							}
						l375:
							goto l373
						l374:
							position, tokenIndex = position374, tokenIndex374
						}
						add(rulePegText, position372)
					}
					if buffer[position] != rune('\'') {
						goto l360
					}
					position++
				l378:
					{
						position379, tokenIndex379 := position, tokenIndex
						if !_rules[ruleIndent]() {
							goto l379
						}
						goto l378
					l379:
						position, tokenIndex = position379, tokenIndex379
					}
				}
			l362:
				add(ruleLiteral, position361)
			}
			memoize(50, position360, tokenIndex360, true)
			return true
		l360:
			memoize(50, position360, tokenIndex360, false)
			position, tokenIndex = position360, tokenIndex360
			return false
		},
		/* 51 Identifier <- <(Skip <(Letter (Letter / Digit / '.')*)> Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{51, position}]; ok {
				return memoizedResult(memoized)
			}
			position380, tokenIndex380 := position, tokenIndex
			{
				position381 := position
				if !_rules[ruleSkip]() {
					goto l380
				}
				{
					position382 := position
					if !_rules[ruleLetter]() {
						goto l380
					}
				l383:
					{
						position384, tokenIndex384 := position, tokenIndex
						{
							position385, tokenIndex385 := position, tokenIndex
							if !_rules[ruleLetter]() {
								goto l386
							}
							goto l385
						l386:
							position, tokenIndex = position385, tokenIndex385
							if !_rules[ruleDigit]() {
								goto l387
							}
							goto l385
						l387:
							position, tokenIndex = position385, tokenIndex385
							if buffer[position] != rune('.') {
								goto l384
							}
							position++
						}
					l385:
						goto l383
					l384:
						position, tokenIndex = position384, tokenIndex384
					}
					add(rulePegText, position382)
				}
			l388:
				{
					position389, tokenIndex389 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l389
					}
					goto l388
				l389:
					position, tokenIndex = position389, tokenIndex389
				}
				add(ruleIdentifier, position381)
			}
			memoize(51, position380, tokenIndex380, true)
			return true
		l380:
			memoize(51, position380, tokenIndex380, false)
			position, tokenIndex = position380, tokenIndex380
			return false
		},
		/* 52 ListSeparator <- <(Skip (',' / ';') Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{52, position}]; ok {
				return memoizedResult(memoized)
			}
			position390, tokenIndex390 := position, tokenIndex
			{
				position391 := position
				if !_rules[ruleSkip]() {
					goto l390
				}
				{
					position392, tokenIndex392 := position, tokenIndex
					if buffer[position] != rune(',') {
						goto l393
					}
					position++
					goto l392
				l393:
					position, tokenIndex = position392, tokenIndex392
					if buffer[position] != rune(';') {
						goto l390
					}
					position++
				}
			l392:
			l394:
				{
					position395, tokenIndex395 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l395
					}
					goto l394
				l395:
					position, tokenIndex = position395, tokenIndex395
				}
				add(ruleListSeparator, position391)
			}
			memoize(52, position390, tokenIndex390, true)
			return true
		l390:
			memoize(52, position390, tokenIndex390, false)
			position, tokenIndex = position390, tokenIndex390
			return false
		},
		/* 53 Letter <- <([A-Z] / [a-z] / '_')> */
		func() bool {
			if memoized, ok := memoization[memoKey{53, position}]; ok {
				return memoizedResult(memoized)
			}
			position396, tokenIndex396 := position, tokenIndex
			{
				position397 := position
				{
					position398, tokenIndex398 := position, tokenIndex
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l399
					}
					position++
					goto l398
				l399:
					position, tokenIndex = position398, tokenIndex398
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l400
					}
					position++
					goto l398
				l400:
					position, tokenIndex = position398, tokenIndex398
					if buffer[position] != rune('_') {
						goto l396
					}
					position++
				}
			l398:
				add(ruleLetter, position397)
			}
			memoize(53, position396, tokenIndex396, true)
			return true
		l396:
			memoize(53, position396, tokenIndex396, false)
			position, tokenIndex = position396, tokenIndex396
			return false
		},
		/* 54 LetterOrDigit <- <([a-z] / [A-Z] / [0-9] / ('_' / '$'))> */
		func() bool {
			if memoized, ok := memoization[memoKey{54, position}]; ok {
				return memoizedResult(memoized)
			}
			position401, tokenIndex401 := position, tokenIndex
			{
				position402 := position
				{
					position403, tokenIndex403 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l404
					}
					position++
					goto l403
				l404:
					position, tokenIndex = position403, tokenIndex403
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l405
					}
					position++
					goto l403
				l405:
					position, tokenIndex = position403, tokenIndex403
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l406
					}
					position++
					goto l403
				l406:
					position, tokenIndex = position403, tokenIndex403
					{
						position407, tokenIndex407 := position, tokenIndex
						if buffer[position] != rune('_') {
							goto l408
						}
						position++
						goto l407
					l408:
						position, tokenIndex = position407, tokenIndex407
						if buffer[position] != rune('$') {
							goto l401
						}
						position++
					}
				l407:
				}
			l403:
				add(ruleLetterOrDigit, position402)
			}
			memoize(54, position401, tokenIndex401, true)
			return true
		l401:
			memoize(54, position401, tokenIndex401, false)
			position, tokenIndex = position401, tokenIndex401
			return false
		},
		/* 55 Digit <- <[0-9]> */
		func() bool {
			if memoized, ok := memoization[memoKey{55, position}]; ok {
				return memoizedResult(memoized)
			}
			position409, tokenIndex409 := position, tokenIndex
			{
				position410 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l409
				}
				position++
				add(ruleDigit, position410)
			}
			memoize(55, position409, tokenIndex409, true)
			return true
		l409:
			memoize(55, position409, tokenIndex409, false)
			position, tokenIndex = position409, tokenIndex409
			return false
		},
		/* 56 ReservedComments <- <Skip> */
		func() bool {
			if memoized, ok := memoization[memoKey{56, position}]; ok {
				return memoizedResult(memoized)
			}
			position411, tokenIndex411 := position, tokenIndex
			{
				position412 := position
				if !_rules[ruleSkip]() {
					goto l411
				}
				add(ruleReservedComments, position412)
			}
			memoize(56, position411, tokenIndex411, true)
			return true
		l411:
			memoize(56, position411, tokenIndex411, false)
			position, tokenIndex = position411, tokenIndex411
			return false
		},
		/* 57 ReservedEndLineComments <- <SkipLine> */
		func() bool {
			if memoized, ok := memoization[memoKey{57, position}]; ok {
				return memoizedResult(memoized)
			}
			position413, tokenIndex413 := position, tokenIndex
			{
				position414 := position
				if !_rules[ruleSkipLine]() {
					goto l413
				}
				add(ruleReservedEndLineComments, position414)
			}
			memoize(57, position413, tokenIndex413, true)
			return true
		l413:
			memoize(57, position413, tokenIndex413, false)
			position, tokenIndex = position413, tokenIndex413
			return false
		},
		/* 58 Skip <- <(Space / Comment)*> */
		func() bool {
			if memoized, ok := memoization[memoKey{58, position}]; ok {
				return memoizedResult(memoized)
			}
			position415, tokenIndex415 := position, tokenIndex
			{
				position416 := position
			l417:
				{
					position418, tokenIndex418 := position, tokenIndex
					{
						position419, tokenIndex419 := position, tokenIndex
						if !_rules[ruleSpace]() {
							goto l420
						}
						goto l419
					l420:
						position, tokenIndex = position419, tokenIndex419
						if !_rules[ruleComment]() {
							goto l418
						}
					}
				l419:
					goto l417
				l418:
					position, tokenIndex = position418, tokenIndex418
				}
				add(ruleSkip, position416)
			}
			memoize(58, position415, tokenIndex415, true)
			return true
		},
		/* 59 SkipLine <- <(Indent / Comment)*> */
		func() bool {
			if memoized, ok := memoization[memoKey{59, position}]; ok {
				return memoizedResult(memoized)
			}
			position421, tokenIndex421 := position, tokenIndex
			{
				position422 := position
			l423:
				{
					position424, tokenIndex424 := position, tokenIndex
					{
						position425, tokenIndex425 := position, tokenIndex
						if !_rules[ruleIndent]() {
							goto l426
						}
						goto l425
					l426:
						position, tokenIndex = position425, tokenIndex425
						if !_rules[ruleComment]() {
							goto l424
						}
					}
				l425:
					goto l423
				l424:
					position, tokenIndex = position424, tokenIndex424
				}
				add(ruleSkipLine, position422)
			}
			memoize(59, position421, tokenIndex421, true)
			return true
		},
		/* 60 Space <- <(Indent / CarriageReturnLineFeed)+> */
		func() bool {
			if memoized, ok := memoization[memoKey{60, position}]; ok {
				return memoizedResult(memoized)
			}
			position427, tokenIndex427 := position, tokenIndex
			{
				position428 := position
				{
					position431, tokenIndex431 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l432
					}
					goto l431
				l432:
					position, tokenIndex = position431, tokenIndex431
					if !_rules[ruleCarriageReturnLineFeed]() {
						goto l427
					}
				}
			l431:
			l429:
				{
					position430, tokenIndex430 := position, tokenIndex
					{
						position433, tokenIndex433 := position, tokenIndex
						if !_rules[ruleIndent]() {
							goto l434
						}
						goto l433
					l434:
						position, tokenIndex = position433, tokenIndex433
						if !_rules[ruleCarriageReturnLineFeed]() {
							goto l430
						}
					}
				l433:
					goto l429
				l430:
					position, tokenIndex = position430, tokenIndex430
				}
				add(ruleSpace, position428)
			}
			memoize(60, position427, tokenIndex427, true)
			return true
		l427:
			memoize(60, position427, tokenIndex427, false)
			position, tokenIndex = position427, tokenIndex427
			return false
		},
		/* 61 Indent <- <(' ' / '\t' / '\v')> */
		func() bool {
			if memoized, ok := memoization[memoKey{61, position}]; ok {
				return memoizedResult(memoized)
			}
			position435, tokenIndex435 := position, tokenIndex
			{
				position436 := position
				{
					position437, tokenIndex437 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l438
					}
					position++
					goto l437
				l438:
					position, tokenIndex = position437, tokenIndex437
					if buffer[position] != rune('\t') {
						goto l439
					}
					position++
					goto l437
				l439:
					position, tokenIndex = position437, tokenIndex437
					if buffer[position] != rune('\v') {
						goto l435
					}
					position++
				}
			l437:
				add(ruleIndent, position436)
			}
			memoize(61, position435, tokenIndex435, true)
			return true
		l435:
			memoize(61, position435, tokenIndex435, false)
			position, tokenIndex = position435, tokenIndex435
			return false
		},
		/* 62 CarriageReturnLineFeed <- <('\r' / '\n')> */
		func() bool {
			if memoized, ok := memoization[memoKey{62, position}]; ok {
				return memoizedResult(memoized)
			}
			position440, tokenIndex440 := position, tokenIndex
			{
				position441 := position
				{
					position442, tokenIndex442 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l443
					}
					position++
					goto l442
				l443:
					position, tokenIndex = position442, tokenIndex442
					if buffer[position] != rune('\n') {
						goto l440
					}
					position++
				}
			l442:
				add(ruleCarriageReturnLineFeed, position441)
			}
			memoize(62, position440, tokenIndex440, true)
			return true
		l440:
			memoize(62, position440, tokenIndex440, false)
			position, tokenIndex = position440, tokenIndex440
			return false
		},
		/* 63 Comment <- <(LongComment / LineComment / UnixComment)> */
		func() bool {
			if memoized, ok := memoization[memoKey{63, position}]; ok {
				return memoizedResult(memoized)
			}
			position444, tokenIndex444 := position, tokenIndex
			{
				position445 := position
				{
					position446, tokenIndex446 := position, tokenIndex
					if !_rules[ruleLongComment]() {
						goto l447
					}
					goto l446
				l447:
					position, tokenIndex = position446, tokenIndex446
					if !_rules[ruleLineComment]() {
						goto l448
					}
					goto l446
				l448:
					position, tokenIndex = position446, tokenIndex446
					if !_rules[ruleUnixComment]() {
						goto l444
					}
				}
			l446:
				add(ruleComment, position445)
			}
			memoize(63, position444, tokenIndex444, true)
			return true
		l444:
			memoize(63, position444, tokenIndex444, false)
			position, tokenIndex = position444, tokenIndex444
			return false
		},
		/* 64 LongComment <- <('/' '*' (!('*' '/') .)* ('*' '/'))> */
		func() bool {
			if memoized, ok := memoization[memoKey{64, position}]; ok {
				return memoizedResult(memoized)
			}
			position449, tokenIndex449 := position, tokenIndex
			{
				position450 := position
				if buffer[position] != rune('/') {
					goto l449
				}
				position++
				if buffer[position] != rune('*') {
					goto l449
				}
				position++
			l451:
				{
					position452, tokenIndex452 := position, tokenIndex
					{
						position453, tokenIndex453 := position, tokenIndex
						if buffer[position] != rune('*') {
							goto l453
						}
						position++
						if buffer[position] != rune('/') {
							goto l453
						}
						position++
						goto l452
					l453:
						position, tokenIndex = position453, tokenIndex453
					}
					if !matchDot() {
						goto l452
					}
					goto l451
				l452:
					position, tokenIndex = position452, tokenIndex452
				}
				if buffer[position] != rune('*') {
					goto l449
				}
				position++
				if buffer[position] != rune('/') {
					goto l449
				}
				position++
				add(ruleLongComment, position450)
			}
			memoize(64, position449, tokenIndex449, true)
			return true
		l449:
			memoize(64, position449, tokenIndex449, false)
			position, tokenIndex = position449, tokenIndex449
			return false
		},
		/* 65 LineComment <- <('/' '/' (!('\r' / '\n') .)*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{65, position}]; ok {
				return memoizedResult(memoized)
			}
			position454, tokenIndex454 := position, tokenIndex
			{
				position455 := position
				if buffer[position] != rune('/') {
					goto l454
				}
				position++
				if buffer[position] != rune('/') {
					goto l454
				}
				position++
			l456:
				{
					position457, tokenIndex457 := position, tokenIndex
					{
						position458, tokenIndex458 := position, tokenIndex
						{
							position459, tokenIndex459 := position, tokenIndex
							if buffer[position] != rune('\r') {
								goto l460
							}
							position++
							goto l459
						l460:
							position, tokenIndex = position459, tokenIndex459
							if buffer[position] != rune('\n') {
								goto l458
							}
							position++
						}
					l459:
						goto l457
					l458:
						position, tokenIndex = position458, tokenIndex458
					}
					if !matchDot() {
						goto l457
					}
					goto l456
				l457:
					position, tokenIndex = position457, tokenIndex457
				}
				add(ruleLineComment, position455)
			}
			memoize(65, position454, tokenIndex454, true)
			return true
		l454:
			memoize(65, position454, tokenIndex454, false)
			position, tokenIndex = position454, tokenIndex454
			return false
		},
		/* 66 UnixComment <- <('#' (!('\r' / '\n') .)*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{66, position}]; ok {
				return memoizedResult(memoized)
			}
			position461, tokenIndex461 := position, tokenIndex
			{
				position462 := position
				if buffer[position] != rune('#') {
					goto l461
				}
				position++
			l463:
				{
					position464, tokenIndex464 := position, tokenIndex
					{
						position465, tokenIndex465 := position, tokenIndex
						{
							position466, tokenIndex466 := position, tokenIndex
							if buffer[position] != rune('\r') {
								goto l467
							}
							position++
							goto l466
						l467:
							position, tokenIndex = position466, tokenIndex466
							if buffer[position] != rune('\n') {
								goto l465
							}
							position++
						}
					l466:
						goto l464
					l465:
						position, tokenIndex = position465, tokenIndex465
					}
					if !matchDot() {
						goto l464
					}
					goto l463
				l464:
					position, tokenIndex = position464, tokenIndex464
				}
				add(ruleUnixComment, position462)
			}
			memoize(66, position461, tokenIndex461, true)
			return true
		l461:
			memoize(66, position461, tokenIndex461, false)
			position, tokenIndex = position461, tokenIndex461
			return false
		},
		/* 67 BOOL <- <(Skip <('b' 'o' 'o' 'l')> !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{67, position}]; ok {
				return memoizedResult(memoized)
			}
			position468, tokenIndex468 := position, tokenIndex
			{
				position469 := position
				if !_rules[ruleSkip]() {
					goto l468
				}
				{
					position470 := position
					if buffer[position] != rune('b') {
						goto l468
					}
					position++
					if buffer[position] != rune('o') {
						goto l468
					}
					position++
					if buffer[position] != rune('o') {
						goto l468
					}
					position++
					if buffer[position] != rune('l') {
						goto l468
					}
					position++
					add(rulePegText, position470)
				}
				{
					position471, tokenIndex471 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l471
					}
					goto l468
				l471:
					position, tokenIndex = position471, tokenIndex471
				}
			l472:
				{
					position473, tokenIndex473 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l473
					}
					goto l472
				l473:
					position, tokenIndex = position473, tokenIndex473
				}
				add(ruleBOOL, position469)
			}
			memoize(67, position468, tokenIndex468, true)
			return true
		l468:
			memoize(67, position468, tokenIndex468, false)
			position, tokenIndex = position468, tokenIndex468
			return false
		},
		/* 68 BYTE <- <(Skip <('b' 'y' 't' 'e')> !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{68, position}]; ok {
				return memoizedResult(memoized)
			}
			position474, tokenIndex474 := position, tokenIndex
			{
				position475 := position
				if !_rules[ruleSkip]() {
					goto l474
				}
				{
					position476 := position
					if buffer[position] != rune('b') {
						goto l474
					}
					position++
					if buffer[position] != rune('y') {
						goto l474
					}
					position++
					if buffer[position] != rune('t') {
						goto l474
					}
					position++
					if buffer[position] != rune('e') {
						goto l474
					}
					position++
					add(rulePegText, position476)
				}
				{
					position477, tokenIndex477 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l477
					}
					goto l474
				l477:
					position, tokenIndex = position477, tokenIndex477
				}
			l478:
				{
					position479, tokenIndex479 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l479
					}
					goto l478
				l479:
					position, tokenIndex = position479, tokenIndex479
				}
				add(ruleBYTE, position475)
			}
			memoize(68, position474, tokenIndex474, true)
			return true
		l474:
			memoize(68, position474, tokenIndex474, false)
			position, tokenIndex = position474, tokenIndex474
			return false
		},
		/* 69 I8 <- <(Skip <('i' '8')> !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{69, position}]; ok {
				return memoizedResult(memoized)
			}
			position480, tokenIndex480 := position, tokenIndex
			{
				position481 := position
				if !_rules[ruleSkip]() {
					goto l480
				}
				{
					position482 := position
					if buffer[position] != rune('i') {
						goto l480
					}
					position++
					if buffer[position] != rune('8') {
						goto l480
					}
					position++
					add(rulePegText, position482)
				}
				{
					position483, tokenIndex483 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l483
					}
					goto l480
				l483:
					position, tokenIndex = position483, tokenIndex483
				}
			l484:
				{
					position485, tokenIndex485 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l485
					}
					goto l484
				l485:
					position, tokenIndex = position485, tokenIndex485
				}
				add(ruleI8, position481)
			}
			memoize(69, position480, tokenIndex480, true)
			return true
		l480:
			memoize(69, position480, tokenIndex480, false)
			position, tokenIndex = position480, tokenIndex480
			return false
		},
		/* 70 I16 <- <(Skip <('i' '1' '6')> !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{70, position}]; ok {
				return memoizedResult(memoized)
			}
			position486, tokenIndex486 := position, tokenIndex
			{
				position487 := position
				if !_rules[ruleSkip]() {
					goto l486
				}
				{
					position488 := position
					if buffer[position] != rune('i') {
						goto l486
					}
					position++
					if buffer[position] != rune('1') {
						goto l486
					}
					position++
					if buffer[position] != rune('6') {
						goto l486
					}
					position++
					add(rulePegText, position488)
				}
				{
					position489, tokenIndex489 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l489
					}
					goto l486
				l489:
					position, tokenIndex = position489, tokenIndex489
				}
			l490:
				{
					position491, tokenIndex491 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l491
					}
					goto l490
				l491:
					position, tokenIndex = position491, tokenIndex491
				}
				add(ruleI16, position487)
			}
			memoize(70, position486, tokenIndex486, true)
			return true
		l486:
			memoize(70, position486, tokenIndex486, false)
			position, tokenIndex = position486, tokenIndex486
			return false
		},
		/* 71 I32 <- <(Skip <('i' '3' '2')> !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{71, position}]; ok {
				return memoizedResult(memoized)
			}
			position492, tokenIndex492 := position, tokenIndex
			{
				position493 := position
				if !_rules[ruleSkip]() {
					goto l492
				}
				{
					position494 := position
					if buffer[position] != rune('i') {
						goto l492
					}
					position++
					if buffer[position] != rune('3') {
						goto l492
					}
					position++
					if buffer[position] != rune('2') {
						goto l492
					}
					position++
					add(rulePegText, position494)
				}
				{
					position495, tokenIndex495 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l495
					}
					goto l492
				l495:
					position, tokenIndex = position495, tokenIndex495
				}
			l496:
				{
					position497, tokenIndex497 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l497
					}
					goto l496
				l497:
					position, tokenIndex = position497, tokenIndex497
				}
				add(ruleI32, position493)
			}
			memoize(71, position492, tokenIndex492, true)
			return true
		l492:
			memoize(71, position492, tokenIndex492, false)
			position, tokenIndex = position492, tokenIndex492
			return false
		},
		/* 72 I64 <- <(Skip <('i' '6' '4')> !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{72, position}]; ok {
				return memoizedResult(memoized)
			}
			position498, tokenIndex498 := position, tokenIndex
			{
				position499 := position
				if !_rules[ruleSkip]() {
					goto l498
				}
				{
					position500 := position
					if buffer[position] != rune('i') {
						goto l498
					}
					position++
					if buffer[position] != rune('6') {
						goto l498
					}
					position++
					if buffer[position] != rune('4') {
						goto l498
					}
					position++
					add(rulePegText, position500)
				}
				{
					position501, tokenIndex501 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l501
					}
					goto l498
				l501:
					position, tokenIndex = position501, tokenIndex501
				}
			l502:
				{
					position503, tokenIndex503 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l503
					}
					goto l502
				l503:
					position, tokenIndex = position503, tokenIndex503
				}
				add(ruleI64, position499)
			}
			memoize(72, position498, tokenIndex498, true)
			return true
		l498:
			memoize(72, position498, tokenIndex498, false)
			position, tokenIndex = position498, tokenIndex498
			return false
		},
		/* 73 DOUBLE <- <(Skip <('d' 'o' 'u' 'b' 'l' 'e')> !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{73, position}]; ok {
				return memoizedResult(memoized)
			}
			position504, tokenIndex504 := position, tokenIndex
			{
				position505 := position
				if !_rules[ruleSkip]() {
					goto l504
				}
				{
					position506 := position
					if buffer[position] != rune('d') {
						goto l504
					}
					position++
					if buffer[position] != rune('o') {
						goto l504
					}
					position++
					if buffer[position] != rune('u') {
						goto l504
					}
					position++
					if buffer[position] != rune('b') {
						goto l504
					}
					position++
					if buffer[position] != rune('l') {
						goto l504
					}
					position++
					if buffer[position] != rune('e') {
						goto l504
					}
					position++
					add(rulePegText, position506)
				}
				{
					position507, tokenIndex507 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l507
					}
					goto l504
				l507:
					position, tokenIndex = position507, tokenIndex507
				}
			l508:
				{
					position509, tokenIndex509 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l509
					}
					goto l508
				l509:
					position, tokenIndex = position509, tokenIndex509
				}
				add(ruleDOUBLE, position505)
			}
			memoize(73, position504, tokenIndex504, true)
			return true
		l504:
			memoize(73, position504, tokenIndex504, false)
			position, tokenIndex = position504, tokenIndex504
			return false
		},
		/* 74 STRING <- <(Skip <('s' 't' 'r' 'i' 'n' 'g')> !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{74, position}]; ok {
				return memoizedResult(memoized)
			}
			position510, tokenIndex510 := position, tokenIndex
			{
				position511 := position
				if !_rules[ruleSkip]() {
					goto l510
				}
				{
					position512 := position
					if buffer[position] != rune('s') {
						goto l510
					}
					position++
					if buffer[position] != rune('t') {
						goto l510
					}
					position++
					if buffer[position] != rune('r') {
						goto l510
					}
					position++
					if buffer[position] != rune('i') {
						goto l510
					}
					position++
					if buffer[position] != rune('n') {
						goto l510
					}
					position++
					if buffer[position] != rune('g') {
						goto l510
					}
					position++
					add(rulePegText, position512)
				}
				{
					position513, tokenIndex513 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l513
					}
					goto l510
				l513:
					position, tokenIndex = position513, tokenIndex513
				}
			l514:
				{
					position515, tokenIndex515 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l515
					}
					goto l514
				l515:
					position, tokenIndex = position515, tokenIndex515
				}
				add(ruleSTRING, position511)
			}
			memoize(74, position510, tokenIndex510, true)
			return true
		l510:
			memoize(74, position510, tokenIndex510, false)
			position, tokenIndex = position510, tokenIndex510
			return false
		},
		/* 75 BINARY <- <(Skip <('b' 'i' 'n' 'a' 'r' 'y')> !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{75, position}]; ok {
				return memoizedResult(memoized)
			}
			position516, tokenIndex516 := position, tokenIndex
			{
				position517 := position
				if !_rules[ruleSkip]() {
					goto l516
				}
				{
					position518 := position
					if buffer[position] != rune('b') {
						goto l516
					}
					position++
					if buffer[position] != rune('i') {
						goto l516
					}
					position++
					if buffer[position] != rune('n') {
						goto l516
					}
					position++
					if buffer[position] != rune('a') {
						goto l516
					}
					position++
					if buffer[position] != rune('r') {
						goto l516
					}
					position++
					if buffer[position] != rune('y') {
						goto l516
					}
					position++
					add(rulePegText, position518)
				}
				{
					position519, tokenIndex519 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l519
					}
					goto l516
				l519:
					position, tokenIndex = position519, tokenIndex519
				}
			l520:
				{
					position521, tokenIndex521 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l521
					}
					goto l520
				l521:
					position, tokenIndex = position521, tokenIndex521
				}
				add(ruleBINARY, position517)
			}
			memoize(75, position516, tokenIndex516, true)
			return true
		l516:
			memoize(75, position516, tokenIndex516, false)
			position, tokenIndex = position516, tokenIndex516
			return false
		},
		/* 76 CONST <- <(Skip ('c' 'o' 'n' 's' 't') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{76, position}]; ok {
				return memoizedResult(memoized)
			}
			position522, tokenIndex522 := position, tokenIndex
			{
				position523 := position
				if !_rules[ruleSkip]() {
					goto l522
				}
				if buffer[position] != rune('c') {
					goto l522
				}
				position++
				if buffer[position] != rune('o') {
					goto l522
				}
				position++
				if buffer[position] != rune('n') {
					goto l522
				}
				position++
				if buffer[position] != rune('s') {
					goto l522
				}
				position++
				if buffer[position] != rune('t') {
					goto l522
				}
				position++
				{
					position524, tokenIndex524 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l524
					}
					goto l522
				l524:
					position, tokenIndex = position524, tokenIndex524
				}
			l525:
				{
					position526, tokenIndex526 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l526
					}
					goto l525
				l526:
					position, tokenIndex = position526, tokenIndex526
				}
				add(ruleCONST, position523)
			}
			memoize(76, position522, tokenIndex522, true)
			return true
		l522:
			memoize(76, position522, tokenIndex522, false)
			position, tokenIndex = position522, tokenIndex522
			return false
		},
		/* 77 ONEWAY <- <(Skip ('o' 'n' 'e' 'w' 'a' 'y') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{77, position}]; ok {
				return memoizedResult(memoized)
			}
			position527, tokenIndex527 := position, tokenIndex
			{
				position528 := position
				if !_rules[ruleSkip]() {
					goto l527
				}
				if buffer[position] != rune('o') {
					goto l527
				}
				position++
				if buffer[position] != rune('n') {
					goto l527
				}
				position++
				if buffer[position] != rune('e') {
					goto l527
				}
				position++
				if buffer[position] != rune('w') {
					goto l527
				}
				position++
				if buffer[position] != rune('a') {
					goto l527
				}
				position++
				if buffer[position] != rune('y') {
					goto l527
				}
				position++
				{
					position529, tokenIndex529 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l529
					}
					goto l527
				l529:
					position, tokenIndex = position529, tokenIndex529
				}
			l530:
				{
					position531, tokenIndex531 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l531
					}
					goto l530
				l531:
					position, tokenIndex = position531, tokenIndex531
				}
				add(ruleONEWAY, position528)
			}
			memoize(77, position527, tokenIndex527, true)
			return true
		l527:
			memoize(77, position527, tokenIndex527, false)
			position, tokenIndex = position527, tokenIndex527
			return false
		},
		/* 78 READONLY <- <(Skip ('r' 'e' 'a' 'd' 'o' 'n' 'l' 'y') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{78, position}]; ok {
				return memoizedResult(memoized)
			}
			position532, tokenIndex532 := position, tokenIndex
			{
				position533 := position
				if !_rules[ruleSkip]() {
					goto l532
				}
				if buffer[position] != rune('r') {
					goto l532
				}
				position++
				if buffer[position] != rune('e') {
					goto l532
				}
				position++
				if buffer[position] != rune('a') {
					goto l532
				}
				position++
				if buffer[position] != rune('d') {
					goto l532
				}
				position++
				if buffer[position] != rune('o') {
					goto l532
				}
				position++
				if buffer[position] != rune('n') {
					goto l532
				}
				position++
				if buffer[position] != rune('l') {
					goto l532
				}
				position++
				if buffer[position] != rune('y') {
					goto l532
				}
				position++
				{
					position534, tokenIndex534 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l534
					}
					goto l532
				l534:
					position, tokenIndex = position534, tokenIndex534
				}
			l535:
				{
					position536, tokenIndex536 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l536
					}
					goto l535
				l536:
					position, tokenIndex = position536, tokenIndex536
				}
				add(ruleREADONLY, position533)
			}
			memoize(78, position532, tokenIndex532, true)
			return true
		l532:
			memoize(78, position532, tokenIndex532, false)
			position, tokenIndex = position532, tokenIndex532
			return false
		},
		/* 79 IDEMPOTENT <- <(Skip ('i' 'd' 'e' 'm' 'p' 'o' 't' 'e' 'n' 't') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{79, position}]; ok {
				return memoizedResult(memoized)
			}
			position537, tokenIndex537 := position, tokenIndex
			{
				position538 := position
				if !_rules[ruleSkip]() {
					goto l537
				}
				if buffer[position] != rune('i') {
					goto l537
				}
				position++
				if buffer[position] != rune('d') {
					goto l537
				}
				position++
				if buffer[position] != rune('e') {
					goto l537
				}
				position++
				if buffer[position] != rune('m') {
					goto l537
				}
				position++
				if buffer[position] != rune('p') {
					goto l537
				}
				position++
				if buffer[position] != rune('o') {
					goto l537
				}
				position++
				if buffer[position] != rune('t') {
					goto l537
				}
				position++
				if buffer[position] != rune('e') {
					goto l537
				}
				position++
				if buffer[position] != rune('n') {
					goto l537
				}
				position++
				if buffer[position] != rune('t') {
					goto l537
				}
				position++
				{
					position539, tokenIndex539 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l539
					}
					goto l537
				l539:
					position, tokenIndex = position539, tokenIndex539
				}
			l540:
				{
					position541, tokenIndex541 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l541
					}
					goto l540
				l541:
					position, tokenIndex = position541, tokenIndex541
				}
				add(ruleIDEMPOTENT, position538)
			}
			memoize(79, position537, tokenIndex537, true)
			return true
		l537:
			memoize(79, position537, tokenIndex537, false)
			position, tokenIndex = position537, tokenIndex537
			return false
		},
		/* 80 TYPEDEF <- <(Skip ('t' 'y' 'p' 'e' 'd' 'e' 'f') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{80, position}]; ok {
				return memoizedResult(memoized)
			}
			position542, tokenIndex542 := position, tokenIndex
			{
				position543 := position
				if !_rules[ruleSkip]() {
					goto l542
				}
				if buffer[position] != rune('t') {
					goto l542
				}
				position++
				if buffer[position] != rune('y') {
					goto l542
				}
				position++
				if buffer[position] != rune('p') {
					goto l542
				}
				position++
				if buffer[position] != rune('e') {
					goto l542
				}
				position++
				if buffer[position] != rune('d') {
					goto l542
				}
				position++
				if buffer[position] != rune('e') {
					goto l542
				}
				position++
				if buffer[position] != rune('f') {
					goto l542
				}
				position++
				{
					position544, tokenIndex544 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l544
					}
					goto l542
				l544:
					position, tokenIndex = position544, tokenIndex544
				}
			l545:
				{
					position546, tokenIndex546 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l546
					}
					goto l545
				l546:
					position, tokenIndex = position546, tokenIndex546
				}
				add(ruleTYPEDEF, position543)
			}
			memoize(80, position542, tokenIndex542, true)
			return true
		l542:
			memoize(80, position542, tokenIndex542, false)
			position, tokenIndex = position542, tokenIndex542
			return false
		},
		/* 81 MAP <- <(Skip ('m' 'a' 'p') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{81, position}]; ok {
				return memoizedResult(memoized)
			}
			position547, tokenIndex547 := position, tokenIndex
			{
				position548 := position
				if !_rules[ruleSkip]() {
					goto l547
				}
				if buffer[position] != rune('m') {
					goto l547
				}
				position++
				if buffer[position] != rune('a') {
					goto l547
				}
				position++
				if buffer[position] != rune('p') {
					goto l547
				}
				position++
				{
					position549, tokenIndex549 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l549
					}
					goto l547
				l549:
					position, tokenIndex = position549, tokenIndex549
				}
			l550:
				{
					position551, tokenIndex551 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l551
					}
					goto l550
				l551:
					position, tokenIndex = position551, tokenIndex551
				}
				add(ruleMAP, position548)
			}
			memoize(81, position547, tokenIndex547, true)
			return true
		l547:
			memoize(81, position547, tokenIndex547, false)
			position, tokenIndex = position547, tokenIndex547
			return false
		},
		/* 82 SET <- <(Skip ('s' 'e' 't') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{82, position}]; ok {
				return memoizedResult(memoized)
			}
			position552, tokenIndex552 := position, tokenIndex
			{
				position553 := position
				if !_rules[ruleSkip]() {
					goto l552
				}
				if buffer[position] != rune('s') {
					goto l552
				}
				position++
				if buffer[position] != rune('e') {
					goto l552
				}
				position++
				if buffer[position] != rune('t') {
					goto l552
				}
				position++
				{
					position554, tokenIndex554 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l554
					}
					goto l552
				l554:
					position, tokenIndex = position554, tokenIndex554
				}
			l555:
				{
					position556, tokenIndex556 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l556
					}
					goto l555
				l556:
					position, tokenIndex = position556, tokenIndex556
				}
				add(ruleSET, position553)
			}
			memoize(82, position552, tokenIndex552, true)
			return true
		l552:
			memoize(82, position552, tokenIndex552, false)
			position, tokenIndex = position552, tokenIndex552
			return false
		},
		/* 83 LIST <- <(Skip ('l' 'i' 's' 't') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{83, position}]; ok {
				return memoizedResult(memoized)
			}
			position557, tokenIndex557 := position, tokenIndex
			{
				position558 := position
				if !_rules[ruleSkip]() {
					goto l557
				}
				if buffer[position] != rune('l') {
					goto l557
				}
				position++
				if buffer[position] != rune('i') {
					goto l557
				}
				position++
				if buffer[position] != rune('s') {
					goto l557
				}
				position++
				if buffer[position] != rune('t') {
					goto l557
				}
				position++
				{
					position559, tokenIndex559 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l559
					}
					goto l557
				l559:
					position, tokenIndex = position559, tokenIndex559
				}
			l560:
				{
					position561, tokenIndex561 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l561
					}
					goto l560
				l561:
					position, tokenIndex = position561, tokenIndex561
				}
				add(ruleLIST, position558)
			}
			memoize(83, position557, tokenIndex557, true)
			return true
		l557:
			memoize(83, position557, tokenIndex557, false)
			position, tokenIndex = position557, tokenIndex557
			return false
		},
		/* 84 VOID <- <(Skip ('v' 'o' 'i' 'd') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{84, position}]; ok {
				return memoizedResult(memoized)
			}
			position562, tokenIndex562 := position, tokenIndex
			{
				position563 := position
				if !_rules[ruleSkip]() {
					goto l562
				}
				if buffer[position] != rune('v') {
					goto l562
				}
				position++
				if buffer[position] != rune('o') {
					goto l562
				}
				position++
				if buffer[position] != rune('i') {
					goto l562
				}
				position++
				if buffer[position] != rune('d') {
					goto l562
				}
				position++
				{
					position564, tokenIndex564 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l564
					}
					goto l562
				l564:
					position, tokenIndex = position564, tokenIndex564
				}
			l565:
				{
					position566, tokenIndex566 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l566
					}
					goto l565
				l566:
					position, tokenIndex = position566, tokenIndex566
				}
				add(ruleVOID, position563)
			}
			memoize(84, position562, tokenIndex562, true)
			return true
		l562:
			memoize(84, position562, tokenIndex562, false)
			position, tokenIndex = position562, tokenIndex562
			return false
		},
		/* 85 THROWS <- <(Skip ('t' 'h' 'r' 'o' 'w' 's') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{85, position}]; ok {
				return memoizedResult(memoized)
			}
			position567, tokenIndex567 := position, tokenIndex
			{
				position568 := position
				if !_rules[ruleSkip]() {
					goto l567
				}
				if buffer[position] != rune('t') {
					goto l567
				}
				position++
				if buffer[position] != rune('h') {
					goto l567
				}
				position++
				if buffer[position] != rune('r') {
					goto l567
				}
				position++
				if buffer[position] != rune('o') {
					goto l567
				}
				position++
				if buffer[position] != rune('w') {
					goto l567
				}
				position++
				if buffer[position] != rune('s') {
					goto l567
				}
				position++
				{
					position569, tokenIndex569 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l569
					}
					goto l567
				l569:
					position, tokenIndex = position569, tokenIndex569
				}
			l570:
				{
					position571, tokenIndex571 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l571
					}
					goto l570
				l571:
					position, tokenIndex = position571, tokenIndex571
				}
				add(ruleTHROWS, position568)
			}
			memoize(85, position567, tokenIndex567, true)
			return true
		l567:
			memoize(85, position567, tokenIndex567, false)
			position, tokenIndex = position567, tokenIndex567
			return false
		},
		/* 86 EXCEPTION <- <(Skip ('e' 'x' 'c' 'e' 'p' 't' 'i' 'o' 'n') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{86, position}]; ok {
				return memoizedResult(memoized)
			}
			position572, tokenIndex572 := position, tokenIndex
			{
				position573 := position
				if !_rules[ruleSkip]() {
					goto l572
				}
				if buffer[position] != rune('e') {
					goto l572
				}
				position++
				if buffer[position] != rune('x') {
					goto l572
				}
				position++
				if buffer[position] != rune('c') {
					goto l572
				}
				position++
				if buffer[position] != rune('e') {
					goto l572
				}
				position++
				if buffer[position] != rune('p') {
					goto l572
				}
				position++
				if buffer[position] != rune('t') {
					goto l572
				}
				position++
				if buffer[position] != rune('i') {
					goto l572
				}
				position++
				if buffer[position] != rune('o') {
					goto l572
				}
				position++
				if buffer[position] != rune('n') {
					goto l572
				}
				position++
				{
					position574, tokenIndex574 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l574
					}
					goto l572
				l574:
					position, tokenIndex = position574, tokenIndex574
				}
			l575:
				{
					position576, tokenIndex576 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l576
					}
					goto l575
				l576:
					position, tokenIndex = position576, tokenIndex576
				}
				add(ruleEXCEPTION, position573)
			}
			memoize(86, position572, tokenIndex572, true)
			return true
		l572:
			memoize(86, position572, tokenIndex572, false)
			position, tokenIndex = position572, tokenIndex572
			return false
		},
		/* 87 SAFE <- <(Skip ('s' 'a' 'f' 'e') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{87, position}]; ok {
				return memoizedResult(memoized)
			}
			position577, tokenIndex577 := position, tokenIndex
			{
				position578 := position
				if !_rules[ruleSkip]() {
					goto l577
				}
				if buffer[position] != rune('s') {
					goto l577
				}
				position++
				if buffer[position] != rune('a') {
					goto l577
				}
				position++
				if buffer[position] != rune('f') {
					goto l577
				}
				position++
				if buffer[position] != rune('e') {
					goto l577
				}
				position++
				{
					position579, tokenIndex579 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l579
					}
					goto l577
				l579:
					position, tokenIndex = position579, tokenIndex579
				}
			l580:
				{
					position581, tokenIndex581 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l581
					}
					goto l580
				l581:
					position, tokenIndex = position581, tokenIndex581
				}
				add(ruleSAFE, position578)
			}
			memoize(87, position577, tokenIndex577, true)
			return true
		l577:
			memoize(87, position577, tokenIndex577, false)
			position, tokenIndex = position577, tokenIndex577
			return false
		},
		/* 88 UNSAFE <- <(Skip ('u' 'n' 's' 'a' 'f' 'e') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{88, position}]; ok {
				return memoizedResult(memoized)
			}
			position582, tokenIndex582 := position, tokenIndex
			{
				position583 := position
				if !_rules[ruleSkip]() {
					goto l582
				}
				if buffer[position] != rune('u') {
					goto l582
				}
				position++
				if buffer[position] != rune('n') {
					goto l582
				}
				position++
				if buffer[position] != rune('s') {
					goto l582
				}
				position++
				if buffer[position] != rune('a') {
					goto l582
				}
				position++
				if buffer[position] != rune('f') {
					goto l582
				}
				position++
				if buffer[position] != rune('e') {
					goto l582
				}
				position++
				{
					position584, tokenIndex584 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l584
					}
					goto l582
				l584:
					position, tokenIndex = position584, tokenIndex584
				}
			l585:
				{
					position586, tokenIndex586 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l586
					}
					goto l585
				l586:
					position, tokenIndex = position586, tokenIndex586
				}
				add(ruleUNSAFE, position583)
			}
			memoize(88, position582, tokenIndex582, true)
			return true
		l582:
			memoize(88, position582, tokenIndex582, false)
			position, tokenIndex = position582, tokenIndex582
			return false
		},
		/* 89 TRANSIENT <- <(Skip ('t' 'r' 'a' 'n' 's' 'i' 'e' 'n' 't') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{89, position}]; ok {
				return memoizedResult(memoized)
			}
			position587, tokenIndex587 := position, tokenIndex
			{
				position588 := position
				if !_rules[ruleSkip]() {
					goto l587
				}
				if buffer[position] != rune('t') {
					goto l587
				}
				position++
				if buffer[position] != rune('r') {
					goto l587
				}
				position++
				if buffer[position] != rune('a') {
					goto l587
				}
				position++
				if buffer[position] != rune('n') {
					goto l587
				}
				position++
				if buffer[position] != rune('s') {
					goto l587
				}
				position++
				if buffer[position] != rune('i') {
					goto l587
				}
				position++
				if buffer[position] != rune('e') {
					goto l587
				}
				position++
				if buffer[position] != rune('n') {
					goto l587
				}
				position++
				if buffer[position] != rune('t') {
					goto l587
				}
				position++
				{
					position589, tokenIndex589 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l589
					}
					goto l587
				l589:
					position, tokenIndex = position589, tokenIndex589
				}
			l590:
				{
					position591, tokenIndex591 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l591
					}
					goto l590
				l591:
					position, tokenIndex = position591, tokenIndex591
				}
				add(ruleTRANSIENT, position588)
			}
			memoize(89, position587, tokenIndex587, true)
			return true
		l587:
			memoize(89, position587, tokenIndex587, false)
			position, tokenIndex = position587, tokenIndex587
			return false
		},
		/* 90 PERMANENT <- <(Skip ('p' 'e' 'r' 'm' 'a' 'n' 'e' 'n' 't') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{90, position}]; ok {
				return memoizedResult(memoized)
			}
			position592, tokenIndex592 := position, tokenIndex
			{
				position593 := position
				if !_rules[ruleSkip]() {
					goto l592
				}
				if buffer[position] != rune('p') {
					goto l592
				}
				position++
				if buffer[position] != rune('e') {
					goto l592
				}
				position++
				if buffer[position] != rune('r') {
					goto l592
				}
				position++
				if buffer[position] != rune('m') {
					goto l592
				}
				position++
				if buffer[position] != rune('a') {
					goto l592
				}
				position++
				if buffer[position] != rune('n') {
					goto l592
				}
				position++
				if buffer[position] != rune('e') {
					goto l592
				}
				position++
				if buffer[position] != rune('n') {
					goto l592
				}
				position++
				if buffer[position] != rune('t') {
					goto l592
				}
				position++
				{
					position594, tokenIndex594 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l594
					}
					goto l592
				l594:
					position, tokenIndex = position594, tokenIndex594
				}
			l595:
				{
					position596, tokenIndex596 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l596
					}
					goto l595
				l596:
					position, tokenIndex = position596, tokenIndex596
				}
				add(rulePERMANENT, position593)
			}
			memoize(90, position592, tokenIndex592, true)
			return true
		l592:
			memoize(90, position592, tokenIndex592, false)
			position, tokenIndex = position592, tokenIndex592
			return false
		},
		/* 91 STATEFUL <- <(Skip ('s' 't' 'a' 't' 'e' 'f' 'u' 'l') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{91, position}]; ok {
				return memoizedResult(memoized)
			}
			position597, tokenIndex597 := position, tokenIndex
			{
				position598 := position
				if !_rules[ruleSkip]() {
					goto l597
				}
				if buffer[position] != rune('s') {
					goto l597
				}
				position++
				if buffer[position] != rune('t') {
					goto l597
				}
				position++
				if buffer[position] != rune('a') {
					goto l597
				}
				position++
				if buffer[position] != rune('t') {
					goto l597
				}
				position++
				if buffer[position] != rune('e') {
					goto l597
				}
				position++
				if buffer[position] != rune('f') {
					goto l597
				}
				position++
				if buffer[position] != rune('u') {
					goto l597
				}
				position++
				if buffer[position] != rune('l') {
					goto l597
				}
				position++
				{
					position599, tokenIndex599 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l599
					}
					goto l597
				l599:
					position, tokenIndex = position599, tokenIndex599
				}
			l600:
				{
					position601, tokenIndex601 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l601
					}
					goto l600
				l601:
					position, tokenIndex = position601, tokenIndex601
				}
				add(ruleSTATEFUL, position598)
			}
			memoize(91, position597, tokenIndex597, true)
			return true
		l597:
			memoize(91, position597, tokenIndex597, false)
			position, tokenIndex = position597, tokenIndex597
			return false
		},
		/* 92 SERVER <- <(Skip ('s' 'e' 'r' 'v' 'e' 'r') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{92, position}]; ok {
				return memoizedResult(memoized)
			}
			position602, tokenIndex602 := position, tokenIndex
			{
				position603 := position
				if !_rules[ruleSkip]() {
					goto l602
				}
				if buffer[position] != rune('s') {
					goto l602
				}
				position++
				if buffer[position] != rune('e') {
					goto l602
				}
				position++
				if buffer[position] != rune('r') {
					goto l602
				}
				position++
				if buffer[position] != rune('v') {
					goto l602
				}
				position++
				if buffer[position] != rune('e') {
					goto l602
				}
				position++
				if buffer[position] != rune('r') {
					goto l602
				}
				position++
				{
					position604, tokenIndex604 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l604
					}
					goto l602
				l604:
					position, tokenIndex = position604, tokenIndex604
				}
			l605:
				{
					position606, tokenIndex606 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l606
					}
					goto l605
				l606:
					position, tokenIndex = position606, tokenIndex606
				}
				add(ruleSERVER, position603)
			}
			memoize(92, position602, tokenIndex602, true)
			return true
		l602:
			memoize(92, position602, tokenIndex602, false)
			position, tokenIndex = position602, tokenIndex602
			return false
		},
		/* 93 CLIENT <- <(Skip ('c' 'l' 'i' 'e' 'n' 't') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{93, position}]; ok {
				return memoizedResult(memoized)
			}
			position607, tokenIndex607 := position, tokenIndex
			{
				position608 := position
				if !_rules[ruleSkip]() {
					goto l607
				}
				if buffer[position] != rune('c') {
					goto l607
				}
				position++
				if buffer[position] != rune('l') {
					goto l607
				}
				position++
				if buffer[position] != rune('i') {
					goto l607
				}
				position++
				if buffer[position] != rune('e') {
					goto l607
				}
				position++
				if buffer[position] != rune('n') {
					goto l607
				}
				position++
				if buffer[position] != rune('t') {
					goto l607
				}
				position++
				{
					position609, tokenIndex609 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l609
					}
					goto l607
				l609:
					position, tokenIndex = position609, tokenIndex609
				}
			l610:
				{
					position611, tokenIndex611 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l611
					}
					goto l610
				l611:
					position, tokenIndex = position611, tokenIndex611
				}
				add(ruleCLIENT, position608)
			}
			memoize(93, position607, tokenIndex607, true)
			return true
		l607:
			memoize(93, position607, tokenIndex607, false)
			position, tokenIndex = position607, tokenIndex607
			return false
		},
		/* 94 EXTENDS <- <(Skip ('e' 'x' 't' 'e' 'n' 'd' 's') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{94, position}]; ok {
				return memoizedResult(memoized)
			}
			position612, tokenIndex612 := position, tokenIndex
			{
				position613 := position
				if !_rules[ruleSkip]() {
					goto l612
				}
				if buffer[position] != rune('e') {
					goto l612
				}
				position++
				if buffer[position] != rune('x') {
					goto l612
				}
				position++
				if buffer[position] != rune('t') {
					goto l612
				}
				position++
				if buffer[position] != rune('e') {
					goto l612
				}
				position++
				if buffer[position] != rune('n') {
					goto l612
				}
				position++
				if buffer[position] != rune('d') {
					goto l612
				}
				position++
				if buffer[position] != rune('s') {
					goto l612
				}
				position++
				{
					position614, tokenIndex614 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l614
					}
					goto l612
				l614:
					position, tokenIndex = position614, tokenIndex614
				}
			l615:
				{
					position616, tokenIndex616 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l616
					}
					goto l615
				l616:
					position, tokenIndex = position616, tokenIndex616
				}
				add(ruleEXTENDS, position613)
			}
			memoize(94, position612, tokenIndex612, true)
			return true
		l612:
			memoize(94, position612, tokenIndex612, false)
			position, tokenIndex = position612, tokenIndex612
			return false
		},
		/* 95 SERVICE <- <(Skip ('s' 'e' 'r' 'v' 'i' 'c' 'e') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{95, position}]; ok {
				return memoizedResult(memoized)
			}
			position617, tokenIndex617 := position, tokenIndex
			{
				position618 := position
				if !_rules[ruleSkip]() {
					goto l617
				}
				if buffer[position] != rune('s') {
					goto l617
				}
				position++
				if buffer[position] != rune('e') {
					goto l617
				}
				position++
				if buffer[position] != rune('r') {
					goto l617
				}
				position++
				if buffer[position] != rune('v') {
					goto l617
				}
				position++
				if buffer[position] != rune('i') {
					goto l617
				}
				position++
				if buffer[position] != rune('c') {
					goto l617
				}
				position++
				if buffer[position] != rune('e') {
					goto l617
				}
				position++
				{
					position619, tokenIndex619 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l619
					}
					goto l617
				l619:
					position, tokenIndex = position619, tokenIndex619
				}
			l620:
				{
					position621, tokenIndex621 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l621
					}
					goto l620
				l621:
					position, tokenIndex = position621, tokenIndex621
				}
				add(ruleSERVICE, position618)
			}
			memoize(95, position617, tokenIndex617, true)
			return true
		l617:
			memoize(95, position617, tokenIndex617, false)
			position, tokenIndex = position617, tokenIndex617
			return false
		},
		/* 96 INTERACTION <- <(Skip ('i' 'n' 't' 'e' 'r' 'a' 'c' 't' 'i' 'o' 'n') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{96, position}]; ok {
				return memoizedResult(memoized)
			}
			position622, tokenIndex622 := position, tokenIndex
			{
				position623 := position
				if !_rules[ruleSkip]() {
					goto l622
				}
				if buffer[position] != rune('i') {
					goto l622
				}
				position++
				if buffer[position] != rune('n') {
					goto l622
				}
				position++
				if buffer[position] != rune('t') {
					goto l622
				}
				position++
				if buffer[position] != rune('e') {
					goto l622
				}
				position++
				if buffer[position] != rune('r') {
					goto l622
				}
				position++
				if buffer[position] != rune('a') {
					goto l622
				}
				position++
				if buffer[position] != rune('c') {
					goto l622
				}
				position++
				if buffer[position] != rune('t') {
					goto l622
				}
				position++
				if buffer[position] != rune('i') {
					goto l622
				}
				position++
				if buffer[position] != rune('o') {
					goto l622
				}
				position++
				if buffer[position] != rune('n') {
					goto l622
				}
				position++
				{
					position624, tokenIndex624 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l624
					}
					goto l622
				l624:
					position, tokenIndex = position624, tokenIndex624
				}
			l625:
				{
					position626, tokenIndex626 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l626
					}
					goto l625
				l626:
					position, tokenIndex = position626, tokenIndex626
				}
				add(ruleINTERACTION, position623)
			}
			memoize(96, position622, tokenIndex622, true)
			return true
		l622:
			memoize(96, position622, tokenIndex622, false)
			position, tokenIndex = position622, tokenIndex622
			return false
		},
		/* 97 STRUCT <- <(Skip ('s' 't' 'r' 'u' 'c' 't') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{97, position}]; ok {
				return memoizedResult(memoized)
			}
			position627, tokenIndex627 := position, tokenIndex
			{
				position628 := position
				if !_rules[ruleSkip]() {
					goto l627
				}
				if buffer[position] != rune('s') {
					goto l627
				}
				position++
				if buffer[position] != rune('t') {
					goto l627
				}
				position++
				if buffer[position] != rune('r') {
					goto l627
				}
				position++
				if buffer[position] != rune('u') {
					goto l627
				}
				position++
				if buffer[position] != rune('c') {
					goto l627
				}
				position++
				if buffer[position] != rune('t') {
					goto l627
				}
				position++
				{
					position629, tokenIndex629 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l629
					}
					goto l627
				l629:
					position, tokenIndex = position629, tokenIndex629
				}
			l630:
				{
					position631, tokenIndex631 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l631
					}
					goto l630
				l631:
					position, tokenIndex = position631, tokenIndex631
				}
				add(ruleSTRUCT, position628)
			}
			memoize(97, position627, tokenIndex627, true)
			return true
		l627:
			memoize(97, position627, tokenIndex627, false)
			position, tokenIndex = position627, tokenIndex627
			return false
		},
		/* 98 UNION <- <(Skip ('u' 'n' 'i' 'o' 'n') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{98, position}]; ok {
				return memoizedResult(memoized)
			}
			position632, tokenIndex632 := position, tokenIndex
			{
				position633 := position
				if !_rules[ruleSkip]() {
					goto l632
				}
				if buffer[position] != rune('u') {
					goto l632
				}
				position++
				if buffer[position] != rune('n') {
					goto l632
				}
				position++
				if buffer[position] != rune('i') {
					goto l632
				}
				position++
				if buffer[position] != rune('o') {
					goto l632
				}
				position++
				if buffer[position] != rune('n') {
					goto l632
				}
				position++
				{
					position634, tokenIndex634 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l634
					}
					goto l632
				l634:
					position, tokenIndex = position634, tokenIndex634
				}
			l635:
				{
					position636, tokenIndex636 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l636
					}
					goto l635
				l636:
					position, tokenIndex = position636, tokenIndex636
				}
				add(ruleUNION, position633)
			}
			memoize(98, position632, tokenIndex632, true)
			return true
		l632:
			memoize(98, position632, tokenIndex632, false)
			position, tokenIndex = position632, tokenIndex632
			return false
		},
		/* 99 ENUM <- <(Skip ('e' 'n' 'u' 'm') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{99, position}]; ok {
				return memoizedResult(memoized)
			}
			position637, tokenIndex637 := position, tokenIndex
			{
				position638 := position
				if !_rules[ruleSkip]() {
					goto l637
				}
				if buffer[position] != rune('e') {
					goto l637
				}
				position++
				if buffer[position] != rune('n') {
					goto l637
				}
				position++
				if buffer[position] != rune('u') {
					goto l637
				}
				position++
				if buffer[position] != rune('m') {
					goto l637
				}
				position++
				{
					position639, tokenIndex639 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l639
					}
					goto l637
				l639:
					position, tokenIndex = position639, tokenIndex639
				}
			l640:
				{
					position641, tokenIndex641 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l641
					}
					goto l640
				l641:
					position, tokenIndex = position641, tokenIndex641
				}
				add(ruleENUM, position638)
			}
			memoize(99, position637, tokenIndex637, true)
			return true
		l637:
			memoize(99, position637, tokenIndex637, false)
			position, tokenIndex = position637, tokenIndex637
			return false
		},
		/* 100 INCLUDE <- <(Skip ('i' 'n' 'c' 'l' 'u' 'd' 'e') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{100, position}]; ok {
				return memoizedResult(memoized)
			}
			position642, tokenIndex642 := position, tokenIndex
			{
				position643 := position
				if !_rules[ruleSkip]() {
					goto l642
				}
				if buffer[position] != rune('i') {
					goto l642
				}
				position++
				if buffer[position] != rune('n') {
					goto l642
				}
				position++
				if buffer[position] != rune('c') {
					goto l642
				}
				position++
				if buffer[position] != rune('l') {
					goto l642
				}
				position++
				if buffer[position] != rune('u') {
					goto l642
				}
				position++
				if buffer[position] != rune('d') {
					goto l642
				}
				position++
				if buffer[position] != rune('e') {
					goto l642
				}
				position++
				{
					position644, tokenIndex644 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l644
					}
					goto l642
				l644:
					position, tokenIndex = position644, tokenIndex644
				}
			l645:
				{
					position646, tokenIndex646 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l646
					}
					goto l645
				l646:
					position, tokenIndex = position646, tokenIndex646
				}
				add(ruleINCLUDE, position643)
			}
			memoize(100, position642, tokenIndex642, true)
			return true
		l642:
			memoize(100, position642, tokenIndex642, false)
			position, tokenIndex = position642, tokenIndex642
			return false
		},
		/* 101 CPPINCLUDE <- <(Skip ('c' 'p' 'p' '_' 'i' 'n' 'c' 'l' 'u' 'd' 'e') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{101, position}]; ok {
				return memoizedResult(memoized)
			}
			position647, tokenIndex647 := position, tokenIndex
			{
				position648 := position
				if !_rules[ruleSkip]() {
					goto l647
				}
				if buffer[position] != rune('c') {
					goto l647
				}
				position++
				if buffer[position] != rune('p') {
					goto l647
				}
				position++
				if buffer[position] != rune('p') {
					goto l647
				}
				position++
				if buffer[position] != rune('_') {
					goto l647
				}
				position++
				if buffer[position] != rune('i') {
					goto l647
				}
				position++
				if buffer[position] != rune('n') {
					goto l647
				}
				position++
				if buffer[position] != rune('c') {
					goto l647
				}
				position++
				if buffer[position] != rune('l') {
					goto l647
				}
				position++
				if buffer[position] != rune('u') {
					goto l647
				}
				position++
				if buffer[position] != rune('d') {
					goto l647
				}
				position++
				if buffer[position] != rune('e') {
					goto l647
				}
				position++
				{
					position649, tokenIndex649 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l649
					}
					goto l647
				l649:
					position, tokenIndex = position649, tokenIndex649
				}
			l650:
				{
					position651, tokenIndex651 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l651
					}
					goto l650
				l651:
					position, tokenIndex = position651, tokenIndex651
				}
				add(ruleCPPINCLUDE, position648)
			}
			memoize(101, position647, tokenIndex647, true)
			return true
		l647:
			memoize(101, position647, tokenIndex647, false)
			position, tokenIndex = position647, tokenIndex647
			return false
		},
		/* 102 HSINCLUDE <- <(Skip ('h' 's' '_' 'i' 'n' 'c' 'l' 'u' 'd' 'e') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{102, position}]; ok {
				return memoizedResult(memoized)
			}
			position652, tokenIndex652 := position, tokenIndex
			{
				position653 := position
				if !_rules[ruleSkip]() {
					goto l652
				}
				if buffer[position] != rune('h') {
					goto l652
				}
				position++
				if buffer[position] != rune('s') {
					goto l652
				}
				position++
				if buffer[position] != rune('_') {
					goto l652
				}
				position++
				if buffer[position] != rune('i') {
					goto l652
				}
				position++
				if buffer[position] != rune('n') {
					goto l652
				}
				position++
				if buffer[position] != rune('c') {
					goto l652
				}
				position++
				if buffer[position] != rune('l') {
					goto l652
				}
				position++
				if buffer[position] != rune('u') {
					goto l652
				}
				position++
				if buffer[position] != rune('d') {
					goto l652
				}
				position++
				if buffer[position] != rune('e') {
					goto l652
				}
				position++
				{
					position654, tokenIndex654 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l654
					}
					goto l652
				l654:
					position, tokenIndex = position654, tokenIndex654
				}
			l655:
				{
					position656, tokenIndex656 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l656
					}
					goto l655
				l656:
					position, tokenIndex = position656, tokenIndex656
				}
				add(ruleHSINCLUDE, position653)
			}
			memoize(102, position652, tokenIndex652, true)
			return true
		l652:
			memoize(102, position652, tokenIndex652, false)
			position, tokenIndex = position652, tokenIndex652
			return false
		},
		/* 103 NAMESPACE <- <(Skip ('n' 'a' 'm' 'e' 's' 'p' 'a' 'c' 'e') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{103, position}]; ok {
				return memoizedResult(memoized)
			}
			position657, tokenIndex657 := position, tokenIndex
			{
				position658 := position
				if !_rules[ruleSkip]() {
					goto l657
				}
				if buffer[position] != rune('n') {
					goto l657
				}
				position++
				if buffer[position] != rune('a') {
					goto l657
				}
				position++
				if buffer[position] != rune('m') {
					goto l657
				}
				position++
				if buffer[position] != rune('e') {
					goto l657
				}
				position++
				if buffer[position] != rune('s') {
					goto l657
				}
				position++
				if buffer[position] != rune('p') {
					goto l657
				}
				position++
				if buffer[position] != rune('a') {
					goto l657
				}
				position++
				if buffer[position] != rune('c') {
					goto l657
				}
				position++
				if buffer[position] != rune('e') {
					goto l657
				}
				position++
				{
					position659, tokenIndex659 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l659
					}
					goto l657
				l659:
					position, tokenIndex = position659, tokenIndex659
				}
			l660:
				{
					position661, tokenIndex661 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l661
					}
					goto l660
				l661:
					position, tokenIndex = position661, tokenIndex661
				}
				add(ruleNAMESPACE, position658)
			}
			memoize(103, position657, tokenIndex657, true)
			return true
		l657:
			memoize(103, position657, tokenIndex657, false)
			position, tokenIndex = position657, tokenIndex657
			return false
		},
		/* 104 PACKAGE <- <(Skip ('p' 'a' 'c' 'k' 'a' 'g' 'e') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{104, position}]; ok {
				return memoizedResult(memoized)
			}
			position662, tokenIndex662 := position, tokenIndex
			{
				position663 := position
				if !_rules[ruleSkip]() {
					goto l662
				}
				if buffer[position] != rune('p') {
					goto l662
				}
				position++
				if buffer[position] != rune('a') {
					goto l662
				}
				position++
				if buffer[position] != rune('c') {
					goto l662
				}
				position++
				if buffer[position] != rune('k') {
					goto l662
				}
				position++
				if buffer[position] != rune('a') {
					goto l662
				}
				position++
				if buffer[position] != rune('g') {
					goto l662
				}
				position++
				if buffer[position] != rune('e') {
					goto l662
				}
				position++
				{
					position664, tokenIndex664 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l664
					}
					goto l662
				l664:
					position, tokenIndex = position664, tokenIndex664
				}
			l665:
				{
					position666, tokenIndex666 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l666
					}
					goto l665
				l666:
					position, tokenIndex = position666, tokenIndex666
				}
				add(rulePACKAGE, position663)
			}
			memoize(104, position662, tokenIndex662, true)
			return true
		l662:
			memoize(104, position662, tokenIndex662, false)
			position, tokenIndex = position662, tokenIndex662
			return false
		},
		/* 105 CPPTYPE <- <(Skip ('c' 'p' 'p' '_' 't' 'y' 'p' 'e') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{105, position}]; ok {
				return memoizedResult(memoized)
			}
			position667, tokenIndex667 := position, tokenIndex
			{
				position668 := position
				if !_rules[ruleSkip]() {
					goto l667
				}
				if buffer[position] != rune('c') {
					goto l667
				}
				position++
				if buffer[position] != rune('p') {
					goto l667
				}
				position++
				if buffer[position] != rune('p') {
					goto l667
				}
				position++
				if buffer[position] != rune('_') {
					goto l667
				}
				position++
				if buffer[position] != rune('t') {
					goto l667
				}
				position++
				if buffer[position] != rune('y') {
					goto l667
				}
				position++
				if buffer[position] != rune('p') {
					goto l667
				}
				position++
				if buffer[position] != rune('e') {
					goto l667
				}
				position++
				{
					position669, tokenIndex669 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l669
					}
					goto l667
				l669:
					position, tokenIndex = position669, tokenIndex669
				}
			l670:
				{
					position671, tokenIndex671 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l671
					}
					goto l670
				l671:
					position, tokenIndex = position671, tokenIndex671
				}
				add(ruleCPPTYPE, position668)
			}
			memoize(105, position667, tokenIndex667, true)
			return true
		l667:
			memoize(105, position667, tokenIndex667, false)
			position, tokenIndex = position667, tokenIndex667
			return false
		},
		/* 106 PERFORMS <- <(Skip ('p' 'e' 'r' 'f' 'o' 'r' 'm' 's') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{106, position}]; ok {
				return memoizedResult(memoized)
			}
			position672, tokenIndex672 := position, tokenIndex
			{
				position673 := position
				if !_rules[ruleSkip]() {
					goto l672
				}
				if buffer[position] != rune('p') {
					goto l672
				}
				position++
				if buffer[position] != rune('e') {
					goto l672
				}
				position++
				if buffer[position] != rune('r') {
					goto l672
				}
				position++
				if buffer[position] != rune('f') {
					goto l672
				}
				position++
				if buffer[position] != rune('o') {
					goto l672
				}
				position++
				if buffer[position] != rune('r') {
					goto l672
				}
				position++
				if buffer[position] != rune('m') {
					goto l672
				}
				position++
				if buffer[position] != rune('s') {
					goto l672
				}
				position++
				{
					position674, tokenIndex674 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l674
					}
					goto l672
				l674:
					position, tokenIndex = position674, tokenIndex674
				}
			l675:
				{
					position676, tokenIndex676 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l676
					}
					goto l675
				l676:
					position, tokenIndex = position676, tokenIndex676
				}
				add(rulePERFORMS, position673)
			}
			memoize(106, position672, tokenIndex672, true)
			return true
		l672:
			memoize(106, position672, tokenIndex672, false)
			position, tokenIndex = position672, tokenIndex672
			return false
		},
		/* 107 SINK <- <(Skip ('s' 'i' 'n' 'k') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{107, position}]; ok {
				return memoizedResult(memoized)
			}
			position677, tokenIndex677 := position, tokenIndex
			{
				position678 := position
				if !_rules[ruleSkip]() {
					goto l677
				}
				if buffer[position] != rune('s') {
					goto l677
				}
				position++
				if buffer[position] != rune('i') {
					goto l677
				}
				position++
				if buffer[position] != rune('n') {
					goto l677
				}
				position++
				if buffer[position] != rune('k') {
					goto l677
				}
				position++
				{
					position679, tokenIndex679 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l679
					}
					goto l677
				l679:
					position, tokenIndex = position679, tokenIndex679
				}
			l680:
				{
					position681, tokenIndex681 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l681
					}
					goto l680
				l681:
					position, tokenIndex = position681, tokenIndex681
				}
				add(ruleSINK, position678)
			}
			memoize(107, position677, tokenIndex677, true)
			return true
		l677:
			memoize(107, position677, tokenIndex677, false)
			position, tokenIndex = position677, tokenIndex677
			return false
		},
		/* 108 STREAM <- <(Skip ('s' 't' 'r' 'e' 'a' 'm') !LetterOrDigit Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{108, position}]; ok {
				return memoizedResult(memoized)
			}
			position682, tokenIndex682 := position, tokenIndex
			{
				position683 := position
				if !_rules[ruleSkip]() {
					goto l682
				}
				if buffer[position] != rune('s') {
					goto l682
				}
				position++
				if buffer[position] != rune('t') {
					goto l682
				}
				position++
				if buffer[position] != rune('r') {
					goto l682
				}
				position++
				if buffer[position] != rune('e') {
					goto l682
				}
				position++
				if buffer[position] != rune('a') {
					goto l682
				}
				position++
				if buffer[position] != rune('m') {
					goto l682
				}
				position++
				{
					position684, tokenIndex684 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l684
					}
					goto l682
				l684:
					position, tokenIndex = position684, tokenIndex684
				}
			l685:
				{
					position686, tokenIndex686 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l686
					}
					goto l685
				l686:
					position, tokenIndex = position686, tokenIndex686
				}
				add(ruleSTREAM, position683)
			}
			memoize(108, position682, tokenIndex682, true)
			return true
		l682:
			memoize(108, position682, tokenIndex682, false)
			position, tokenIndex = position682, tokenIndex682
			return false
		},
		/* 109 LBRK <- <(Skip '[' Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{109, position}]; ok {
				return memoizedResult(memoized)
			}
			position687, tokenIndex687 := position, tokenIndex
			{
				position688 := position
				if !_rules[ruleSkip]() {
					goto l687
				}
				if buffer[position] != rune('[') {
					goto l687
				}
				position++
			l689:
				{
					position690, tokenIndex690 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l690
					}
					goto l689
				l690:
					position, tokenIndex = position690, tokenIndex690
				}
				add(ruleLBRK, position688)
			}
			memoize(109, position687, tokenIndex687, true)
			return true
		l687:
			memoize(109, position687, tokenIndex687, false)
			position, tokenIndex = position687, tokenIndex687
			return false
		},
		/* 110 RBRK <- <(Skip ']' Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{110, position}]; ok {
				return memoizedResult(memoized)
			}
			position691, tokenIndex691 := position, tokenIndex
			{
				position692 := position
				if !_rules[ruleSkip]() {
					goto l691
				}
				if buffer[position] != rune(']') {
					goto l691
				}
				position++
			l693:
				{
					position694, tokenIndex694 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l694
					}
					goto l693
				l694:
					position, tokenIndex = position694, tokenIndex694
				}
				add(ruleRBRK, position692)
			}
			memoize(110, position691, tokenIndex691, true)
			return true
		l691:
			memoize(110, position691, tokenIndex691, false)
			position, tokenIndex = position691, tokenIndex691
			return false
		},
		/* 111 LWING <- <(Skip '{' Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{111, position}]; ok {
				return memoizedResult(memoized)
			}
			position695, tokenIndex695 := position, tokenIndex
			{
				position696 := position
				if !_rules[ruleSkip]() {
					goto l695
				}
				if buffer[position] != rune('{') {
					goto l695
				}
				position++
			l697:
				{
					position698, tokenIndex698 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l698
					}
					goto l697
				l698:
					position, tokenIndex = position698, tokenIndex698
				}
				add(ruleLWING, position696)
			}
			memoize(111, position695, tokenIndex695, true)
			return true
		l695:
			memoize(111, position695, tokenIndex695, false)
			position, tokenIndex = position695, tokenIndex695
			return false
		},
		/* 112 RWING <- <(Skip '}' Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{112, position}]; ok {
				return memoizedResult(memoized)
			}
			position699, tokenIndex699 := position, tokenIndex
			{
				position700 := position
				if !_rules[ruleSkip]() {
					goto l699
				}
				if buffer[position] != rune('}') {
					goto l699
				}
				position++
			l701:
				{
					position702, tokenIndex702 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l702
					}
					goto l701
				l702:
					position, tokenIndex = position702, tokenIndex702
				}
				add(ruleRWING, position700)
			}
			memoize(112, position699, tokenIndex699, true)
			return true
		l699:
			memoize(112, position699, tokenIndex699, false)
			position, tokenIndex = position699, tokenIndex699
			return false
		},
		/* 113 EQUAL <- <(Skip '=' Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{113, position}]; ok {
				return memoizedResult(memoized)
			}
			position703, tokenIndex703 := position, tokenIndex
			{
				position704 := position
				if !_rules[ruleSkip]() {
					goto l703
				}
				if buffer[position] != rune('=') {
					goto l703
				}
				position++
			l705:
				{
					position706, tokenIndex706 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l706
					}
					goto l705
				l706:
					position, tokenIndex = position706, tokenIndex706
				}
				add(ruleEQUAL, position704)
			}
			memoize(113, position703, tokenIndex703, true)
			return true
		l703:
			memoize(113, position703, tokenIndex703, false)
			position, tokenIndex = position703, tokenIndex703
			return false
		},
		/* 114 LPOINT <- <(Skip '<' Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{114, position}]; ok {
				return memoizedResult(memoized)
			}
			position707, tokenIndex707 := position, tokenIndex
			{
				position708 := position
				if !_rules[ruleSkip]() {
					goto l707
				}
				if buffer[position] != rune('<') {
					goto l707
				}
				position++
			l709:
				{
					position710, tokenIndex710 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l710
					}
					goto l709
				l710:
					position, tokenIndex = position710, tokenIndex710
				}
				add(ruleLPOINT, position708)
			}
			memoize(114, position707, tokenIndex707, true)
			return true
		l707:
			memoize(114, position707, tokenIndex707, false)
			position, tokenIndex = position707, tokenIndex707
			return false
		},
		/* 115 RPOINT <- <(Skip '>' Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{115, position}]; ok {
				return memoizedResult(memoized)
			}
			position711, tokenIndex711 := position, tokenIndex
			{
				position712 := position
				if !_rules[ruleSkip]() {
					goto l711
				}
				if buffer[position] != rune('>') {
					goto l711
				}
				position++
			l713:
				{
					position714, tokenIndex714 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l714
					}
					goto l713
				l714:
					position, tokenIndex = position714, tokenIndex714
				}
				add(ruleRPOINT, position712)
			}
			memoize(115, position711, tokenIndex711, true)
			return true
		l711:
			memoize(115, position711, tokenIndex711, false)
			position, tokenIndex = position711, tokenIndex711
			return false
		},
		/* 116 COMMA <- <(Skip ',' Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{116, position}]; ok {
				return memoizedResult(memoized)
			}
			position715, tokenIndex715 := position, tokenIndex
			{
				position716 := position
				if !_rules[ruleSkip]() {
					goto l715
				}
				if buffer[position] != rune(',') {
					goto l715
				}
				position++
			l717:
				{
					position718, tokenIndex718 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l718
					}
					goto l717
				l718:
					position, tokenIndex = position718, tokenIndex718
				}
				add(ruleCOMMA, position716)
			}
			memoize(116, position715, tokenIndex715, true)
			return true
		l715:
			memoize(116, position715, tokenIndex715, false)
			position, tokenIndex = position715, tokenIndex715
			return false
		},
		/* 117 LPAR <- <(Skip '(' Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{117, position}]; ok {
				return memoizedResult(memoized)
			}
			position719, tokenIndex719 := position, tokenIndex
			{
				position720 := position
				if !_rules[ruleSkip]() {
					goto l719
				}
				if buffer[position] != rune('(') {
					goto l719
				}
				position++
			l721:
				{
					position722, tokenIndex722 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l722
					}
					goto l721
				l722:
					position, tokenIndex = position722, tokenIndex722
				}
				add(ruleLPAR, position720)
			}
			memoize(117, position719, tokenIndex719, true)
			return true
		l719:
			memoize(117, position719, tokenIndex719, false)
			position, tokenIndex = position719, tokenIndex719
			return false
		},
		/* 118 RPAR <- <(Skip ')' Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{118, position}]; ok {
				return memoizedResult(memoized)
			}
			position723, tokenIndex723 := position, tokenIndex
			{
				position724 := position
				if !_rules[ruleSkip]() {
					goto l723
				}
				if buffer[position] != rune(')') {
					goto l723
				}
				position++
			l725:
				{
					position726, tokenIndex726 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l726
					}
					goto l725
				l726:
					position, tokenIndex = position726, tokenIndex726
				}
				add(ruleRPAR, position724)
			}
			memoize(118, position723, tokenIndex723, true)
			return true
		l723:
			memoize(118, position723, tokenIndex723, false)
			position, tokenIndex = position723, tokenIndex723
			return false
		},
		/* 119 COLON <- <(Skip ':' Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{119, position}]; ok {
				return memoizedResult(memoized)
			}
			position727, tokenIndex727 := position, tokenIndex
			{
				position728 := position
				if !_rules[ruleSkip]() {
					goto l727
				}
				if buffer[position] != rune(':') {
					goto l727
				}
				position++
			l729:
				{
					position730, tokenIndex730 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l730
					}
					goto l729
				l730:
					position, tokenIndex = position730, tokenIndex730
				}
				add(ruleCOLON, position728)
			}
			memoize(119, position727, tokenIndex727, true)
			return true
		l727:
			memoize(119, position727, tokenIndex727, false)
			position, tokenIndex = position727, tokenIndex727
			return false
		},
		/* 120 AT <- <(Skip '@' Indent*)> */
		func() bool {
			if memoized, ok := memoization[memoKey{120, position}]; ok {
				return memoizedResult(memoized)
			}
			position731, tokenIndex731 := position, tokenIndex
			{
				position732 := position
				if !_rules[ruleSkip]() {
					goto l731
				}
				if buffer[position] != rune('@') {
					goto l731
				}
				position++
			l733:
				{
					position734, tokenIndex734 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l734
					}
					goto l733
				l734:
					position, tokenIndex = position734, tokenIndex734
				}
				add(ruleAT, position732)
			}
			memoize(120, position731, tokenIndex731, true)
			return true
		l731:
			memoize(120, position731, tokenIndex731, false)
			position, tokenIndex = position731, tokenIndex731
			return false
		},
		nil,
	}
	p.rules = _rules
	return nil
}
