// Code generated by peg. DO NOT EDIT.
package parser

// Code generated by peg ./thrift.peg DO NOT EDIT.

import (
	"fmt"
	"io"
	"os"
	"sort"
	"strconv"
	"strings"
)

const endSymbol rune = 1114112

/* The rule types inferred from the grammar are below. */
type pegRule uint8

const (
	ruleUnknown pegRule = iota
	ruleDocument
	ruleHeader
	ruleInclude
	ruleCppInclude
	ruleNamespace
	ruleNamespaceScope
	ruleDefinition
	ruleConst
	ruleTypedef
	ruleEnum
	ruleService
	ruleStruct
	ruleUnion
	ruleException
	ruleField
	ruleFieldId
	ruleFieldReq
	ruleFunction
	ruleFunctionType
	ruleThrows
	ruleFieldType
	ruleBaseType
	ruleContainerType
	ruleMapType
	ruleSetType
	ruleListType
	ruleCppType
	ruleConstValue
	ruleIntConstant
	ruleDoubleConstant
	ruleExponent
	ruleAnnotations
	ruleAnnotation
	ruleConstList
	ruleConstMap
	ruleEscapeLiteralChar
	ruleLiteral
	ruleIdentifier
	ruleListSeparator
	ruleLetter
	ruleLetterOrDigit
	ruleDigit
	ruleReservedComments
	ruleSkip
	ruleSkipLine
	ruleSpace
	ruleIndent
	ruleCarriageReturnLineFeed
	ruleComment
	ruleLongComment
	ruleLineComment
	ruleUnixComment
	ruleBOOL
	ruleBYTE
	ruleI8
	ruleI16
	ruleI32
	ruleI64
	ruleDOUBLE
	ruleSTRING
	ruleBINARY
	ruleCONST
	ruleONEWAY
	ruleTYPEDEF
	ruleMAP
	ruleSET
	ruleLIST
	ruleVOID
	ruleTHROWS
	ruleEXCEPTION
	ruleEXTENDS
	ruleSERVICE
	ruleSTRUCT
	ruleUNION
	ruleENUM
	ruleINCLUDE
	ruleCPPINCLUDE
	ruleNAMESPACE
	ruleCPPTYPE
	ruleLBRK
	ruleRBRK
	ruleLWING
	ruleRWING
	ruleEQUAL
	ruleLPOINT
	ruleRPOINT
	ruleCOMMA
	ruleLPAR
	ruleRPAR
	ruleCOLON
	rulePegText
)

var rul3s = [...]string{
	"Unknown",
	"Document",
	"Header",
	"Include",
	"CppInclude",
	"Namespace",
	"NamespaceScope",
	"Definition",
	"Const",
	"Typedef",
	"Enum",
	"Service",
	"Struct",
	"Union",
	"Exception",
	"Field",
	"FieldId",
	"FieldReq",
	"Function",
	"FunctionType",
	"Throws",
	"FieldType",
	"BaseType",
	"ContainerType",
	"MapType",
	"SetType",
	"ListType",
	"CppType",
	"ConstValue",
	"IntConstant",
	"DoubleConstant",
	"Exponent",
	"Annotations",
	"Annotation",
	"ConstList",
	"ConstMap",
	"EscapeLiteralChar",
	"Literal",
	"Identifier",
	"ListSeparator",
	"Letter",
	"LetterOrDigit",
	"Digit",
	"ReservedComments",
	"Skip",
	"SkipLine",
	"Space",
	"Indent",
	"CarriageReturnLineFeed",
	"Comment",
	"LongComment",
	"LineComment",
	"UnixComment",
	"BOOL",
	"BYTE",
	"I8",
	"I16",
	"I32",
	"I64",
	"DOUBLE",
	"STRING",
	"BINARY",
	"CONST",
	"ONEWAY",
	"TYPEDEF",
	"MAP",
	"SET",
	"LIST",
	"VOID",
	"THROWS",
	"EXCEPTION",
	"EXTENDS",
	"SERVICE",
	"STRUCT",
	"UNION",
	"ENUM",
	"INCLUDE",
	"CPPINCLUDE",
	"NAMESPACE",
	"CPPTYPE",
	"LBRK",
	"RBRK",
	"LWING",
	"RWING",
	"EQUAL",
	"LPOINT",
	"RPOINT",
	"COMMA",
	"LPAR",
	"RPAR",
	"COLON",
	"PegText",
}

type token32 struct {
	pegRule
	begin, end uint32
}

func (t *token32) String() string {
	return fmt.Sprintf("\x1B[34m%v\x1B[m %v %v", rul3s[t.pegRule], t.begin, t.end)
}

type node32 struct {
	token32
	up, next *node32
}

func (node *node32) print(w io.Writer, pretty bool, buffer string) {
	var print func(node *node32, depth int)
	print = func(node *node32, depth int) {
		for node != nil {
			for c := 0; c < depth; c++ {
				fmt.Fprintf(w, " ")
			}
			rule := rul3s[node.pegRule]
			quote := strconv.Quote(string(([]rune(buffer)[node.begin:node.end])))
			if !pretty {
				fmt.Fprintf(w, "%v %v\n", rule, quote)
			} else {
				fmt.Fprintf(w, "\x1B[36m%v\x1B[m %v\n", rule, quote)
			}
			if node.up != nil {
				print(node.up, depth+1)
			}
			node = node.next
		}
	}
	print(node, 0)
}

func (node *node32) Print(w io.Writer, buffer string) {
	node.print(w, false, buffer)
}

func (node *node32) PrettyPrint(w io.Writer, buffer string) {
	node.print(w, true, buffer)
}

type tokens32 struct {
	tree []token32
}

func (t *tokens32) Trim(length uint32) {
	t.tree = t.tree[:length]
}

func (t *tokens32) Print() {
	for _, token := range t.tree {
		fmt.Println(token.String())
	}
}

func (t *tokens32) AST() *node32 {
	type element struct {
		node *node32
		down *element
	}
	tokens := t.Tokens()
	var stack *element
	for _, token := range tokens {
		if token.begin == token.end {
			continue
		}
		node := &node32{token32: token}
		for stack != nil && stack.node.begin >= token.begin && stack.node.end <= token.end {
			stack.node.next = node.up
			node.up = stack.node
			stack = stack.down
		}
		stack = &element{node: node, down: stack}
	}
	if stack != nil {
		return stack.node
	}
	return nil
}

func (t *tokens32) PrintSyntaxTree(buffer string) {
	t.AST().Print(os.Stdout, buffer)
}

func (t *tokens32) WriteSyntaxTree(w io.Writer, buffer string) {
	t.AST().Print(w, buffer)
}

func (t *tokens32) PrettyPrintSyntaxTree(buffer string) {
	t.AST().PrettyPrint(os.Stdout, buffer)
}

func (t *tokens32) Add(rule pegRule, begin, end, index uint32) {
	tree, i := t.tree, int(index)
	if i >= len(tree) {
		t.tree = append(tree, token32{pegRule: rule, begin: begin, end: end})
		return
	}
	tree[i] = token32{pegRule: rule, begin: begin, end: end}
}

func (t *tokens32) Tokens() []token32 {
	return t.tree
}

type ThriftIDL struct {
	Buffer string
	buffer []rune
	rules  [92]func() bool
	parse  func(rule ...int) error
	reset  func()
	Pretty bool
	tokens32
}

func (p *ThriftIDL) Parse(rule ...int) error {
	return p.parse(rule...)
}

func (p *ThriftIDL) Reset() {
	p.reset()
}

type textPosition struct {
	line, symbol int
}

type textPositionMap map[int]textPosition

func translatePositions(buffer []rune, positions []int) textPositionMap {
	length, translations, j, line, symbol := len(positions), make(textPositionMap, len(positions)), 0, 1, 0
	sort.Ints(positions)

search:
	for i, c := range buffer {
		if c == '\n' {
			line, symbol = line+1, 0
		} else {
			symbol++
		}
		if i == positions[j] {
			translations[positions[j]] = textPosition{line, symbol}
			for j++; j < length; j++ {
				if i != positions[j] {
					continue search
				}
			}
			break search
		}
	}

	return translations
}

type parseError struct {
	p   *ThriftIDL
	max token32
}

func (e *parseError) Error() string {
	tokens, err := []token32{e.max}, "\n"
	positions, p := make([]int, 2*len(tokens)), 0
	for _, token := range tokens {
		positions[p], p = int(token.begin), p+1
		positions[p], p = int(token.end), p+1
	}
	translations := translatePositions(e.p.buffer, positions)
	format := "parse error near %v (line %v symbol %v - line %v symbol %v):\n%v\n"
	if e.p.Pretty {
		format = "parse error near \x1B[34m%v\x1B[m (line %v symbol %v - line %v symbol %v):\n%v\n"
	}
	for _, token := range tokens {
		begin, end := int(token.begin), int(token.end)
		err += fmt.Sprintf(format,
			rul3s[token.pegRule],
			translations[begin].line, translations[begin].symbol,
			translations[end].line, translations[end].symbol,
			strconv.Quote(string(e.p.buffer[begin:end])))
	}

	return err
}

func (p *ThriftIDL) PrintSyntaxTree() {
	if p.Pretty {
		p.tokens32.PrettyPrintSyntaxTree(p.Buffer)
	} else {
		p.tokens32.PrintSyntaxTree(p.Buffer)
	}
}

func (p *ThriftIDL) WriteSyntaxTree(w io.Writer) {
	p.tokens32.WriteSyntaxTree(w, p.Buffer)
}

func (p *ThriftIDL) SprintSyntaxTree() string {
	var bldr strings.Builder
	p.WriteSyntaxTree(&bldr)
	return bldr.String()
}

func Pretty(pretty bool) func(*ThriftIDL) error {
	return func(p *ThriftIDL) error {
		p.Pretty = pretty
		return nil
	}
}

func Size(size int) func(*ThriftIDL) error {
	return func(p *ThriftIDL) error {
		p.tokens32 = tokens32{tree: make([]token32, 0, size)}
		return nil
	}
}
func (p *ThriftIDL) Init(options ...func(*ThriftIDL) error) error {
	var (
		max                  token32
		position, tokenIndex uint32
		buffer               []rune
	)
	for _, option := range options {
		err := option(p)
		if err != nil {
			return err
		}
	}
	p.reset = func() {
		max = token32{}
		position, tokenIndex = 0, 0

		p.buffer = []rune(p.Buffer)
		if len(p.buffer) == 0 || p.buffer[len(p.buffer)-1] != endSymbol {
			p.buffer = append(p.buffer, endSymbol)
		}
		buffer = p.buffer
	}
	p.reset()

	_rules := p.rules
	tree := p.tokens32
	p.parse = func(rule ...int) error {
		r := 1
		if len(rule) > 0 {
			r = rule[0]
		}
		matches := p.rules[r]()
		p.tokens32 = tree
		if matches {
			p.Trim(tokenIndex)
			return nil
		}
		return &parseError{p, max}
	}

	add := func(rule pegRule, begin uint32) {
		tree.Add(rule, begin, position, tokenIndex)
		tokenIndex++
		if begin != position && position > max.end {
			max = token32{rule, begin, position}
		}
	}

	matchDot := func() bool {
		if buffer[position] != endSymbol {
			position++
			return true
		}
		return false
	}

	/*matchChar := func(c byte) bool {
		if buffer[position] == c {
			position++
			return true
		}
		return false
	}*/

	/*matchRange := func(lower byte, upper byte) bool {
		if c := buffer[position]; c >= lower && c <= upper {
			position++
			return true
		}
		return false
	}*/

	_rules = [...]func() bool{
		nil,
		/* 0 Document <- <(Header* Definition* Skip !.)> */
		func() bool {
			position0, tokenIndex0 := position, tokenIndex
			{
				position1 := position
			l2:
				{
					position3, tokenIndex3 := position, tokenIndex
					if !_rules[ruleHeader]() {
						goto l3
					}
					goto l2
				l3:
					position, tokenIndex = position3, tokenIndex3
				}
			l4:
				{
					position5, tokenIndex5 := position, tokenIndex
					if !_rules[ruleDefinition]() {
						goto l5
					}
					goto l4
				l5:
					position, tokenIndex = position5, tokenIndex5
				}
				if !_rules[ruleSkip]() {
					goto l0
				}
				{
					position6, tokenIndex6 := position, tokenIndex
					if !matchDot() {
						goto l6
					}
					goto l0
				l6:
					position, tokenIndex = position6, tokenIndex6
				}
				add(ruleDocument, position1)
			}
			return true
		l0:
			position, tokenIndex = position0, tokenIndex0
			return false
		},
		/* 1 Header <- <(Skip (Include / CppInclude / Namespace) SkipLine)> */
		func() bool {
			position7, tokenIndex7 := position, tokenIndex
			{
				position8 := position
				if !_rules[ruleSkip]() {
					goto l7
				}
				{
					position9, tokenIndex9 := position, tokenIndex
					if !_rules[ruleInclude]() {
						goto l10
					}
					goto l9
				l10:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleCppInclude]() {
						goto l11
					}
					goto l9
				l11:
					position, tokenIndex = position9, tokenIndex9
					if !_rules[ruleNamespace]() {
						goto l7
					}
				}
			l9:
				if !_rules[ruleSkipLine]() {
					goto l7
				}
				add(ruleHeader, position8)
			}
			return true
		l7:
			position, tokenIndex = position7, tokenIndex7
			return false
		},
		/* 2 Include <- <(INCLUDE Literal)> */
		func() bool {
			position12, tokenIndex12 := position, tokenIndex
			{
				position13 := position
				if !_rules[ruleINCLUDE]() {
					goto l12
				}
				if !_rules[ruleLiteral]() {
					goto l12
				}
				add(ruleInclude, position13)
			}
			return true
		l12:
			position, tokenIndex = position12, tokenIndex12
			return false
		},
		/* 3 CppInclude <- <(CPPINCLUDE Literal)> */
		func() bool {
			position14, tokenIndex14 := position, tokenIndex
			{
				position15 := position
				if !_rules[ruleCPPINCLUDE]() {
					goto l14
				}
				if !_rules[ruleLiteral]() {
					goto l14
				}
				add(ruleCppInclude, position15)
			}
			return true
		l14:
			position, tokenIndex = position14, tokenIndex14
			return false
		},
		/* 4 Namespace <- <(NAMESPACE NamespaceScope Identifier Annotations?)> */
		func() bool {
			position16, tokenIndex16 := position, tokenIndex
			{
				position17 := position
				if !_rules[ruleNAMESPACE]() {
					goto l16
				}
				if !_rules[ruleNamespaceScope]() {
					goto l16
				}
				if !_rules[ruleIdentifier]() {
					goto l16
				}
				{
					position18, tokenIndex18 := position, tokenIndex
					if !_rules[ruleAnnotations]() {
						goto l18
					}
					goto l19
				l18:
					position, tokenIndex = position18, tokenIndex18
				}
			l19:
				add(ruleNamespace, position17)
			}
			return true
		l16:
			position, tokenIndex = position16, tokenIndex16
			return false
		},
		/* 5 NamespaceScope <- <((Skip <'*'> Indent*) / Identifier)> */
		func() bool {
			position20, tokenIndex20 := position, tokenIndex
			{
				position21 := position
				{
					position22, tokenIndex22 := position, tokenIndex
					if !_rules[ruleSkip]() {
						goto l23
					}
					{
						position24 := position
						if buffer[position] != rune('*') {
							goto l23
						}
						position++
						add(rulePegText, position24)
					}
				l25:
					{
						position26, tokenIndex26 := position, tokenIndex
						if !_rules[ruleIndent]() {
							goto l26
						}
						goto l25
					l26:
						position, tokenIndex = position26, tokenIndex26
					}
					goto l22
				l23:
					position, tokenIndex = position22, tokenIndex22
					if !_rules[ruleIdentifier]() {
						goto l20
					}
				}
			l22:
				add(ruleNamespaceScope, position21)
			}
			return true
		l20:
			position, tokenIndex = position20, tokenIndex20
			return false
		},
		/* 6 Definition <- <(ReservedComments Skip (Const / Typedef / Enum / Service / Struct / Union / Exception) Annotations? SkipLine)> */
		func() bool {
			position27, tokenIndex27 := position, tokenIndex
			{
				position28 := position
				if !_rules[ruleReservedComments]() {
					goto l27
				}
				if !_rules[ruleSkip]() {
					goto l27
				}
				{
					position29, tokenIndex29 := position, tokenIndex
					if !_rules[ruleConst]() {
						goto l30
					}
					goto l29
				l30:
					position, tokenIndex = position29, tokenIndex29
					if !_rules[ruleTypedef]() {
						goto l31
					}
					goto l29
				l31:
					position, tokenIndex = position29, tokenIndex29
					if !_rules[ruleEnum]() {
						goto l32
					}
					goto l29
				l32:
					position, tokenIndex = position29, tokenIndex29
					if !_rules[ruleService]() {
						goto l33
					}
					goto l29
				l33:
					position, tokenIndex = position29, tokenIndex29
					if !_rules[ruleStruct]() {
						goto l34
					}
					goto l29
				l34:
					position, tokenIndex = position29, tokenIndex29
					if !_rules[ruleUnion]() {
						goto l35
					}
					goto l29
				l35:
					position, tokenIndex = position29, tokenIndex29
					if !_rules[ruleException]() {
						goto l27
					}
				}
			l29:
				{
					position36, tokenIndex36 := position, tokenIndex
					if !_rules[ruleAnnotations]() {
						goto l36
					}
					goto l37
				l36:
					position, tokenIndex = position36, tokenIndex36
				}
			l37:
				if !_rules[ruleSkipLine]() {
					goto l27
				}
				add(ruleDefinition, position28)
			}
			return true
		l27:
			position, tokenIndex = position27, tokenIndex27
			return false
		},
		/* 7 Const <- <(CONST FieldType Identifier EQUAL ConstValue ListSeparator?)> */
		func() bool {
			position38, tokenIndex38 := position, tokenIndex
			{
				position39 := position
				if !_rules[ruleCONST]() {
					goto l38
				}
				if !_rules[ruleFieldType]() {
					goto l38
				}
				if !_rules[ruleIdentifier]() {
					goto l38
				}
				if !_rules[ruleEQUAL]() {
					goto l38
				}
				if !_rules[ruleConstValue]() {
					goto l38
				}
				{
					position40, tokenIndex40 := position, tokenIndex
					if !_rules[ruleListSeparator]() {
						goto l40
					}
					goto l41
				l40:
					position, tokenIndex = position40, tokenIndex40
				}
			l41:
				add(ruleConst, position39)
			}
			return true
		l38:
			position, tokenIndex = position38, tokenIndex38
			return false
		},
		/* 8 Typedef <- <(TYPEDEF FieldType Identifier)> */
		func() bool {
			position42, tokenIndex42 := position, tokenIndex
			{
				position43 := position
				if !_rules[ruleTYPEDEF]() {
					goto l42
				}
				if !_rules[ruleFieldType]() {
					goto l42
				}
				if !_rules[ruleIdentifier]() {
					goto l42
				}
				add(ruleTypedef, position43)
			}
			return true
		l42:
			position, tokenIndex = position42, tokenIndex42
			return false
		},
		/* 9 Enum <- <(ENUM Identifier LWING (ReservedComments Identifier (EQUAL IntConstant)? Annotations? ListSeparator? SkipLine)* RWING)> */
		func() bool {
			position44, tokenIndex44 := position, tokenIndex
			{
				position45 := position
				if !_rules[ruleENUM]() {
					goto l44
				}
				if !_rules[ruleIdentifier]() {
					goto l44
				}
				if !_rules[ruleLWING]() {
					goto l44
				}
			l46:
				{
					position47, tokenIndex47 := position, tokenIndex
					if !_rules[ruleReservedComments]() {
						goto l47
					}
					if !_rules[ruleIdentifier]() {
						goto l47
					}
					{
						position48, tokenIndex48 := position, tokenIndex
						if !_rules[ruleEQUAL]() {
							goto l48
						}
						if !_rules[ruleIntConstant]() {
							goto l48
						}
						goto l49
					l48:
						position, tokenIndex = position48, tokenIndex48
					}
				l49:
					{
						position50, tokenIndex50 := position, tokenIndex
						if !_rules[ruleAnnotations]() {
							goto l50
						}
						goto l51
					l50:
						position, tokenIndex = position50, tokenIndex50
					}
				l51:
					{
						position52, tokenIndex52 := position, tokenIndex
						if !_rules[ruleListSeparator]() {
							goto l52
						}
						goto l53
					l52:
						position, tokenIndex = position52, tokenIndex52
					}
				l53:
					if !_rules[ruleSkipLine]() {
						goto l47
					}
					goto l46
				l47:
					position, tokenIndex = position47, tokenIndex47
				}
				if !_rules[ruleRWING]() {
					goto l44
				}
				add(ruleEnum, position45)
			}
			return true
		l44:
			position, tokenIndex = position44, tokenIndex44
			return false
		},
		/* 10 Service <- <(SERVICE Identifier (EXTENDS Identifier)? LWING Function* RWING)> */
		func() bool {
			position54, tokenIndex54 := position, tokenIndex
			{
				position55 := position
				if !_rules[ruleSERVICE]() {
					goto l54
				}
				if !_rules[ruleIdentifier]() {
					goto l54
				}
				{
					position56, tokenIndex56 := position, tokenIndex
					if !_rules[ruleEXTENDS]() {
						goto l56
					}
					if !_rules[ruleIdentifier]() {
						goto l56
					}
					goto l57
				l56:
					position, tokenIndex = position56, tokenIndex56
				}
			l57:
				if !_rules[ruleLWING]() {
					goto l54
				}
			l58:
				{
					position59, tokenIndex59 := position, tokenIndex
					if !_rules[ruleFunction]() {
						goto l59
					}
					goto l58
				l59:
					position, tokenIndex = position59, tokenIndex59
				}
				if !_rules[ruleRWING]() {
					goto l54
				}
				add(ruleService, position55)
			}
			return true
		l54:
			position, tokenIndex = position54, tokenIndex54
			return false
		},
		/* 11 Struct <- <(STRUCT Identifier LWING Field* RWING)> */
		func() bool {
			position60, tokenIndex60 := position, tokenIndex
			{
				position61 := position
				if !_rules[ruleSTRUCT]() {
					goto l60
				}
				if !_rules[ruleIdentifier]() {
					goto l60
				}
				if !_rules[ruleLWING]() {
					goto l60
				}
			l62:
				{
					position63, tokenIndex63 := position, tokenIndex
					if !_rules[ruleField]() {
						goto l63
					}
					goto l62
				l63:
					position, tokenIndex = position63, tokenIndex63
				}
				if !_rules[ruleRWING]() {
					goto l60
				}
				add(ruleStruct, position61)
			}
			return true
		l60:
			position, tokenIndex = position60, tokenIndex60
			return false
		},
		/* 12 Union <- <(UNION Identifier LWING Field* RWING)> */
		func() bool {
			position64, tokenIndex64 := position, tokenIndex
			{
				position65 := position
				if !_rules[ruleUNION]() {
					goto l64
				}
				if !_rules[ruleIdentifier]() {
					goto l64
				}
				if !_rules[ruleLWING]() {
					goto l64
				}
			l66:
				{
					position67, tokenIndex67 := position, tokenIndex
					if !_rules[ruleField]() {
						goto l67
					}
					goto l66
				l67:
					position, tokenIndex = position67, tokenIndex67
				}
				if !_rules[ruleRWING]() {
					goto l64
				}
				add(ruleUnion, position65)
			}
			return true
		l64:
			position, tokenIndex = position64, tokenIndex64
			return false
		},
		/* 13 Exception <- <(EXCEPTION Identifier LWING Field* RWING)> */
		func() bool {
			position68, tokenIndex68 := position, tokenIndex
			{
				position69 := position
				if !_rules[ruleEXCEPTION]() {
					goto l68
				}
				if !_rules[ruleIdentifier]() {
					goto l68
				}
				if !_rules[ruleLWING]() {
					goto l68
				}
			l70:
				{
					position71, tokenIndex71 := position, tokenIndex
					if !_rules[ruleField]() {
						goto l71
					}
					goto l70
				l71:
					position, tokenIndex = position71, tokenIndex71
				}
				if !_rules[ruleRWING]() {
					goto l68
				}
				add(ruleException, position69)
			}
			return true
		l68:
			position, tokenIndex = position68, tokenIndex68
			return false
		},
		/* 14 Field <- <(ReservedComments Skip FieldId? FieldReq? FieldType Identifier (EQUAL ConstValue)? Annotations? ListSeparator? SkipLine)> */
		func() bool {
			position72, tokenIndex72 := position, tokenIndex
			{
				position73 := position
				if !_rules[ruleReservedComments]() {
					goto l72
				}
				if !_rules[ruleSkip]() {
					goto l72
				}
				{
					position74, tokenIndex74 := position, tokenIndex
					if !_rules[ruleFieldId]() {
						goto l74
					}
					goto l75
				l74:
					position, tokenIndex = position74, tokenIndex74
				}
			l75:
				{
					position76, tokenIndex76 := position, tokenIndex
					if !_rules[ruleFieldReq]() {
						goto l76
					}
					goto l77
				l76:
					position, tokenIndex = position76, tokenIndex76
				}
			l77:
				if !_rules[ruleFieldType]() {
					goto l72
				}
				if !_rules[ruleIdentifier]() {
					goto l72
				}
				{
					position78, tokenIndex78 := position, tokenIndex
					if !_rules[ruleEQUAL]() {
						goto l78
					}
					if !_rules[ruleConstValue]() {
						goto l78
					}
					goto l79
				l78:
					position, tokenIndex = position78, tokenIndex78
				}
			l79:
				{
					position80, tokenIndex80 := position, tokenIndex
					if !_rules[ruleAnnotations]() {
						goto l80
					}
					goto l81
				l80:
					position, tokenIndex = position80, tokenIndex80
				}
			l81:
				{
					position82, tokenIndex82 := position, tokenIndex
					if !_rules[ruleListSeparator]() {
						goto l82
					}
					goto l83
				l82:
					position, tokenIndex = position82, tokenIndex82
				}
			l83:
				if !_rules[ruleSkipLine]() {
					goto l72
				}
				add(ruleField, position73)
			}
			return true
		l72:
			position, tokenIndex = position72, tokenIndex72
			return false
		},
		/* 15 FieldId <- <(Skip IntConstant COLON Indent*)> */
		func() bool {
			position84, tokenIndex84 := position, tokenIndex
			{
				position85 := position
				if !_rules[ruleSkip]() {
					goto l84
				}
				if !_rules[ruleIntConstant]() {
					goto l84
				}
				if !_rules[ruleCOLON]() {
					goto l84
				}
			l86:
				{
					position87, tokenIndex87 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l87
					}
					goto l86
				l87:
					position, tokenIndex = position87, tokenIndex87
				}
				add(ruleFieldId, position85)
			}
			return true
		l84:
			position, tokenIndex = position84, tokenIndex84
			return false
		},
		/* 16 FieldReq <- <(Skip <(('r' 'e' 'q' 'u' 'i' 'r' 'e' 'd') / ('o' 'p' 't' 'i' 'o' 'n' 'a' 'l'))> Indent*)> */
		func() bool {
			position88, tokenIndex88 := position, tokenIndex
			{
				position89 := position
				if !_rules[ruleSkip]() {
					goto l88
				}
				{
					position90 := position
					{
						position91, tokenIndex91 := position, tokenIndex
						if buffer[position] != rune('r') {
							goto l92
						}
						position++
						if buffer[position] != rune('e') {
							goto l92
						}
						position++
						if buffer[position] != rune('q') {
							goto l92
						}
						position++
						if buffer[position] != rune('u') {
							goto l92
						}
						position++
						if buffer[position] != rune('i') {
							goto l92
						}
						position++
						if buffer[position] != rune('r') {
							goto l92
						}
						position++
						if buffer[position] != rune('e') {
							goto l92
						}
						position++
						if buffer[position] != rune('d') {
							goto l92
						}
						position++
						goto l91
					l92:
						position, tokenIndex = position91, tokenIndex91
						if buffer[position] != rune('o') {
							goto l88
						}
						position++
						if buffer[position] != rune('p') {
							goto l88
						}
						position++
						if buffer[position] != rune('t') {
							goto l88
						}
						position++
						if buffer[position] != rune('i') {
							goto l88
						}
						position++
						if buffer[position] != rune('o') {
							goto l88
						}
						position++
						if buffer[position] != rune('n') {
							goto l88
						}
						position++
						if buffer[position] != rune('a') {
							goto l88
						}
						position++
						if buffer[position] != rune('l') {
							goto l88
						}
						position++
					}
				l91:
					add(rulePegText, position90)
				}
			l93:
				{
					position94, tokenIndex94 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l94
					}
					goto l93
				l94:
					position, tokenIndex = position94, tokenIndex94
				}
				add(ruleFieldReq, position89)
			}
			return true
		l88:
			position, tokenIndex = position88, tokenIndex88
			return false
		},
		/* 17 Function <- <(ReservedComments Skip ONEWAY? FunctionType Identifier LPAR Field* RPAR Throws? Annotations? ListSeparator? SkipLine)> */
		func() bool {
			position95, tokenIndex95 := position, tokenIndex
			{
				position96 := position
				if !_rules[ruleReservedComments]() {
					goto l95
				}
				if !_rules[ruleSkip]() {
					goto l95
				}
				{
					position97, tokenIndex97 := position, tokenIndex
					if !_rules[ruleONEWAY]() {
						goto l97
					}
					goto l98
				l97:
					position, tokenIndex = position97, tokenIndex97
				}
			l98:
				if !_rules[ruleFunctionType]() {
					goto l95
				}
				if !_rules[ruleIdentifier]() {
					goto l95
				}
				if !_rules[ruleLPAR]() {
					goto l95
				}
			l99:
				{
					position100, tokenIndex100 := position, tokenIndex
					if !_rules[ruleField]() {
						goto l100
					}
					goto l99
				l100:
					position, tokenIndex = position100, tokenIndex100
				}
				if !_rules[ruleRPAR]() {
					goto l95
				}
				{
					position101, tokenIndex101 := position, tokenIndex
					if !_rules[ruleThrows]() {
						goto l101
					}
					goto l102
				l101:
					position, tokenIndex = position101, tokenIndex101
				}
			l102:
				{
					position103, tokenIndex103 := position, tokenIndex
					if !_rules[ruleAnnotations]() {
						goto l103
					}
					goto l104
				l103:
					position, tokenIndex = position103, tokenIndex103
				}
			l104:
				{
					position105, tokenIndex105 := position, tokenIndex
					if !_rules[ruleListSeparator]() {
						goto l105
					}
					goto l106
				l105:
					position, tokenIndex = position105, tokenIndex105
				}
			l106:
				if !_rules[ruleSkipLine]() {
					goto l95
				}
				add(ruleFunction, position96)
			}
			return true
		l95:
			position, tokenIndex = position95, tokenIndex95
			return false
		},
		/* 18 FunctionType <- <(VOID / FieldType)> */
		func() bool {
			position107, tokenIndex107 := position, tokenIndex
			{
				position108 := position
				{
					position109, tokenIndex109 := position, tokenIndex
					if !_rules[ruleVOID]() {
						goto l110
					}
					goto l109
				l110:
					position, tokenIndex = position109, tokenIndex109
					if !_rules[ruleFieldType]() {
						goto l107
					}
				}
			l109:
				add(ruleFunctionType, position108)
			}
			return true
		l107:
			position, tokenIndex = position107, tokenIndex107
			return false
		},
		/* 19 Throws <- <(THROWS LPAR Field* RPAR)> */
		func() bool {
			position111, tokenIndex111 := position, tokenIndex
			{
				position112 := position
				if !_rules[ruleTHROWS]() {
					goto l111
				}
				if !_rules[ruleLPAR]() {
					goto l111
				}
			l113:
				{
					position114, tokenIndex114 := position, tokenIndex
					if !_rules[ruleField]() {
						goto l114
					}
					goto l113
				l114:
					position, tokenIndex = position114, tokenIndex114
				}
				if !_rules[ruleRPAR]() {
					goto l111
				}
				add(ruleThrows, position112)
			}
			return true
		l111:
			position, tokenIndex = position111, tokenIndex111
			return false
		},
		/* 20 FieldType <- <((ContainerType / BaseType / Identifier) Annotations?)> */
		func() bool {
			position115, tokenIndex115 := position, tokenIndex
			{
				position116 := position
				{
					position117, tokenIndex117 := position, tokenIndex
					if !_rules[ruleContainerType]() {
						goto l118
					}
					goto l117
				l118:
					position, tokenIndex = position117, tokenIndex117
					if !_rules[ruleBaseType]() {
						goto l119
					}
					goto l117
				l119:
					position, tokenIndex = position117, tokenIndex117
					if !_rules[ruleIdentifier]() {
						goto l115
					}
				}
			l117:
				{
					position120, tokenIndex120 := position, tokenIndex
					if !_rules[ruleAnnotations]() {
						goto l120
					}
					goto l121
				l120:
					position, tokenIndex = position120, tokenIndex120
				}
			l121:
				add(ruleFieldType, position116)
			}
			return true
		l115:
			position, tokenIndex = position115, tokenIndex115
			return false
		},
		/* 21 BaseType <- <(BOOL / BYTE / I8 / I16 / I32 / I64 / DOUBLE / STRING / BINARY)> */
		func() bool {
			position122, tokenIndex122 := position, tokenIndex
			{
				position123 := position
				{
					position124, tokenIndex124 := position, tokenIndex
					if !_rules[ruleBOOL]() {
						goto l125
					}
					goto l124
				l125:
					position, tokenIndex = position124, tokenIndex124
					if !_rules[ruleBYTE]() {
						goto l126
					}
					goto l124
				l126:
					position, tokenIndex = position124, tokenIndex124
					if !_rules[ruleI8]() {
						goto l127
					}
					goto l124
				l127:
					position, tokenIndex = position124, tokenIndex124
					if !_rules[ruleI16]() {
						goto l128
					}
					goto l124
				l128:
					position, tokenIndex = position124, tokenIndex124
					if !_rules[ruleI32]() {
						goto l129
					}
					goto l124
				l129:
					position, tokenIndex = position124, tokenIndex124
					if !_rules[ruleI64]() {
						goto l130
					}
					goto l124
				l130:
					position, tokenIndex = position124, tokenIndex124
					if !_rules[ruleDOUBLE]() {
						goto l131
					}
					goto l124
				l131:
					position, tokenIndex = position124, tokenIndex124
					if !_rules[ruleSTRING]() {
						goto l132
					}
					goto l124
				l132:
					position, tokenIndex = position124, tokenIndex124
					if !_rules[ruleBINARY]() {
						goto l122
					}
				}
			l124:
				add(ruleBaseType, position123)
			}
			return true
		l122:
			position, tokenIndex = position122, tokenIndex122
			return false
		},
		/* 22 ContainerType <- <(MapType / SetType / ListType)> */
		func() bool {
			position133, tokenIndex133 := position, tokenIndex
			{
				position134 := position
				{
					position135, tokenIndex135 := position, tokenIndex
					if !_rules[ruleMapType]() {
						goto l136
					}
					goto l135
				l136:
					position, tokenIndex = position135, tokenIndex135
					if !_rules[ruleSetType]() {
						goto l137
					}
					goto l135
				l137:
					position, tokenIndex = position135, tokenIndex135
					if !_rules[ruleListType]() {
						goto l133
					}
				}
			l135:
				add(ruleContainerType, position134)
			}
			return true
		l133:
			position, tokenIndex = position133, tokenIndex133
			return false
		},
		/* 23 MapType <- <(MAP CppType? LPOINT FieldType COMMA FieldType RPOINT)> */
		func() bool {
			position138, tokenIndex138 := position, tokenIndex
			{
				position139 := position
				if !_rules[ruleMAP]() {
					goto l138
				}
				{
					position140, tokenIndex140 := position, tokenIndex
					if !_rules[ruleCppType]() {
						goto l140
					}
					goto l141
				l140:
					position, tokenIndex = position140, tokenIndex140
				}
			l141:
				if !_rules[ruleLPOINT]() {
					goto l138
				}
				if !_rules[ruleFieldType]() {
					goto l138
				}
				if !_rules[ruleCOMMA]() {
					goto l138
				}
				if !_rules[ruleFieldType]() {
					goto l138
				}
				if !_rules[ruleRPOINT]() {
					goto l138
				}
				add(ruleMapType, position139)
			}
			return true
		l138:
			position, tokenIndex = position138, tokenIndex138
			return false
		},
		/* 24 SetType <- <(SET CppType? LPOINT FieldType RPOINT)> */
		func() bool {
			position142, tokenIndex142 := position, tokenIndex
			{
				position143 := position
				if !_rules[ruleSET]() {
					goto l142
				}
				{
					position144, tokenIndex144 := position, tokenIndex
					if !_rules[ruleCppType]() {
						goto l144
					}
					goto l145
				l144:
					position, tokenIndex = position144, tokenIndex144
				}
			l145:
				if !_rules[ruleLPOINT]() {
					goto l142
				}
				if !_rules[ruleFieldType]() {
					goto l142
				}
				if !_rules[ruleRPOINT]() {
					goto l142
				}
				add(ruleSetType, position143)
			}
			return true
		l142:
			position, tokenIndex = position142, tokenIndex142
			return false
		},
		/* 25 ListType <- <(LIST LPOINT FieldType RPOINT CppType?)> */
		func() bool {
			position146, tokenIndex146 := position, tokenIndex
			{
				position147 := position
				if !_rules[ruleLIST]() {
					goto l146
				}
				if !_rules[ruleLPOINT]() {
					goto l146
				}
				if !_rules[ruleFieldType]() {
					goto l146
				}
				if !_rules[ruleRPOINT]() {
					goto l146
				}
				{
					position148, tokenIndex148 := position, tokenIndex
					if !_rules[ruleCppType]() {
						goto l148
					}
					goto l149
				l148:
					position, tokenIndex = position148, tokenIndex148
				}
			l149:
				add(ruleListType, position147)
			}
			return true
		l146:
			position, tokenIndex = position146, tokenIndex146
			return false
		},
		/* 26 CppType <- <(CPPTYPE Literal)> */
		func() bool {
			position150, tokenIndex150 := position, tokenIndex
			{
				position151 := position
				if !_rules[ruleCPPTYPE]() {
					goto l150
				}
				if !_rules[ruleLiteral]() {
					goto l150
				}
				add(ruleCppType, position151)
			}
			return true
		l150:
			position, tokenIndex = position150, tokenIndex150
			return false
		},
		/* 27 ConstValue <- <(DoubleConstant / IntConstant / Literal / Identifier / ConstList / ConstMap)> */
		func() bool {
			position152, tokenIndex152 := position, tokenIndex
			{
				position153 := position
				{
					position154, tokenIndex154 := position, tokenIndex
					if !_rules[ruleDoubleConstant]() {
						goto l155
					}
					goto l154
				l155:
					position, tokenIndex = position154, tokenIndex154
					if !_rules[ruleIntConstant]() {
						goto l156
					}
					goto l154
				l156:
					position, tokenIndex = position154, tokenIndex154
					if !_rules[ruleLiteral]() {
						goto l157
					}
					goto l154
				l157:
					position, tokenIndex = position154, tokenIndex154
					if !_rules[ruleIdentifier]() {
						goto l158
					}
					goto l154
				l158:
					position, tokenIndex = position154, tokenIndex154
					if !_rules[ruleConstList]() {
						goto l159
					}
					goto l154
				l159:
					position, tokenIndex = position154, tokenIndex154
					if !_rules[ruleConstMap]() {
						goto l152
					}
				}
			l154:
				add(ruleConstValue, position153)
			}
			return true
		l152:
			position, tokenIndex = position152, tokenIndex152
			return false
		},
		/* 28 IntConstant <- <(Skip <(('0' 'x' ([0-9] / [A-Z] / [a-z])+) / ('0' 'o' Digit+) / (('+' / '-')? Digit+))> Indent*)> */
		func() bool {
			position160, tokenIndex160 := position, tokenIndex
			{
				position161 := position
				if !_rules[ruleSkip]() {
					goto l160
				}
				{
					position162 := position
					{
						position163, tokenIndex163 := position, tokenIndex
						if buffer[position] != rune('0') {
							goto l164
						}
						position++
						if buffer[position] != rune('x') {
							goto l164
						}
						position++
						{
							position167, tokenIndex167 := position, tokenIndex
							if c := buffer[position]; c < rune('0') || c > rune('9') {
								goto l168
							}
							position++
							goto l167
						l168:
							position, tokenIndex = position167, tokenIndex167
							if c := buffer[position]; c < rune('A') || c > rune('Z') {
								goto l169
							}
							position++
							goto l167
						l169:
							position, tokenIndex = position167, tokenIndex167
							if c := buffer[position]; c < rune('a') || c > rune('z') {
								goto l164
							}
							position++
						}
					l167:
					l165:
						{
							position166, tokenIndex166 := position, tokenIndex
							{
								position170, tokenIndex170 := position, tokenIndex
								if c := buffer[position]; c < rune('0') || c > rune('9') {
									goto l171
								}
								position++
								goto l170
							l171:
								position, tokenIndex = position170, tokenIndex170
								if c := buffer[position]; c < rune('A') || c > rune('Z') {
									goto l172
								}
								position++
								goto l170
							l172:
								position, tokenIndex = position170, tokenIndex170
								if c := buffer[position]; c < rune('a') || c > rune('z') {
									goto l166
								}
								position++
							}
						l170:
							goto l165
						l166:
							position, tokenIndex = position166, tokenIndex166
						}
						goto l163
					l164:
						position, tokenIndex = position163, tokenIndex163
						if buffer[position] != rune('0') {
							goto l173
						}
						position++
						if buffer[position] != rune('o') {
							goto l173
						}
						position++
						if !_rules[ruleDigit]() {
							goto l173
						}
					l174:
						{
							position175, tokenIndex175 := position, tokenIndex
							if !_rules[ruleDigit]() {
								goto l175
							}
							goto l174
						l175:
							position, tokenIndex = position175, tokenIndex175
						}
						goto l163
					l173:
						position, tokenIndex = position163, tokenIndex163
						{
							position176, tokenIndex176 := position, tokenIndex
							{
								position178, tokenIndex178 := position, tokenIndex
								if buffer[position] != rune('+') {
									goto l179
								}
								position++
								goto l178
							l179:
								position, tokenIndex = position178, tokenIndex178
								if buffer[position] != rune('-') {
									goto l176
								}
								position++
							}
						l178:
							goto l177
						l176:
							position, tokenIndex = position176, tokenIndex176
						}
					l177:
						if !_rules[ruleDigit]() {
							goto l160
						}
					l180:
						{
							position181, tokenIndex181 := position, tokenIndex
							if !_rules[ruleDigit]() {
								goto l181
							}
							goto l180
						l181:
							position, tokenIndex = position181, tokenIndex181
						}
					}
				l163:
					add(rulePegText, position162)
				}
			l182:
				{
					position183, tokenIndex183 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l183
					}
					goto l182
				l183:
					position, tokenIndex = position183, tokenIndex183
				}
				add(ruleIntConstant, position161)
			}
			return true
		l160:
			position, tokenIndex = position160, tokenIndex160
			return false
		},
		/* 29 DoubleConstant <- <(Skip <(('+' / '-')? ((Digit* '.' Digit+ Exponent?) / (Digit+ Exponent)))> Indent*)> */
		func() bool {
			position184, tokenIndex184 := position, tokenIndex
			{
				position185 := position
				if !_rules[ruleSkip]() {
					goto l184
				}
				{
					position186 := position
					{
						position187, tokenIndex187 := position, tokenIndex
						{
							position189, tokenIndex189 := position, tokenIndex
							if buffer[position] != rune('+') {
								goto l190
							}
							position++
							goto l189
						l190:
							position, tokenIndex = position189, tokenIndex189
							if buffer[position] != rune('-') {
								goto l187
							}
							position++
						}
					l189:
						goto l188
					l187:
						position, tokenIndex = position187, tokenIndex187
					}
				l188:
					{
						position191, tokenIndex191 := position, tokenIndex
					l193:
						{
							position194, tokenIndex194 := position, tokenIndex
							if !_rules[ruleDigit]() {
								goto l194
							}
							goto l193
						l194:
							position, tokenIndex = position194, tokenIndex194
						}
						if buffer[position] != rune('.') {
							goto l192
						}
						position++
						if !_rules[ruleDigit]() {
							goto l192
						}
					l195:
						{
							position196, tokenIndex196 := position, tokenIndex
							if !_rules[ruleDigit]() {
								goto l196
							}
							goto l195
						l196:
							position, tokenIndex = position196, tokenIndex196
						}
						{
							position197, tokenIndex197 := position, tokenIndex
							if !_rules[ruleExponent]() {
								goto l197
							}
							goto l198
						l197:
							position, tokenIndex = position197, tokenIndex197
						}
					l198:
						goto l191
					l192:
						position, tokenIndex = position191, tokenIndex191
						if !_rules[ruleDigit]() {
							goto l184
						}
					l199:
						{
							position200, tokenIndex200 := position, tokenIndex
							if !_rules[ruleDigit]() {
								goto l200
							}
							goto l199
						l200:
							position, tokenIndex = position200, tokenIndex200
						}
						if !_rules[ruleExponent]() {
							goto l184
						}
					}
				l191:
					add(rulePegText, position186)
				}
			l201:
				{
					position202, tokenIndex202 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l202
					}
					goto l201
				l202:
					position, tokenIndex = position202, tokenIndex202
				}
				add(ruleDoubleConstant, position185)
			}
			return true
		l184:
			position, tokenIndex = position184, tokenIndex184
			return false
		},
		/* 30 Exponent <- <(('e' / 'E') IntConstant)> */
		func() bool {
			position203, tokenIndex203 := position, tokenIndex
			{
				position204 := position
				{
					position205, tokenIndex205 := position, tokenIndex
					if buffer[position] != rune('e') {
						goto l206
					}
					position++
					goto l205
				l206:
					position, tokenIndex = position205, tokenIndex205
					if buffer[position] != rune('E') {
						goto l203
					}
					position++
				}
			l205:
				if !_rules[ruleIntConstant]() {
					goto l203
				}
				add(ruleExponent, position204)
			}
			return true
		l203:
			position, tokenIndex = position203, tokenIndex203
			return false
		},
		/* 31 Annotations <- <(LPAR Annotation+ RPAR)> */
		func() bool {
			position207, tokenIndex207 := position, tokenIndex
			{
				position208 := position
				if !_rules[ruleLPAR]() {
					goto l207
				}
				if !_rules[ruleAnnotation]() {
					goto l207
				}
			l209:
				{
					position210, tokenIndex210 := position, tokenIndex
					if !_rules[ruleAnnotation]() {
						goto l210
					}
					goto l209
				l210:
					position, tokenIndex = position210, tokenIndex210
				}
				if !_rules[ruleRPAR]() {
					goto l207
				}
				add(ruleAnnotations, position208)
			}
			return true
		l207:
			position, tokenIndex = position207, tokenIndex207
			return false
		},
		/* 32 Annotation <- <(Identifier EQUAL Literal ListSeparator?)> */
		func() bool {
			position211, tokenIndex211 := position, tokenIndex
			{
				position212 := position
				if !_rules[ruleIdentifier]() {
					goto l211
				}
				if !_rules[ruleEQUAL]() {
					goto l211
				}
				if !_rules[ruleLiteral]() {
					goto l211
				}
				{
					position213, tokenIndex213 := position, tokenIndex
					if !_rules[ruleListSeparator]() {
						goto l213
					}
					goto l214
				l213:
					position, tokenIndex = position213, tokenIndex213
				}
			l214:
				add(ruleAnnotation, position212)
			}
			return true
		l211:
			position, tokenIndex = position211, tokenIndex211
			return false
		},
		/* 33 ConstList <- <(LBRK (ConstValue ListSeparator?)* RBRK)> */
		func() bool {
			position215, tokenIndex215 := position, tokenIndex
			{
				position216 := position
				if !_rules[ruleLBRK]() {
					goto l215
				}
			l217:
				{
					position218, tokenIndex218 := position, tokenIndex
					if !_rules[ruleConstValue]() {
						goto l218
					}
					{
						position219, tokenIndex219 := position, tokenIndex
						if !_rules[ruleListSeparator]() {
							goto l219
						}
						goto l220
					l219:
						position, tokenIndex = position219, tokenIndex219
					}
				l220:
					goto l217
				l218:
					position, tokenIndex = position218, tokenIndex218
				}
				if !_rules[ruleRBRK]() {
					goto l215
				}
				add(ruleConstList, position216)
			}
			return true
		l215:
			position, tokenIndex = position215, tokenIndex215
			return false
		},
		/* 34 ConstMap <- <(LWING (ConstValue COLON ConstValue ListSeparator?)* RWING)> */
		func() bool {
			position221, tokenIndex221 := position, tokenIndex
			{
				position222 := position
				if !_rules[ruleLWING]() {
					goto l221
				}
			l223:
				{
					position224, tokenIndex224 := position, tokenIndex
					if !_rules[ruleConstValue]() {
						goto l224
					}
					if !_rules[ruleCOLON]() {
						goto l224
					}
					if !_rules[ruleConstValue]() {
						goto l224
					}
					{
						position225, tokenIndex225 := position, tokenIndex
						if !_rules[ruleListSeparator]() {
							goto l225
						}
						goto l226
					l225:
						position, tokenIndex = position225, tokenIndex225
					}
				l226:
					goto l223
				l224:
					position, tokenIndex = position224, tokenIndex224
				}
				if !_rules[ruleRWING]() {
					goto l221
				}
				add(ruleConstMap, position222)
			}
			return true
		l221:
			position, tokenIndex = position221, tokenIndex221
			return false
		},
		/* 35 EscapeLiteralChar <- <('\\' ('"' / '\''))> */
		func() bool {
			position227, tokenIndex227 := position, tokenIndex
			{
				position228 := position
				if buffer[position] != rune('\\') {
					goto l227
				}
				position++
				{
					position229, tokenIndex229 := position, tokenIndex
					if buffer[position] != rune('"') {
						goto l230
					}
					position++
					goto l229
				l230:
					position, tokenIndex = position229, tokenIndex229
					if buffer[position] != rune('\'') {
						goto l227
					}
					position++
				}
			l229:
				add(ruleEscapeLiteralChar, position228)
			}
			return true
		l227:
			position, tokenIndex = position227, tokenIndex227
			return false
		},
		/* 36 Literal <- <((Skip '"' <(EscapeLiteralChar / (!'"' .))*> '"' Indent*) / (Skip '\'' <(EscapeLiteralChar / (!'\'' .))*> '\'' Indent*))> */
		func() bool {
			position231, tokenIndex231 := position, tokenIndex
			{
				position232 := position
				{
					position233, tokenIndex233 := position, tokenIndex
					if !_rules[ruleSkip]() {
						goto l234
					}
					if buffer[position] != rune('"') {
						goto l234
					}
					position++
					{
						position235 := position
					l236:
						{
							position237, tokenIndex237 := position, tokenIndex
							{
								position238, tokenIndex238 := position, tokenIndex
								if !_rules[ruleEscapeLiteralChar]() {
									goto l239
								}
								goto l238
							l239:
								position, tokenIndex = position238, tokenIndex238
								{
									position240, tokenIndex240 := position, tokenIndex
									if buffer[position] != rune('"') {
										goto l240
									}
									position++
									goto l237
								l240:
									position, tokenIndex = position240, tokenIndex240
								}
								if !matchDot() {
									goto l237
								}
							}
						l238:
							goto l236
						l237:
							position, tokenIndex = position237, tokenIndex237
						}
						add(rulePegText, position235)
					}
					if buffer[position] != rune('"') {
						goto l234
					}
					position++
				l241:
					{
						position242, tokenIndex242 := position, tokenIndex
						if !_rules[ruleIndent]() {
							goto l242
						}
						goto l241
					l242:
						position, tokenIndex = position242, tokenIndex242
					}
					goto l233
				l234:
					position, tokenIndex = position233, tokenIndex233
					if !_rules[ruleSkip]() {
						goto l231
					}
					if buffer[position] != rune('\'') {
						goto l231
					}
					position++
					{
						position243 := position
					l244:
						{
							position245, tokenIndex245 := position, tokenIndex
							{
								position246, tokenIndex246 := position, tokenIndex
								if !_rules[ruleEscapeLiteralChar]() {
									goto l247
								}
								goto l246
							l247:
								position, tokenIndex = position246, tokenIndex246
								{
									position248, tokenIndex248 := position, tokenIndex
									if buffer[position] != rune('\'') {
										goto l248
									}
									position++
									goto l245
								l248:
									position, tokenIndex = position248, tokenIndex248
								}
								if !matchDot() {
									goto l245
								}
							}
						l246:
							goto l244
						l245:
							position, tokenIndex = position245, tokenIndex245
						}
						add(rulePegText, position243)
					}
					if buffer[position] != rune('\'') {
						goto l231
					}
					position++
				l249:
					{
						position250, tokenIndex250 := position, tokenIndex
						if !_rules[ruleIndent]() {
							goto l250
						}
						goto l249
					l250:
						position, tokenIndex = position250, tokenIndex250
					}
				}
			l233:
				add(ruleLiteral, position232)
			}
			return true
		l231:
			position, tokenIndex = position231, tokenIndex231
			return false
		},
		/* 37 Identifier <- <(Skip <(Letter (Letter / Digit / '.')*)> Indent*)> */
		func() bool {
			position251, tokenIndex251 := position, tokenIndex
			{
				position252 := position
				if !_rules[ruleSkip]() {
					goto l251
				}
				{
					position253 := position
					if !_rules[ruleLetter]() {
						goto l251
					}
				l254:
					{
						position255, tokenIndex255 := position, tokenIndex
						{
							position256, tokenIndex256 := position, tokenIndex
							if !_rules[ruleLetter]() {
								goto l257
							}
							goto l256
						l257:
							position, tokenIndex = position256, tokenIndex256
							if !_rules[ruleDigit]() {
								goto l258
							}
							goto l256
						l258:
							position, tokenIndex = position256, tokenIndex256
							if buffer[position] != rune('.') {
								goto l255
							}
							position++
						}
					l256:
						goto l254
					l255:
						position, tokenIndex = position255, tokenIndex255
					}
					add(rulePegText, position253)
				}
			l259:
				{
					position260, tokenIndex260 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l260
					}
					goto l259
				l260:
					position, tokenIndex = position260, tokenIndex260
				}
				add(ruleIdentifier, position252)
			}
			return true
		l251:
			position, tokenIndex = position251, tokenIndex251
			return false
		},
		/* 38 ListSeparator <- <(Skip (',' / ';') Indent*)> */
		func() bool {
			position261, tokenIndex261 := position, tokenIndex
			{
				position262 := position
				if !_rules[ruleSkip]() {
					goto l261
				}
				{
					position263, tokenIndex263 := position, tokenIndex
					if buffer[position] != rune(',') {
						goto l264
					}
					position++
					goto l263
				l264:
					position, tokenIndex = position263, tokenIndex263
					if buffer[position] != rune(';') {
						goto l261
					}
					position++
				}
			l263:
			l265:
				{
					position266, tokenIndex266 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l266
					}
					goto l265
				l266:
					position, tokenIndex = position266, tokenIndex266
				}
				add(ruleListSeparator, position262)
			}
			return true
		l261:
			position, tokenIndex = position261, tokenIndex261
			return false
		},
		/* 39 Letter <- <([A-Z] / [a-z] / '_')> */
		func() bool {
			position267, tokenIndex267 := position, tokenIndex
			{
				position268 := position
				{
					position269, tokenIndex269 := position, tokenIndex
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l270
					}
					position++
					goto l269
				l270:
					position, tokenIndex = position269, tokenIndex269
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l271
					}
					position++
					goto l269
				l271:
					position, tokenIndex = position269, tokenIndex269
					if buffer[position] != rune('_') {
						goto l267
					}
					position++
				}
			l269:
				add(ruleLetter, position268)
			}
			return true
		l267:
			position, tokenIndex = position267, tokenIndex267
			return false
		},
		/* 40 LetterOrDigit <- <([a-z] / [A-Z] / [0-9] / ('_' / '$'))> */
		func() bool {
			position272, tokenIndex272 := position, tokenIndex
			{
				position273 := position
				{
					position274, tokenIndex274 := position, tokenIndex
					if c := buffer[position]; c < rune('a') || c > rune('z') {
						goto l275
					}
					position++
					goto l274
				l275:
					position, tokenIndex = position274, tokenIndex274
					if c := buffer[position]; c < rune('A') || c > rune('Z') {
						goto l276
					}
					position++
					goto l274
				l276:
					position, tokenIndex = position274, tokenIndex274
					if c := buffer[position]; c < rune('0') || c > rune('9') {
						goto l277
					}
					position++
					goto l274
				l277:
					position, tokenIndex = position274, tokenIndex274
					{
						position278, tokenIndex278 := position, tokenIndex
						if buffer[position] != rune('_') {
							goto l279
						}
						position++
						goto l278
					l279:
						position, tokenIndex = position278, tokenIndex278
						if buffer[position] != rune('$') {
							goto l272
						}
						position++
					}
				l278:
				}
			l274:
				add(ruleLetterOrDigit, position273)
			}
			return true
		l272:
			position, tokenIndex = position272, tokenIndex272
			return false
		},
		/* 41 Digit <- <[0-9]> */
		func() bool {
			position280, tokenIndex280 := position, tokenIndex
			{
				position281 := position
				if c := buffer[position]; c < rune('0') || c > rune('9') {
					goto l280
				}
				position++
				add(ruleDigit, position281)
			}
			return true
		l280:
			position, tokenIndex = position280, tokenIndex280
			return false
		},
		/* 42 ReservedComments <- <Skip> */
		func() bool {
			position282, tokenIndex282 := position, tokenIndex
			{
				position283 := position
				if !_rules[ruleSkip]() {
					goto l282
				}
				add(ruleReservedComments, position283)
			}
			return true
		l282:
			position, tokenIndex = position282, tokenIndex282
			return false
		},
		/* 43 Skip <- <(Space / Comment)*> */
		func() bool {
			{
				position285 := position
			l286:
				{
					position287, tokenIndex287 := position, tokenIndex
					{
						position288, tokenIndex288 := position, tokenIndex
						if !_rules[ruleSpace]() {
							goto l289
						}
						goto l288
					l289:
						position, tokenIndex = position288, tokenIndex288
						if !_rules[ruleComment]() {
							goto l287
						}
					}
				l288:
					goto l286
				l287:
					position, tokenIndex = position287, tokenIndex287
				}
				add(ruleSkip, position285)
			}
			return true
		},
		/* 44 SkipLine <- <((Indent / Comment)* CarriageReturnLineFeed?)> */
		func() bool {
			{
				position291 := position
			l292:
				{
					position293, tokenIndex293 := position, tokenIndex
					{
						position294, tokenIndex294 := position, tokenIndex
						if !_rules[ruleIndent]() {
							goto l295
						}
						goto l294
					l295:
						position, tokenIndex = position294, tokenIndex294
						if !_rules[ruleComment]() {
							goto l293
						}
					}
				l294:
					goto l292
				l293:
					position, tokenIndex = position293, tokenIndex293
				}
				{
					position296, tokenIndex296 := position, tokenIndex
					if !_rules[ruleCarriageReturnLineFeed]() {
						goto l296
					}
					goto l297
				l296:
					position, tokenIndex = position296, tokenIndex296
				}
			l297:
				add(ruleSkipLine, position291)
			}
			return true
		},
		/* 45 Space <- <(Indent / CarriageReturnLineFeed)+> */
		func() bool {
			position298, tokenIndex298 := position, tokenIndex
			{
				position299 := position
				{
					position302, tokenIndex302 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l303
					}
					goto l302
				l303:
					position, tokenIndex = position302, tokenIndex302
					if !_rules[ruleCarriageReturnLineFeed]() {
						goto l298
					}
				}
			l302:
			l300:
				{
					position301, tokenIndex301 := position, tokenIndex
					{
						position304, tokenIndex304 := position, tokenIndex
						if !_rules[ruleIndent]() {
							goto l305
						}
						goto l304
					l305:
						position, tokenIndex = position304, tokenIndex304
						if !_rules[ruleCarriageReturnLineFeed]() {
							goto l301
						}
					}
				l304:
					goto l300
				l301:
					position, tokenIndex = position301, tokenIndex301
				}
				add(ruleSpace, position299)
			}
			return true
		l298:
			position, tokenIndex = position298, tokenIndex298
			return false
		},
		/* 46 Indent <- <(' ' / '\t' / '\v')> */
		func() bool {
			position306, tokenIndex306 := position, tokenIndex
			{
				position307 := position
				{
					position308, tokenIndex308 := position, tokenIndex
					if buffer[position] != rune(' ') {
						goto l309
					}
					position++
					goto l308
				l309:
					position, tokenIndex = position308, tokenIndex308
					if buffer[position] != rune('\t') {
						goto l310
					}
					position++
					goto l308
				l310:
					position, tokenIndex = position308, tokenIndex308
					if buffer[position] != rune('\v') {
						goto l306
					}
					position++
				}
			l308:
				add(ruleIndent, position307)
			}
			return true
		l306:
			position, tokenIndex = position306, tokenIndex306
			return false
		},
		/* 47 CarriageReturnLineFeed <- <('\r' / '\n')> */
		func() bool {
			position311, tokenIndex311 := position, tokenIndex
			{
				position312 := position
				{
					position313, tokenIndex313 := position, tokenIndex
					if buffer[position] != rune('\r') {
						goto l314
					}
					position++
					goto l313
				l314:
					position, tokenIndex = position313, tokenIndex313
					if buffer[position] != rune('\n') {
						goto l311
					}
					position++
				}
			l313:
				add(ruleCarriageReturnLineFeed, position312)
			}
			return true
		l311:
			position, tokenIndex = position311, tokenIndex311
			return false
		},
		/* 48 Comment <- <(LongComment / LineComment / UnixComment)> */
		func() bool {
			position315, tokenIndex315 := position, tokenIndex
			{
				position316 := position
				{
					position317, tokenIndex317 := position, tokenIndex
					if !_rules[ruleLongComment]() {
						goto l318
					}
					goto l317
				l318:
					position, tokenIndex = position317, tokenIndex317
					if !_rules[ruleLineComment]() {
						goto l319
					}
					goto l317
				l319:
					position, tokenIndex = position317, tokenIndex317
					if !_rules[ruleUnixComment]() {
						goto l315
					}
				}
			l317:
				add(ruleComment, position316)
			}
			return true
		l315:
			position, tokenIndex = position315, tokenIndex315
			return false
		},
		/* 49 LongComment <- <('/' '*' (!('*' '/') .)* ('*' '/'))> */
		func() bool {
			position320, tokenIndex320 := position, tokenIndex
			{
				position321 := position
				if buffer[position] != rune('/') {
					goto l320
				}
				position++
				if buffer[position] != rune('*') {
					goto l320
				}
				position++
			l322:
				{
					position323, tokenIndex323 := position, tokenIndex
					{
						position324, tokenIndex324 := position, tokenIndex
						if buffer[position] != rune('*') {
							goto l324
						}
						position++
						if buffer[position] != rune('/') {
							goto l324
						}
						position++
						goto l323
					l324:
						position, tokenIndex = position324, tokenIndex324
					}
					if !matchDot() {
						goto l323
					}
					goto l322
				l323:
					position, tokenIndex = position323, tokenIndex323
				}
				if buffer[position] != rune('*') {
					goto l320
				}
				position++
				if buffer[position] != rune('/') {
					goto l320
				}
				position++
				add(ruleLongComment, position321)
			}
			return true
		l320:
			position, tokenIndex = position320, tokenIndex320
			return false
		},
		/* 50 LineComment <- <('/' '/' (!('\r' / '\n') .)*)> */
		func() bool {
			position325, tokenIndex325 := position, tokenIndex
			{
				position326 := position
				if buffer[position] != rune('/') {
					goto l325
				}
				position++
				if buffer[position] != rune('/') {
					goto l325
				}
				position++
			l327:
				{
					position328, tokenIndex328 := position, tokenIndex
					{
						position329, tokenIndex329 := position, tokenIndex
						{
							position330, tokenIndex330 := position, tokenIndex
							if buffer[position] != rune('\r') {
								goto l331
							}
							position++
							goto l330
						l331:
							position, tokenIndex = position330, tokenIndex330
							if buffer[position] != rune('\n') {
								goto l329
							}
							position++
						}
					l330:
						goto l328
					l329:
						position, tokenIndex = position329, tokenIndex329
					}
					if !matchDot() {
						goto l328
					}
					goto l327
				l328:
					position, tokenIndex = position328, tokenIndex328
				}
				add(ruleLineComment, position326)
			}
			return true
		l325:
			position, tokenIndex = position325, tokenIndex325
			return false
		},
		/* 51 UnixComment <- <('#' (!('\r' / '\n') .)*)> */
		func() bool {
			position332, tokenIndex332 := position, tokenIndex
			{
				position333 := position
				if buffer[position] != rune('#') {
					goto l332
				}
				position++
			l334:
				{
					position335, tokenIndex335 := position, tokenIndex
					{
						position336, tokenIndex336 := position, tokenIndex
						{
							position337, tokenIndex337 := position, tokenIndex
							if buffer[position] != rune('\r') {
								goto l338
							}
							position++
							goto l337
						l338:
							position, tokenIndex = position337, tokenIndex337
							if buffer[position] != rune('\n') {
								goto l336
							}
							position++
						}
					l337:
						goto l335
					l336:
						position, tokenIndex = position336, tokenIndex336
					}
					if !matchDot() {
						goto l335
					}
					goto l334
				l335:
					position, tokenIndex = position335, tokenIndex335
				}
				add(ruleUnixComment, position333)
			}
			return true
		l332:
			position, tokenIndex = position332, tokenIndex332
			return false
		},
		/* 52 BOOL <- <(Skip <('b' 'o' 'o' 'l')> !LetterOrDigit Indent*)> */
		func() bool {
			position339, tokenIndex339 := position, tokenIndex
			{
				position340 := position
				if !_rules[ruleSkip]() {
					goto l339
				}
				{
					position341 := position
					if buffer[position] != rune('b') {
						goto l339
					}
					position++
					if buffer[position] != rune('o') {
						goto l339
					}
					position++
					if buffer[position] != rune('o') {
						goto l339
					}
					position++
					if buffer[position] != rune('l') {
						goto l339
					}
					position++
					add(rulePegText, position341)
				}
				{
					position342, tokenIndex342 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l342
					}
					goto l339
				l342:
					position, tokenIndex = position342, tokenIndex342
				}
			l343:
				{
					position344, tokenIndex344 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l344
					}
					goto l343
				l344:
					position, tokenIndex = position344, tokenIndex344
				}
				add(ruleBOOL, position340)
			}
			return true
		l339:
			position, tokenIndex = position339, tokenIndex339
			return false
		},
		/* 53 BYTE <- <(Skip <('b' 'y' 't' 'e')> !LetterOrDigit Indent*)> */
		func() bool {
			position345, tokenIndex345 := position, tokenIndex
			{
				position346 := position
				if !_rules[ruleSkip]() {
					goto l345
				}
				{
					position347 := position
					if buffer[position] != rune('b') {
						goto l345
					}
					position++
					if buffer[position] != rune('y') {
						goto l345
					}
					position++
					if buffer[position] != rune('t') {
						goto l345
					}
					position++
					if buffer[position] != rune('e') {
						goto l345
					}
					position++
					add(rulePegText, position347)
				}
				{
					position348, tokenIndex348 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l348
					}
					goto l345
				l348:
					position, tokenIndex = position348, tokenIndex348
				}
			l349:
				{
					position350, tokenIndex350 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l350
					}
					goto l349
				l350:
					position, tokenIndex = position350, tokenIndex350
				}
				add(ruleBYTE, position346)
			}
			return true
		l345:
			position, tokenIndex = position345, tokenIndex345
			return false
		},
		/* 54 I8 <- <(Skip <('i' '8')> !LetterOrDigit Indent*)> */
		func() bool {
			position351, tokenIndex351 := position, tokenIndex
			{
				position352 := position
				if !_rules[ruleSkip]() {
					goto l351
				}
				{
					position353 := position
					if buffer[position] != rune('i') {
						goto l351
					}
					position++
					if buffer[position] != rune('8') {
						goto l351
					}
					position++
					add(rulePegText, position353)
				}
				{
					position354, tokenIndex354 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l354
					}
					goto l351
				l354:
					position, tokenIndex = position354, tokenIndex354
				}
			l355:
				{
					position356, tokenIndex356 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l356
					}
					goto l355
				l356:
					position, tokenIndex = position356, tokenIndex356
				}
				add(ruleI8, position352)
			}
			return true
		l351:
			position, tokenIndex = position351, tokenIndex351
			return false
		},
		/* 55 I16 <- <(Skip <('i' '1' '6')> !LetterOrDigit Indent*)> */
		func() bool {
			position357, tokenIndex357 := position, tokenIndex
			{
				position358 := position
				if !_rules[ruleSkip]() {
					goto l357
				}
				{
					position359 := position
					if buffer[position] != rune('i') {
						goto l357
					}
					position++
					if buffer[position] != rune('1') {
						goto l357
					}
					position++
					if buffer[position] != rune('6') {
						goto l357
					}
					position++
					add(rulePegText, position359)
				}
				{
					position360, tokenIndex360 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l360
					}
					goto l357
				l360:
					position, tokenIndex = position360, tokenIndex360
				}
			l361:
				{
					position362, tokenIndex362 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l362
					}
					goto l361
				l362:
					position, tokenIndex = position362, tokenIndex362
				}
				add(ruleI16, position358)
			}
			return true
		l357:
			position, tokenIndex = position357, tokenIndex357
			return false
		},
		/* 56 I32 <- <(Skip <('i' '3' '2')> !LetterOrDigit Indent*)> */
		func() bool {
			position363, tokenIndex363 := position, tokenIndex
			{
				position364 := position
				if !_rules[ruleSkip]() {
					goto l363
				}
				{
					position365 := position
					if buffer[position] != rune('i') {
						goto l363
					}
					position++
					if buffer[position] != rune('3') {
						goto l363
					}
					position++
					if buffer[position] != rune('2') {
						goto l363
					}
					position++
					add(rulePegText, position365)
				}
				{
					position366, tokenIndex366 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l366
					}
					goto l363
				l366:
					position, tokenIndex = position366, tokenIndex366
				}
			l367:
				{
					position368, tokenIndex368 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l368
					}
					goto l367
				l368:
					position, tokenIndex = position368, tokenIndex368
				}
				add(ruleI32, position364)
			}
			return true
		l363:
			position, tokenIndex = position363, tokenIndex363
			return false
		},
		/* 57 I64 <- <(Skip <('i' '6' '4')> !LetterOrDigit Indent*)> */
		func() bool {
			position369, tokenIndex369 := position, tokenIndex
			{
				position370 := position
				if !_rules[ruleSkip]() {
					goto l369
				}
				{
					position371 := position
					if buffer[position] != rune('i') {
						goto l369
					}
					position++
					if buffer[position] != rune('6') {
						goto l369
					}
					position++
					if buffer[position] != rune('4') {
						goto l369
					}
					position++
					add(rulePegText, position371)
				}
				{
					position372, tokenIndex372 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l372
					}
					goto l369
				l372:
					position, tokenIndex = position372, tokenIndex372
				}
			l373:
				{
					position374, tokenIndex374 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l374
					}
					goto l373
				l374:
					position, tokenIndex = position374, tokenIndex374
				}
				add(ruleI64, position370)
			}
			return true
		l369:
			position, tokenIndex = position369, tokenIndex369
			return false
		},
		/* 58 DOUBLE <- <(Skip <('d' 'o' 'u' 'b' 'l' 'e')> !LetterOrDigit Indent*)> */
		func() bool {
			position375, tokenIndex375 := position, tokenIndex
			{
				position376 := position
				if !_rules[ruleSkip]() {
					goto l375
				}
				{
					position377 := position
					if buffer[position] != rune('d') {
						goto l375
					}
					position++
					if buffer[position] != rune('o') {
						goto l375
					}
					position++
					if buffer[position] != rune('u') {
						goto l375
					}
					position++
					if buffer[position] != rune('b') {
						goto l375
					}
					position++
					if buffer[position] != rune('l') {
						goto l375
					}
					position++
					if buffer[position] != rune('e') {
						goto l375
					}
					position++
					add(rulePegText, position377)
				}
				{
					position378, tokenIndex378 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l378
					}
					goto l375
				l378:
					position, tokenIndex = position378, tokenIndex378
				}
			l379:
				{
					position380, tokenIndex380 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l380
					}
					goto l379
				l380:
					position, tokenIndex = position380, tokenIndex380
				}
				add(ruleDOUBLE, position376)
			}
			return true
		l375:
			position, tokenIndex = position375, tokenIndex375
			return false
		},
		/* 59 STRING <- <(Skip <('s' 't' 'r' 'i' 'n' 'g')> !LetterOrDigit Indent*)> */
		func() bool {
			position381, tokenIndex381 := position, tokenIndex
			{
				position382 := position
				if !_rules[ruleSkip]() {
					goto l381
				}
				{
					position383 := position
					if buffer[position] != rune('s') {
						goto l381
					}
					position++
					if buffer[position] != rune('t') {
						goto l381
					}
					position++
					if buffer[position] != rune('r') {
						goto l381
					}
					position++
					if buffer[position] != rune('i') {
						goto l381
					}
					position++
					if buffer[position] != rune('n') {
						goto l381
					}
					position++
					if buffer[position] != rune('g') {
						goto l381
					}
					position++
					add(rulePegText, position383)
				}
				{
					position384, tokenIndex384 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l384
					}
					goto l381
				l384:
					position, tokenIndex = position384, tokenIndex384
				}
			l385:
				{
					position386, tokenIndex386 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l386
					}
					goto l385
				l386:
					position, tokenIndex = position386, tokenIndex386
				}
				add(ruleSTRING, position382)
			}
			return true
		l381:
			position, tokenIndex = position381, tokenIndex381
			return false
		},
		/* 60 BINARY <- <(Skip <('b' 'i' 'n' 'a' 'r' 'y')> !LetterOrDigit Indent*)> */
		func() bool {
			position387, tokenIndex387 := position, tokenIndex
			{
				position388 := position
				if !_rules[ruleSkip]() {
					goto l387
				}
				{
					position389 := position
					if buffer[position] != rune('b') {
						goto l387
					}
					position++
					if buffer[position] != rune('i') {
						goto l387
					}
					position++
					if buffer[position] != rune('n') {
						goto l387
					}
					position++
					if buffer[position] != rune('a') {
						goto l387
					}
					position++
					if buffer[position] != rune('r') {
						goto l387
					}
					position++
					if buffer[position] != rune('y') {
						goto l387
					}
					position++
					add(rulePegText, position389)
				}
				{
					position390, tokenIndex390 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l390
					}
					goto l387
				l390:
					position, tokenIndex = position390, tokenIndex390
				}
			l391:
				{
					position392, tokenIndex392 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l392
					}
					goto l391
				l392:
					position, tokenIndex = position392, tokenIndex392
				}
				add(ruleBINARY, position388)
			}
			return true
		l387:
			position, tokenIndex = position387, tokenIndex387
			return false
		},
		/* 61 CONST <- <(Skip ('c' 'o' 'n' 's' 't') !LetterOrDigit Indent*)> */
		func() bool {
			position393, tokenIndex393 := position, tokenIndex
			{
				position394 := position
				if !_rules[ruleSkip]() {
					goto l393
				}
				if buffer[position] != rune('c') {
					goto l393
				}
				position++
				if buffer[position] != rune('o') {
					goto l393
				}
				position++
				if buffer[position] != rune('n') {
					goto l393
				}
				position++
				if buffer[position] != rune('s') {
					goto l393
				}
				position++
				if buffer[position] != rune('t') {
					goto l393
				}
				position++
				{
					position395, tokenIndex395 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l395
					}
					goto l393
				l395:
					position, tokenIndex = position395, tokenIndex395
				}
			l396:
				{
					position397, tokenIndex397 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l397
					}
					goto l396
				l397:
					position, tokenIndex = position397, tokenIndex397
				}
				add(ruleCONST, position394)
			}
			return true
		l393:
			position, tokenIndex = position393, tokenIndex393
			return false
		},
		/* 62 ONEWAY <- <(Skip ('o' 'n' 'e' 'w' 'a' 'y') !LetterOrDigit Indent*)> */
		func() bool {
			position398, tokenIndex398 := position, tokenIndex
			{
				position399 := position
				if !_rules[ruleSkip]() {
					goto l398
				}
				if buffer[position] != rune('o') {
					goto l398
				}
				position++
				if buffer[position] != rune('n') {
					goto l398
				}
				position++
				if buffer[position] != rune('e') {
					goto l398
				}
				position++
				if buffer[position] != rune('w') {
					goto l398
				}
				position++
				if buffer[position] != rune('a') {
					goto l398
				}
				position++
				if buffer[position] != rune('y') {
					goto l398
				}
				position++
				{
					position400, tokenIndex400 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l400
					}
					goto l398
				l400:
					position, tokenIndex = position400, tokenIndex400
				}
			l401:
				{
					position402, tokenIndex402 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l402
					}
					goto l401
				l402:
					position, tokenIndex = position402, tokenIndex402
				}
				add(ruleONEWAY, position399)
			}
			return true
		l398:
			position, tokenIndex = position398, tokenIndex398
			return false
		},
		/* 63 TYPEDEF <- <(Skip ('t' 'y' 'p' 'e' 'd' 'e' 'f') !LetterOrDigit Indent*)> */
		func() bool {
			position403, tokenIndex403 := position, tokenIndex
			{
				position404 := position
				if !_rules[ruleSkip]() {
					goto l403
				}
				if buffer[position] != rune('t') {
					goto l403
				}
				position++
				if buffer[position] != rune('y') {
					goto l403
				}
				position++
				if buffer[position] != rune('p') {
					goto l403
				}
				position++
				if buffer[position] != rune('e') {
					goto l403
				}
				position++
				if buffer[position] != rune('d') {
					goto l403
				}
				position++
				if buffer[position] != rune('e') {
					goto l403
				}
				position++
				if buffer[position] != rune('f') {
					goto l403
				}
				position++
				{
					position405, tokenIndex405 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l405
					}
					goto l403
				l405:
					position, tokenIndex = position405, tokenIndex405
				}
			l406:
				{
					position407, tokenIndex407 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l407
					}
					goto l406
				l407:
					position, tokenIndex = position407, tokenIndex407
				}
				add(ruleTYPEDEF, position404)
			}
			return true
		l403:
			position, tokenIndex = position403, tokenIndex403
			return false
		},
		/* 64 MAP <- <(Skip ('m' 'a' 'p') !LetterOrDigit Indent*)> */
		func() bool {
			position408, tokenIndex408 := position, tokenIndex
			{
				position409 := position
				if !_rules[ruleSkip]() {
					goto l408
				}
				if buffer[position] != rune('m') {
					goto l408
				}
				position++
				if buffer[position] != rune('a') {
					goto l408
				}
				position++
				if buffer[position] != rune('p') {
					goto l408
				}
				position++
				{
					position410, tokenIndex410 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l410
					}
					goto l408
				l410:
					position, tokenIndex = position410, tokenIndex410
				}
			l411:
				{
					position412, tokenIndex412 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l412
					}
					goto l411
				l412:
					position, tokenIndex = position412, tokenIndex412
				}
				add(ruleMAP, position409)
			}
			return true
		l408:
			position, tokenIndex = position408, tokenIndex408
			return false
		},
		/* 65 SET <- <(Skip ('s' 'e' 't') !LetterOrDigit Indent*)> */
		func() bool {
			position413, tokenIndex413 := position, tokenIndex
			{
				position414 := position
				if !_rules[ruleSkip]() {
					goto l413
				}
				if buffer[position] != rune('s') {
					goto l413
				}
				position++
				if buffer[position] != rune('e') {
					goto l413
				}
				position++
				if buffer[position] != rune('t') {
					goto l413
				}
				position++
				{
					position415, tokenIndex415 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l415
					}
					goto l413
				l415:
					position, tokenIndex = position415, tokenIndex415
				}
			l416:
				{
					position417, tokenIndex417 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l417
					}
					goto l416
				l417:
					position, tokenIndex = position417, tokenIndex417
				}
				add(ruleSET, position414)
			}
			return true
		l413:
			position, tokenIndex = position413, tokenIndex413
			return false
		},
		/* 66 LIST <- <(Skip ('l' 'i' 's' 't') !LetterOrDigit Indent*)> */
		func() bool {
			position418, tokenIndex418 := position, tokenIndex
			{
				position419 := position
				if !_rules[ruleSkip]() {
					goto l418
				}
				if buffer[position] != rune('l') {
					goto l418
				}
				position++
				if buffer[position] != rune('i') {
					goto l418
				}
				position++
				if buffer[position] != rune('s') {
					goto l418
				}
				position++
				if buffer[position] != rune('t') {
					goto l418
				}
				position++
				{
					position420, tokenIndex420 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l420
					}
					goto l418
				l420:
					position, tokenIndex = position420, tokenIndex420
				}
			l421:
				{
					position422, tokenIndex422 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l422
					}
					goto l421
				l422:
					position, tokenIndex = position422, tokenIndex422
				}
				add(ruleLIST, position419)
			}
			return true
		l418:
			position, tokenIndex = position418, tokenIndex418
			return false
		},
		/* 67 VOID <- <(Skip ('v' 'o' 'i' 'd') !LetterOrDigit Indent*)> */
		func() bool {
			position423, tokenIndex423 := position, tokenIndex
			{
				position424 := position
				if !_rules[ruleSkip]() {
					goto l423
				}
				if buffer[position] != rune('v') {
					goto l423
				}
				position++
				if buffer[position] != rune('o') {
					goto l423
				}
				position++
				if buffer[position] != rune('i') {
					goto l423
				}
				position++
				if buffer[position] != rune('d') {
					goto l423
				}
				position++
				{
					position425, tokenIndex425 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l425
					}
					goto l423
				l425:
					position, tokenIndex = position425, tokenIndex425
				}
			l426:
				{
					position427, tokenIndex427 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l427
					}
					goto l426
				l427:
					position, tokenIndex = position427, tokenIndex427
				}
				add(ruleVOID, position424)
			}
			return true
		l423:
			position, tokenIndex = position423, tokenIndex423
			return false
		},
		/* 68 THROWS <- <(Skip ('t' 'h' 'r' 'o' 'w' 's') !LetterOrDigit Indent*)> */
		func() bool {
			position428, tokenIndex428 := position, tokenIndex
			{
				position429 := position
				if !_rules[ruleSkip]() {
					goto l428
				}
				if buffer[position] != rune('t') {
					goto l428
				}
				position++
				if buffer[position] != rune('h') {
					goto l428
				}
				position++
				if buffer[position] != rune('r') {
					goto l428
				}
				position++
				if buffer[position] != rune('o') {
					goto l428
				}
				position++
				if buffer[position] != rune('w') {
					goto l428
				}
				position++
				if buffer[position] != rune('s') {
					goto l428
				}
				position++
				{
					position430, tokenIndex430 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l430
					}
					goto l428
				l430:
					position, tokenIndex = position430, tokenIndex430
				}
			l431:
				{
					position432, tokenIndex432 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l432
					}
					goto l431
				l432:
					position, tokenIndex = position432, tokenIndex432
				}
				add(ruleTHROWS, position429)
			}
			return true
		l428:
			position, tokenIndex = position428, tokenIndex428
			return false
		},
		/* 69 EXCEPTION <- <(Skip ('e' 'x' 'c' 'e' 'p' 't' 'i' 'o' 'n') !LetterOrDigit Indent*)> */
		func() bool {
			position433, tokenIndex433 := position, tokenIndex
			{
				position434 := position
				if !_rules[ruleSkip]() {
					goto l433
				}
				if buffer[position] != rune('e') {
					goto l433
				}
				position++
				if buffer[position] != rune('x') {
					goto l433
				}
				position++
				if buffer[position] != rune('c') {
					goto l433
				}
				position++
				if buffer[position] != rune('e') {
					goto l433
				}
				position++
				if buffer[position] != rune('p') {
					goto l433
				}
				position++
				if buffer[position] != rune('t') {
					goto l433
				}
				position++
				if buffer[position] != rune('i') {
					goto l433
				}
				position++
				if buffer[position] != rune('o') {
					goto l433
				}
				position++
				if buffer[position] != rune('n') {
					goto l433
				}
				position++
				{
					position435, tokenIndex435 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l435
					}
					goto l433
				l435:
					position, tokenIndex = position435, tokenIndex435
				}
			l436:
				{
					position437, tokenIndex437 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l437
					}
					goto l436
				l437:
					position, tokenIndex = position437, tokenIndex437
				}
				add(ruleEXCEPTION, position434)
			}
			return true
		l433:
			position, tokenIndex = position433, tokenIndex433
			return false
		},
		/* 70 EXTENDS <- <(Skip ('e' 'x' 't' 'e' 'n' 'd' 's') !LetterOrDigit Indent*)> */
		func() bool {
			position438, tokenIndex438 := position, tokenIndex
			{
				position439 := position
				if !_rules[ruleSkip]() {
					goto l438
				}
				if buffer[position] != rune('e') {
					goto l438
				}
				position++
				if buffer[position] != rune('x') {
					goto l438
				}
				position++
				if buffer[position] != rune('t') {
					goto l438
				}
				position++
				if buffer[position] != rune('e') {
					goto l438
				}
				position++
				if buffer[position] != rune('n') {
					goto l438
				}
				position++
				if buffer[position] != rune('d') {
					goto l438
				}
				position++
				if buffer[position] != rune('s') {
					goto l438
				}
				position++
				{
					position440, tokenIndex440 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l440
					}
					goto l438
				l440:
					position, tokenIndex = position440, tokenIndex440
				}
			l441:
				{
					position442, tokenIndex442 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l442
					}
					goto l441
				l442:
					position, tokenIndex = position442, tokenIndex442
				}
				add(ruleEXTENDS, position439)
			}
			return true
		l438:
			position, tokenIndex = position438, tokenIndex438
			return false
		},
		/* 71 SERVICE <- <(Skip ('s' 'e' 'r' 'v' 'i' 'c' 'e') !LetterOrDigit Indent*)> */
		func() bool {
			position443, tokenIndex443 := position, tokenIndex
			{
				position444 := position
				if !_rules[ruleSkip]() {
					goto l443
				}
				if buffer[position] != rune('s') {
					goto l443
				}
				position++
				if buffer[position] != rune('e') {
					goto l443
				}
				position++
				if buffer[position] != rune('r') {
					goto l443
				}
				position++
				if buffer[position] != rune('v') {
					goto l443
				}
				position++
				if buffer[position] != rune('i') {
					goto l443
				}
				position++
				if buffer[position] != rune('c') {
					goto l443
				}
				position++
				if buffer[position] != rune('e') {
					goto l443
				}
				position++
				{
					position445, tokenIndex445 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l445
					}
					goto l443
				l445:
					position, tokenIndex = position445, tokenIndex445
				}
			l446:
				{
					position447, tokenIndex447 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l447
					}
					goto l446
				l447:
					position, tokenIndex = position447, tokenIndex447
				}
				add(ruleSERVICE, position444)
			}
			return true
		l443:
			position, tokenIndex = position443, tokenIndex443
			return false
		},
		/* 72 STRUCT <- <(Skip ('s' 't' 'r' 'u' 'c' 't') !LetterOrDigit Indent*)> */
		func() bool {
			position448, tokenIndex448 := position, tokenIndex
			{
				position449 := position
				if !_rules[ruleSkip]() {
					goto l448
				}
				if buffer[position] != rune('s') {
					goto l448
				}
				position++
				if buffer[position] != rune('t') {
					goto l448
				}
				position++
				if buffer[position] != rune('r') {
					goto l448
				}
				position++
				if buffer[position] != rune('u') {
					goto l448
				}
				position++
				if buffer[position] != rune('c') {
					goto l448
				}
				position++
				if buffer[position] != rune('t') {
					goto l448
				}
				position++
				{
					position450, tokenIndex450 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l450
					}
					goto l448
				l450:
					position, tokenIndex = position450, tokenIndex450
				}
			l451:
				{
					position452, tokenIndex452 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l452
					}
					goto l451
				l452:
					position, tokenIndex = position452, tokenIndex452
				}
				add(ruleSTRUCT, position449)
			}
			return true
		l448:
			position, tokenIndex = position448, tokenIndex448
			return false
		},
		/* 73 UNION <- <(Skip ('u' 'n' 'i' 'o' 'n') !LetterOrDigit Indent*)> */
		func() bool {
			position453, tokenIndex453 := position, tokenIndex
			{
				position454 := position
				if !_rules[ruleSkip]() {
					goto l453
				}
				if buffer[position] != rune('u') {
					goto l453
				}
				position++
				if buffer[position] != rune('n') {
					goto l453
				}
				position++
				if buffer[position] != rune('i') {
					goto l453
				}
				position++
				if buffer[position] != rune('o') {
					goto l453
				}
				position++
				if buffer[position] != rune('n') {
					goto l453
				}
				position++
				{
					position455, tokenIndex455 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l455
					}
					goto l453
				l455:
					position, tokenIndex = position455, tokenIndex455
				}
			l456:
				{
					position457, tokenIndex457 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l457
					}
					goto l456
				l457:
					position, tokenIndex = position457, tokenIndex457
				}
				add(ruleUNION, position454)
			}
			return true
		l453:
			position, tokenIndex = position453, tokenIndex453
			return false
		},
		/* 74 ENUM <- <(Skip ('e' 'n' 'u' 'm') !LetterOrDigit Indent*)> */
		func() bool {
			position458, tokenIndex458 := position, tokenIndex
			{
				position459 := position
				if !_rules[ruleSkip]() {
					goto l458
				}
				if buffer[position] != rune('e') {
					goto l458
				}
				position++
				if buffer[position] != rune('n') {
					goto l458
				}
				position++
				if buffer[position] != rune('u') {
					goto l458
				}
				position++
				if buffer[position] != rune('m') {
					goto l458
				}
				position++
				{
					position460, tokenIndex460 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l460
					}
					goto l458
				l460:
					position, tokenIndex = position460, tokenIndex460
				}
			l461:
				{
					position462, tokenIndex462 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l462
					}
					goto l461
				l462:
					position, tokenIndex = position462, tokenIndex462
				}
				add(ruleENUM, position459)
			}
			return true
		l458:
			position, tokenIndex = position458, tokenIndex458
			return false
		},
		/* 75 INCLUDE <- <(Skip ('i' 'n' 'c' 'l' 'u' 'd' 'e') !LetterOrDigit Indent*)> */
		func() bool {
			position463, tokenIndex463 := position, tokenIndex
			{
				position464 := position
				if !_rules[ruleSkip]() {
					goto l463
				}
				if buffer[position] != rune('i') {
					goto l463
				}
				position++
				if buffer[position] != rune('n') {
					goto l463
				}
				position++
				if buffer[position] != rune('c') {
					goto l463
				}
				position++
				if buffer[position] != rune('l') {
					goto l463
				}
				position++
				if buffer[position] != rune('u') {
					goto l463
				}
				position++
				if buffer[position] != rune('d') {
					goto l463
				}
				position++
				if buffer[position] != rune('e') {
					goto l463
				}
				position++
				{
					position465, tokenIndex465 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l465
					}
					goto l463
				l465:
					position, tokenIndex = position465, tokenIndex465
				}
			l466:
				{
					position467, tokenIndex467 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l467
					}
					goto l466
				l467:
					position, tokenIndex = position467, tokenIndex467
				}
				add(ruleINCLUDE, position464)
			}
			return true
		l463:
			position, tokenIndex = position463, tokenIndex463
			return false
		},
		/* 76 CPPINCLUDE <- <(Skip ('c' 'p' 'p' '_' 'i' 'n' 'c' 'l' 'u' 'd' 'e') !LetterOrDigit Indent*)> */
		func() bool {
			position468, tokenIndex468 := position, tokenIndex
			{
				position469 := position
				if !_rules[ruleSkip]() {
					goto l468
				}
				if buffer[position] != rune('c') {
					goto l468
				}
				position++
				if buffer[position] != rune('p') {
					goto l468
				}
				position++
				if buffer[position] != rune('p') {
					goto l468
				}
				position++
				if buffer[position] != rune('_') {
					goto l468
				}
				position++
				if buffer[position] != rune('i') {
					goto l468
				}
				position++
				if buffer[position] != rune('n') {
					goto l468
				}
				position++
				if buffer[position] != rune('c') {
					goto l468
				}
				position++
				if buffer[position] != rune('l') {
					goto l468
				}
				position++
				if buffer[position] != rune('u') {
					goto l468
				}
				position++
				if buffer[position] != rune('d') {
					goto l468
				}
				position++
				if buffer[position] != rune('e') {
					goto l468
				}
				position++
				{
					position470, tokenIndex470 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l470
					}
					goto l468
				l470:
					position, tokenIndex = position470, tokenIndex470
				}
			l471:
				{
					position472, tokenIndex472 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l472
					}
					goto l471
				l472:
					position, tokenIndex = position472, tokenIndex472
				}
				add(ruleCPPINCLUDE, position469)
			}
			return true
		l468:
			position, tokenIndex = position468, tokenIndex468
			return false
		},
		/* 77 NAMESPACE <- <(Skip ('n' 'a' 'm' 'e' 's' 'p' 'a' 'c' 'e') !LetterOrDigit Indent*)> */
		func() bool {
			position473, tokenIndex473 := position, tokenIndex
			{
				position474 := position
				if !_rules[ruleSkip]() {
					goto l473
				}
				if buffer[position] != rune('n') {
					goto l473
				}
				position++
				if buffer[position] != rune('a') {
					goto l473
				}
				position++
				if buffer[position] != rune('m') {
					goto l473
				}
				position++
				if buffer[position] != rune('e') {
					goto l473
				}
				position++
				if buffer[position] != rune('s') {
					goto l473
				}
				position++
				if buffer[position] != rune('p') {
					goto l473
				}
				position++
				if buffer[position] != rune('a') {
					goto l473
				}
				position++
				if buffer[position] != rune('c') {
					goto l473
				}
				position++
				if buffer[position] != rune('e') {
					goto l473
				}
				position++
				{
					position475, tokenIndex475 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l475
					}
					goto l473
				l475:
					position, tokenIndex = position475, tokenIndex475
				}
			l476:
				{
					position477, tokenIndex477 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l477
					}
					goto l476
				l477:
					position, tokenIndex = position477, tokenIndex477
				}
				add(ruleNAMESPACE, position474)
			}
			return true
		l473:
			position, tokenIndex = position473, tokenIndex473
			return false
		},
		/* 78 CPPTYPE <- <(Skip ('c' 'p' 'p' '_' 't' 'y' 'p' 'e') !LetterOrDigit Indent*)> */
		func() bool {
			position478, tokenIndex478 := position, tokenIndex
			{
				position479 := position
				if !_rules[ruleSkip]() {
					goto l478
				}
				if buffer[position] != rune('c') {
					goto l478
				}
				position++
				if buffer[position] != rune('p') {
					goto l478
				}
				position++
				if buffer[position] != rune('p') {
					goto l478
				}
				position++
				if buffer[position] != rune('_') {
					goto l478
				}
				position++
				if buffer[position] != rune('t') {
					goto l478
				}
				position++
				if buffer[position] != rune('y') {
					goto l478
				}
				position++
				if buffer[position] != rune('p') {
					goto l478
				}
				position++
				if buffer[position] != rune('e') {
					goto l478
				}
				position++
				{
					position480, tokenIndex480 := position, tokenIndex
					if !_rules[ruleLetterOrDigit]() {
						goto l480
					}
					goto l478
				l480:
					position, tokenIndex = position480, tokenIndex480
				}
			l481:
				{
					position482, tokenIndex482 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l482
					}
					goto l481
				l482:
					position, tokenIndex = position482, tokenIndex482
				}
				add(ruleCPPTYPE, position479)
			}
			return true
		l478:
			position, tokenIndex = position478, tokenIndex478
			return false
		},
		/* 79 LBRK <- <(Skip '[' Indent*)> */
		func() bool {
			position483, tokenIndex483 := position, tokenIndex
			{
				position484 := position
				if !_rules[ruleSkip]() {
					goto l483
				}
				if buffer[position] != rune('[') {
					goto l483
				}
				position++
			l485:
				{
					position486, tokenIndex486 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l486
					}
					goto l485
				l486:
					position, tokenIndex = position486, tokenIndex486
				}
				add(ruleLBRK, position484)
			}
			return true
		l483:
			position, tokenIndex = position483, tokenIndex483
			return false
		},
		/* 80 RBRK <- <(Skip ']' Indent*)> */
		func() bool {
			position487, tokenIndex487 := position, tokenIndex
			{
				position488 := position
				if !_rules[ruleSkip]() {
					goto l487
				}
				if buffer[position] != rune(']') {
					goto l487
				}
				position++
			l489:
				{
					position490, tokenIndex490 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l490
					}
					goto l489
				l490:
					position, tokenIndex = position490, tokenIndex490
				}
				add(ruleRBRK, position488)
			}
			return true
		l487:
			position, tokenIndex = position487, tokenIndex487
			return false
		},
		/* 81 LWING <- <(Skip '{' Indent*)> */
		func() bool {
			position491, tokenIndex491 := position, tokenIndex
			{
				position492 := position
				if !_rules[ruleSkip]() {
					goto l491
				}
				if buffer[position] != rune('{') {
					goto l491
				}
				position++
			l493:
				{
					position494, tokenIndex494 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l494
					}
					goto l493
				l494:
					position, tokenIndex = position494, tokenIndex494
				}
				add(ruleLWING, position492)
			}
			return true
		l491:
			position, tokenIndex = position491, tokenIndex491
			return false
		},
		/* 82 RWING <- <(Skip '}' Indent*)> */
		func() bool {
			position495, tokenIndex495 := position, tokenIndex
			{
				position496 := position
				if !_rules[ruleSkip]() {
					goto l495
				}
				if buffer[position] != rune('}') {
					goto l495
				}
				position++
			l497:
				{
					position498, tokenIndex498 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l498
					}
					goto l497
				l498:
					position, tokenIndex = position498, tokenIndex498
				}
				add(ruleRWING, position496)
			}
			return true
		l495:
			position, tokenIndex = position495, tokenIndex495
			return false
		},
		/* 83 EQUAL <- <(Skip '=' Indent*)> */
		func() bool {
			position499, tokenIndex499 := position, tokenIndex
			{
				position500 := position
				if !_rules[ruleSkip]() {
					goto l499
				}
				if buffer[position] != rune('=') {
					goto l499
				}
				position++
			l501:
				{
					position502, tokenIndex502 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l502
					}
					goto l501
				l502:
					position, tokenIndex = position502, tokenIndex502
				}
				add(ruleEQUAL, position500)
			}
			return true
		l499:
			position, tokenIndex = position499, tokenIndex499
			return false
		},
		/* 84 LPOINT <- <(Skip '<' Indent*)> */
		func() bool {
			position503, tokenIndex503 := position, tokenIndex
			{
				position504 := position
				if !_rules[ruleSkip]() {
					goto l503
				}
				if buffer[position] != rune('<') {
					goto l503
				}
				position++
			l505:
				{
					position506, tokenIndex506 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l506
					}
					goto l505
				l506:
					position, tokenIndex = position506, tokenIndex506
				}
				add(ruleLPOINT, position504)
			}
			return true
		l503:
			position, tokenIndex = position503, tokenIndex503
			return false
		},
		/* 85 RPOINT <- <(Skip '>' Indent*)> */
		func() bool {
			position507, tokenIndex507 := position, tokenIndex
			{
				position508 := position
				if !_rules[ruleSkip]() {
					goto l507
				}
				if buffer[position] != rune('>') {
					goto l507
				}
				position++
			l509:
				{
					position510, tokenIndex510 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l510
					}
					goto l509
				l510:
					position, tokenIndex = position510, tokenIndex510
				}
				add(ruleRPOINT, position508)
			}
			return true
		l507:
			position, tokenIndex = position507, tokenIndex507
			return false
		},
		/* 86 COMMA <- <(Skip ',' Indent*)> */
		func() bool {
			position511, tokenIndex511 := position, tokenIndex
			{
				position512 := position
				if !_rules[ruleSkip]() {
					goto l511
				}
				if buffer[position] != rune(',') {
					goto l511
				}
				position++
			l513:
				{
					position514, tokenIndex514 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l514
					}
					goto l513
				l514:
					position, tokenIndex = position514, tokenIndex514
				}
				add(ruleCOMMA, position512)
			}
			return true
		l511:
			position, tokenIndex = position511, tokenIndex511
			return false
		},
		/* 87 LPAR <- <(Skip '(' Indent*)> */
		func() bool {
			position515, tokenIndex515 := position, tokenIndex
			{
				position516 := position
				if !_rules[ruleSkip]() {
					goto l515
				}
				if buffer[position] != rune('(') {
					goto l515
				}
				position++
			l517:
				{
					position518, tokenIndex518 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l518
					}
					goto l517
				l518:
					position, tokenIndex = position518, tokenIndex518
				}
				add(ruleLPAR, position516)
			}
			return true
		l515:
			position, tokenIndex = position515, tokenIndex515
			return false
		},
		/* 88 RPAR <- <(Skip ')' Indent*)> */
		func() bool {
			position519, tokenIndex519 := position, tokenIndex
			{
				position520 := position
				if !_rules[ruleSkip]() {
					goto l519
				}
				if buffer[position] != rune(')') {
					goto l519
				}
				position++
			l521:
				{
					position522, tokenIndex522 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l522
					}
					goto l521
				l522:
					position, tokenIndex = position522, tokenIndex522
				}
				add(ruleRPAR, position520)
			}
			return true
		l519:
			position, tokenIndex = position519, tokenIndex519
			return false
		},
		/* 89 COLON <- <(Skip ':' Indent*)> */
		func() bool {
			position523, tokenIndex523 := position, tokenIndex
			{
				position524 := position
				if !_rules[ruleSkip]() {
					goto l523
				}
				if buffer[position] != rune(':') {
					goto l523
				}
				position++
			l525:
				{
					position526, tokenIndex526 := position, tokenIndex
					if !_rules[ruleIndent]() {
						goto l526
					}
					goto l525
				l526:
					position, tokenIndex = position526, tokenIndex526
				}
				add(ruleCOLON, position524)
			}
			return true
		l523:
			position, tokenIndex = position523, tokenIndex523
			return false
		},
		nil,
	}
	p.rules = _rules
	return nil
}
